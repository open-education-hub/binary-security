"use strict";(self.webpackChunkbinary_security=self.webpackChunkbinary_security||[]).push([[8797],{2403:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/handle_LIST-eaf7cb36cd6f261db6c91508e7e0635a.png"},2818:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/handle_child_process-f520438be14ce78f7514ced2194469df.png"},3216:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=t(8168),i=(t(6540),t(5680));const r={},s="Static Analysis",o={unversionedId:"Binary Analysis/Static Analysis/Reading/README",id:"Binary Analysis/Static Analysis/Reading/README",title:"Static Analysis",description:"Introduction",source:"@site/docs/Binary Analysis/Static Analysis/Reading/README.md",sourceDirName:"Binary Analysis/Static Analysis/Reading",slug:"/Binary Analysis/Static Analysis/Reading/",permalink:"/binary-security/Binary Analysis/Static Analysis/Reading/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Static Analysis",permalink:"/binary-security/Binary Analysis/Static Analysis/"},next:{title:"Drills",permalink:"/binary-security/Binary Analysis/Static Analysis/Drills/"}},l={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Disassembling Executables",id:"disassembling-executables",level:2},{value:"Linear Sweep",id:"linear-sweep",level:3},{value:"Recursive Traversal",id:"recursive-traversal",level:3},{value:"IDA and Ghidra",id:"ida-and-ghidra",level:2},{value:"IDA tips &amp; tricks",id:"ida-tips--tricks",level:3},{value:"IDA Pro and Ghidra",id:"ida-pro-and-ghidra",level:3},{value:"C++",id:"c",level:2},{value:"Further reading",id:"further-reading",level:2},{value:"Challenges",id:"challenges",level:2},{value:"04. <code>crypto_crackme</code>",id:"04-crypto_crackme",level:3},{value:"05. broken",id:"05-broken",level:3},{value:"06. <code>hyp3rs3rv3r</code>",id:"06-hyp3rs3rv3r",level:3}],c={toc:p},d="wrapper";function h({components:e,...n}){return(0,i.yg)(d,(0,a.A)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"static-analysis"},"Static Analysis"),(0,i.yg)("h2",{id:"introduction"},"Introduction"),(0,i.yg)("p",null,"Sometimes we are either unable or reluctant to run an unknown executable.\nThis inability to run the file can be caused by a multitude of factors, such as not having the correct dependencies or runtimes for it.\nIn addition, it is often unsafe to run binaries without analysing them first.\nToday we'll learn about one method of analysis, called ",(0,i.yg)("strong",{parentName:"p"},"static analysis"),"."),(0,i.yg)("p",null,"Thus, static analysis allows us to understand the behaviour of the application by displaying either its assembly code or an equivalent high-level code.\nIn order to obtain the assembly code, via a procedure called ",(0,i.yg)("strong",{parentName:"p"},"disassembling"),", currently there are two approaches being used, which we'll describe in the following sections.\nThe high-level code, is ",(0,i.yg)("em",{parentName:"p"},"deduced")," from the machine code, through a more complex process called ",(0,i.yg)("strong",{parentName:"p"},"decompilation"),", which sometimes might make it a bit inaccurate, when compared to the assembly code."),(0,i.yg)("h2",{id:"disassembling-executables"},"Disassembling Executables"),(0,i.yg)("p",null,"There are two main strategies when it comes to disassembly.\nThey are called ",(0,i.yg)("strong",{parentName:"p"},"Linear Sweep")," and ",(0,i.yg)("strong",{parentName:"p"},"Recursive Traversal"),".\nAs we'll see below, the main difference between the two is their accuracy"),(0,i.yg)("h3",{id:"linear-sweep"},"Linear Sweep"),(0,i.yg)("p",null,"The first strategy that we'll look at is ",(0,i.yg)("em",{parentName:"p"},"Linear Sweep"),".\nA very popular tool that uses this strategy is ",(0,i.yg)("inlineCode",{parentName:"p"},"objdump"),".\nWhat ",(0,i.yg)("em",{parentName:"p"},"Linear Sweep")," does is it parses the ",(0,i.yg)("inlineCode",{parentName:"p"},".text")," section of the executable from the beginning to the end and translates each encountered machine code instruction into its equivalent Assembly instruction.\nIt's a fast and simple algorithm.\nBeing so simple, however, renders it vulnerable to being mislead.\nThis can happen in a few ways.\nOne way is to insert an inappropriate instruction somewhere in the ",(0,i.yg)("inlineCode",{parentName:"p"},".text")," section.\nWhen the algorithm reaches it, it will try to interpret it as something meaningful and output a completely different Assembly code that would make no sense."),(0,i.yg)("p",null,"Let's consider the code below, which is also available ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/hexcellents/sss-exploit/blob/master/sessions/04-static-analysis/activities/01-tutorial-disassemble-methods/src/wrong.c"},"in this repository"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},'int main()\n{\n    asm volatile(\n        "A: jmp B\\n\\t"\n        ".byte 0xde\\n\\t"\n        ".byte 0xad\\n\\t"\n        ".byte 0xc0\\n\\t"\n        ".byte 0xde\\n\\t"\n        "jmp -1\\n\\t"\n        "B:\\n\\t"\n    );\n    printf("What is wrong with me :-s?\\n");\n    return -1;\n}\n')),(0,i.yg)("p",null,"Take a look at the Makefile rule for ",(0,i.yg)("inlineCode",{parentName:"p"},"wrong")," and notice that it ",(0,i.yg)("strong",{parentName:"p"},"strips")," the binary:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-makefile"},"wrong: wrong.o\n    $(CC) $(CFLAGS) $< -o $@\n    -strip $@\n")),(0,i.yg)("p",null,"If we remove the line at the end of the snipped above and then disassemble the executable, we can see our inline assembly code (",(0,i.yg)("inlineCode",{parentName:"p"},"de ad c0 de"),") together with the encoding of ",(0,i.yg)("inlineCode",{parentName:"p"},"jmp -1"),".\nThe binary code is as expected, but the way it's interpreted is completely off.\nThis happens because ",(0,i.yg)("em",{parentName:"p"},"objdump"),' gets "confused" when reaching the bytes ',(0,i.yg)("inlineCode",{parentName:"p"},"de ad c0 de")," and can't figure out that the code is meaningless."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},"080491ab <A>:\n 80491ab:       eb 09                   jmp    80491b6 <B>\n 80491ad:       de ad c0 de e9 49       fisubr WORD PTR [ebp+0x49e9dec0]\n 80491b3:       6e                      outs   dx,BYTE PTR ds:[esi]\n 80491b4:       fb                      sti\n 80491b5:       f7                      .byte 0xf7\n\n080491b6 <B>:\n 80491b6:       83 ec 0c                sub    esp,0xc\n")),(0,i.yg)("p",null,"If we restore the line where the binary is stripped, recompile and disassemble it once more, we see that this time, ",(0,i.yg)("inlineCode",{parentName:"p"},"objdump")," gets completely lost when it encounters our ",(0,i.yg)("inlineCode",{parentName:"p"},"de ad c0 de")," sequence.\nThis is because, previously, it used symbols in the binary, such as ",(0,i.yg)("inlineCode",{parentName:"p"},"B"),", to figure out where some of the real instructions started.\nNow, without the help of those symbols, ",(0,i.yg)("inlineCode",{parentName:"p"},"objdump")," doesn't manage to output a coherent Assembly code."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"}," 804840c:       eb 09                   jmp    8048417 <__libc_start_main@plt+0x127>\n 804840e:       de ad c0 de e9 e8       fisubr WORD PTR [ebp-0x17162140]\n 8048414:       7b fb                   jnp    8048411 <__libc_start_main@plt+0x121>\n 8048416:       f7 83 ec 0c 68 c0 84    test   DWORD PTR [ebx-0x3f97f314],0xe8080484\n 804841d:       04 08 e8\n 8048420:       ac                      lods   al,BYTE PTR ds:[esi]\n 8048421:       fe                      (bad)\n 8048422:       ff                      (bad)\n 8048423:       ff 83 c4 10 b8 ff       inc    DWORD PTR [ebx-0x47ef3c]\n 8048429:       ff                      (bad)\n 804842a:       ff                      (bad)\n 804842b:       ff 8b 4d fc c9 8d       dec    DWORD PTR [ebx-0x723603b3]\n 8048431:       61                      popa\n 8048432:       fc                      cld\n 8048433:       c3                      ret\n")),(0,i.yg)("p",null,"In order to avoid traps like the one showcased above, we need to use smarter disassembly techniques, such as ",(0,i.yg)("em",{parentName:"p"},"Recursive Traversal"),"."),(0,i.yg)("h3",{id:"recursive-traversal"},"Recursive Traversal"),(0,i.yg)("p",null,"Note that, in the example above, the misleading instruction is never executed.\nIf it were, the program would crash after receiving a ",(0,i.yg)("inlineCode",{parentName:"p"},"SIGILL")," signal and after outputting ",(0,i.yg)("inlineCode",{parentName:"p"},"Illegal instruction (core dumped)"),", because the CPU would not know how to decode that particular instruction.\nBut if we run the binary above, we notice that it doesn't crash.\nSo that instruction is nothing but dead code.\nAs a result, it's useless to us no matter what it means.\nAnd this is where ",(0,i.yg)("em",{parentName:"p"},"Recursive Traversal")," comes in."),(0,i.yg)("p",null,"This strategy doesn't start the disassembly at the beginning of the ",(0,i.yg)("inlineCode",{parentName:"p"},".text")," section, but at the entry point (the address of the ",(0,i.yg)("inlineCode",{parentName:"p"},"_start")," symbol) and disassembles the instructions linearly, while also considering ",(0,i.yg)("strong",{parentName:"p"},"jumps"),".\nThus, when encountering code branches, the algorithm follows them and creates what's called a ",(0,i.yg)("strong",{parentName:"p"},"Control Flow Graph (CFG)"),", where each node is called a ",(0,i.yg)("strong",{parentName:"p"},"Basic Block (BB)")," and is made up of instructions that are always executed in that order, regardless of conditional jumps or function calls.\nTake a look at the CFG below and note the BBs and the jumps that make up the arches.\nThe code comes from the ",(0,i.yg)("inlineCode",{parentName:"p"},"hyp3rs3rv3r")," binary, which can be found ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/hexcellents/sss-exploit/tree/master/sessions/04-static-analysis/activities/02-tutorial-ida-time/src"},"here"),".\nTo make things harder, this executable was also stripped.\n",(0,i.yg)("img",{alt:"CFG created by IDA",src:t(3550).A,width:"400",height:"583"})),(0,i.yg)("p",null,"In conclusion, we can look at the CFG as being a DFS (recursive) traversal of the code, separated into BBs, with ",(0,i.yg)("inlineCode",{parentName:"p"},"ret")," instructions acting as ",(0,i.yg)("em",{parentName:"p"},"back edges"),"."),(0,i.yg)("h2",{id:"ida-and-ghidra"},"IDA and Ghidra"),(0,i.yg)("p",null,"The tool that we used in order to generate the image above is called ",(0,i.yg)("a",{parentName:"p",href:"https://www.hex-rays.com/products/ida/support/download_freeware/"},"IDA"),".\nNext, we'll learn how to use it!"),(0,i.yg)("p",null,"We'll showcase the functionalities of IDA by disassembling the ",(0,i.yg)("inlineCode",{parentName:"p"},"hyp3rs3rv3r")," binary.\nThe first screen you are presented with is the following:"),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"Initial IDA Screen",src:t(3473).A,width:"600",height:"396"})),(0,i.yg)("p",null,"Main components:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"On the left you have the ",(0,i.yg)("strong",{parentName:"li"},"Function window")," with the list of identified subroutines, functions or external functions called by the binary.\nThey are color coded according to the legend right above it."),(0,i.yg)("li",{parentName:"ul"},"Under it you have a graph overview of the view presented on the right."),(0,i.yg)("li",{parentName:"ul"},"On the right you have multiple tabs, with the ",(0,i.yg)("strong",{parentName:"li"},"Function summary")," selected in the IDA-view.\nWe will not be using this.\nInstead, we will switch to the complete ",(0,i.yg)("strong",{parentName:"li"},"Graph View")," of functions by pressing the space bar.\nThis graph is the CFG we mentioned earlier.")),(0,i.yg)("p",null,"Upon pressing space bar and navigating in the ",(0,i.yg)("strong",{parentName:"p"},"Function window")," to functions that are not coloured (meaning they are part of this binary) we get the following view:\n",(0,i.yg)("img",{alt:"IDA - First View",src:t(3584).A,width:"600",height:"241"})),(0,i.yg)("p",null,"When reversing binaries, we will see this particular Assembly construct a lot, as it is the standard one generated by ",(0,i.yg)("inlineCode",{parentName:"p"},"gcc"),".\nRemember from ",(0,i.yg)("a",{parentName:"p",href:"../../Executables%20and%20Processes/Reading"},'the "Executables an Processes" session')," that ",(0,i.yg)("a",{parentName:"p",href:"refspecs.linuxbase.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic/baselib---libc-start-main-.html"},(0,i.yg)("inlineCode",{parentName:"a"},"__libc_start_main"))," is the wrapper that calls ",(0,i.yg)("inlineCode",{parentName:"p"},"main"),".\nWe now rename the last argument pushed on the stack to main.\nPress ",(0,i.yg)("inlineCode",{parentName:"p"},"n")," and enter the new name.\nNow you have your first function identified.\nClick on it to see what ",(0,i.yg)("inlineCode",{parentName:"p"},"main")," does:"),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"main",src:t(7557).A,width:"600",height:"348"})),(0,i.yg)("p",null,"Note how the execution is neatly laid out in the CFG view.\nIf you look at the left panel you can see the complete view.\nThe execution is divided because of conditional and unconditional branches.\nLet's figure out what happens by analyzing the assembly code:"),(0,i.yg)("p",null,"First we have the function prologue, stack alignment and stack allocation:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},"push    ebp\nmov     ebp, esp\nand     esp, 0FFFFFFF0h\nsub     esp, 450h\n")),(0,i.yg)("p",null,"Next, a variable on the stack is initialized to 1.\nIf you click on ",(0,i.yg)("inlineCode",{parentName:"p"},"434h")," it will become highlighted and you can scroll through the whole function to see where it's used later.\nWe'll ignore this for now."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},"mov     dword ptr [esp+434h], 1\n")),(0,i.yg)("p",null,"Next, we see the first branching:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},"cmp     [ebp+arg_0], 2\njz      short loc_8049068\n")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Remember"),":\nOn 32 bit systems, ",(0,i.yg)("inlineCode",{parentName:"p"},"[ebp + 0]")," is the saved ",(0,i.yg)("inlineCode",{parentName:"p"},"ebp"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"[ebp + 4]")," is the return address and ",(0,i.yg)("inlineCode",{parentName:"p"},"[ebp + 8]")," is the first argument to the current function.\nIDA follows a slightly different naming convention: ",(0,i.yg)("inlineCode",{parentName:"p"},"[ebp + 8]")," is named ",(0,i.yg)("inlineCode",{parentName:"p"},"[ebp+arg_0]"),". ",(0,i.yg)("inlineCode",{parentName:"p"},"[ebp + 12]")," is named ",(0,i.yg)("inlineCode",{parentName:"p"},"[ebp+arg_4]")," etc.\nYou can rename those ",(0,i.yg)("inlineCode",{parentName:"p"},"arg_*")," constructs if you want, anyway."),(0,i.yg)("p",null,"So it's referring to the first argument: ",(0,i.yg)("inlineCode",{parentName:"p"},"argc"),".\nBasically, what it does is:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},"if(argc == 2) {\n    goto loc_8049068\n} else {\n....\n}\n")),(0,i.yg)("p",null,"What does the ",(0,i.yg)("inlineCode",{parentName:"p"},"else")," branch do?"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},'mov     eax, [ebp+arg_4]\nmov     eax, [eax]\nmov     [esp+4], eax\nmov     dword ptr [esp], offset format ; "Usage: %s <banner_file>\\n"\ncall    _printf\n\nmov     dword ptr [esp], 0 ; status\ncall    _exit\n')),(0,i.yg)("p",null,"It's pretty straightforward if you remember the tasks from ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/hexcellents/sss-exploit/tree/master/sessions/03-executable-file-formats"},"Session 02"),".\nThe second argument (",(0,i.yg)("inlineCode",{parentName:"p"},"argv"),") is dereferenced and pushed on the stack along with a format string.\nThen ",(0,i.yg)("inlineCode",{parentName:"p"},"printf")," is called.\nNext, ",(0,i.yg)("inlineCode",{parentName:"p"},"exit")," is called with a status of 0."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},'if(argc == 2) {\n    goto loc_8049068\n} else {\n    printf("%s <banner_file>\\n", argv[0]);\n    exit(0);\n}\n')),(0,i.yg)("p",null,"Now let's do something a bit more advanced: we want to identify the 2 commands that the server accepts by using static analysis.\nHow do we approach this problem as fast as possible?\nWe already know that the server accepts multiple clients.\nIt can do this through forking.\nLet's see where ",(0,i.yg)("inlineCode",{parentName:"p"},"fork")," is called in the program.\nFirst find the ",(0,i.yg)("inlineCode",{parentName:"p"},"fork")," function on the left panel and select it.\nNow you see a stub to it from the ",(0,i.yg)("inlineCode",{parentName:"p"},"PLT")," section.\nWe want to find all locations in the program that call this function.\nYou can achieve this by obtaining all the ",(0,i.yg)("strong",{parentName:"p"},"cross-references (xrefs)")," to it by pressing ",(0,i.yg)("inlineCode",{parentName:"p"},"x"),".\nYou should get the following screen:"),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"fork cross-references 1",src:t(4549).A,width:"600",height:"347"})),(0,i.yg)("p",null,"Click that location and you will get to the forking point:"),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"fork cross-references 2",src:t(3550).A,width:"400",height:"583"})),(0,i.yg)("p",null,"You can see that the return value is stored on the stack at ",(0,i.yg)("inlineCode",{parentName:"p"},"[esp+438h]"),", some error checking (",(0,i.yg)("inlineCode",{parentName:"p"},"perror")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"exit"),") is done and then the return value is checked for 0 (as we traditionally do for ",(0,i.yg)("inlineCode",{parentName:"p"},"fork")," calls).\nThe child will execute ",(0,i.yg)("inlineCode",{parentName:"p"},"sub_8048ED7")," and the parent will loop back.\nYou can rename ",(0,i.yg)("inlineCode",{parentName:"p"},"sub_8048ED7")," to something more legible such as ",(0,i.yg)("inlineCode",{parentName:"p"},"handle_child_process"),"\nIn this function you can now clearly see the two commands and which function is called for each:"),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"handle_child_process",src:t(2818).A,width:"600",height:"571"})),(0,i.yg)("p",null,"It looks like the one on the left, ",(0,i.yg)("inlineCode",{parentName:"p"},"sub_8048B0B")," handles the ",(0,i.yg)("inlineCode",{parentName:"p"},"LIST")," command so we rename it to ",(0,i.yg)("inlineCode",{parentName:"p"},"handle_LIST"),".\nAs expected, it calls ",(0,i.yg)("inlineCode",{parentName:"p"},"opendir")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"readdir")," to read all the files in the current directory, then writes them to the socket."),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"handle_LIST",src:t(2403).A,width:"400",height:"539"})),(0,i.yg)("h3",{id:"ida-tips--tricks"},"IDA tips & tricks"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Saving progress is disabled for the trial version.\nHowever, you can save a limited (but useful) subset of your work using ",(0,i.yg)("inlineCode",{parentName:"li"},"File -> Produce File -> Dump database to IDC file")," and then load it next time using ",(0,i.yg)("inlineCode",{parentName:"li"},"File -> Script File"),"."),(0,i.yg)("li",{parentName:"ul"},"If you close some windows and don't know how to get them back you can reset the layout using ",(0,i.yg)("inlineCode",{parentName:"li"},"Windows->Reset Desktop"),"."),(0,i.yg)("li",{parentName:"ul"},"If you want to return to the previous view you can press ",(0,i.yg)("inlineCode",{parentName:"li"},"Escape"),"."),(0,i.yg)("li",{parentName:"ul"},"When you want to view code as in ",(0,i.yg)("inlineCode",{parentName:"li"},"objdump")," you only need to press ",(0,i.yg)("inlineCode",{parentName:"li"},"Spacebar")," once.\nAnd then again to return to CFG mode."),(0,i.yg)("li",{parentName:"ul"},"If there is a hex value and you want to convert it to decimal (or back) press ",(0,i.yg)("inlineCode",{parentName:"li"},"h"),"."),(0,i.yg)("li",{parentName:"ul"},"Converting hex/dec values to ",(0,i.yg)("em",{parentName:"li"},"ASCII"),": press ",(0,i.yg)("inlineCode",{parentName:"li"},"r"),"."),(0,i.yg)("li",{parentName:"ul"},"If you want to write comments next to an instruction or a function press ",(0,i.yg)("inlineCode",{parentName:"li"},":"),".")),(0,i.yg)("h3",{id:"ida-pro-and-ghidra"},"IDA Pro and Ghidra"),(0,i.yg)("p",null,"IDA Pro is installed on the Kali virtual machine.\nThe main difference between it and the free version is that the Pro one can also ",(0,i.yg)("strong",{parentName:"p"},"decompile")," the code based on the CFGs listed above.\nThis will come in extremely useful as we hack more and more binaries."),(0,i.yg)("p",null,"Another tool that is capable of decompiling the code in an executable is ",(0,i.yg)("a",{parentName:"p",href:"https://ghidra-sre.org/"},"Ghidra"),".\nOne advantage of Ghidra over IDA is that Ghidra displays both the C and the Assembly code side by side.\nThis allows us to correlate the two and reap the benefits of both of them at the same time."),(0,i.yg)("h2",{id:"c"},"C++"),(0,i.yg)("p",null,"Things look slightly different when we try to hack executables that have been compiled from C++ code, instead of C.\nThe difference comes from the way symbols (method symbols in particular) are handled by C++ compilers.\nLet's disassemble the code below and see how its symbols look:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-cpp"},'##include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    cout << "Hello world" << endl;\n    return 0;\n}\n')),(0,i.yg)("p",null,"Disassembling it in IDA looks familiar at first"),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"IDA start",src:t(3928).A,width:"400",height:"379"})),(0,i.yg)("p",null,"But then the fun starts:"),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"IDA main",src:t(4957).A,width:"550",height:"343"})),(0,i.yg)("p",null,"As we can see, all symbols look almost as if they were encrypted.\nIn fact, this process is called ",(0,i.yg)("strong",{parentName:"p"},"name mangling"),".\nIf we take a closer look at them, however, we can distinguish some clues about those function calls, for example.\nThe first one contains the sequences ",(0,i.yg)("inlineCode",{parentName:"p"},"char_traits")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"basic_ostream"),", the former being a C++ abstraction for string operations, while the latter is a base class for output operators, such as ",(0,i.yg)("inlineCode",{parentName:"p"},"<<"),"."),(0,i.yg)("p",null,"IDA can demangle strings such as the ones above by itself.\nSome recommended settings (you may prefer something different) are the following:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Options -> Demangled names")),(0,i.yg)("li",{parentName:"ul"},"Show demangled C++ names as ",(0,i.yg)("inlineCode",{parentName:"li"},"Names")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Setup short names")),(0,i.yg)("li",{parentName:"ul"},"Click ",(0,i.yg)("inlineCode",{parentName:"li"},"Only main name"))),(0,i.yg)("p",null,"These settings only display the important classes and namespaces that make up each method, like this:"),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"IDA demangled",src:t(5265).A,width:"521",height:"416"})),(0,i.yg)("h2",{id:"further-reading"},"Further reading"),(0,i.yg)("p",null,"More information about name mangling can be obtained at:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Name_mangling"},"https://en.wikipedia.org/wiki/Name_mangling")),(0,i.yg)("li",{parentName:"ul"},"on demand demangling: ",(0,i.yg)("a",{parentName:"li",href:"http://demangler.com/"},"http://demangler.com/")," or ",(0,i.yg)("inlineCode",{parentName:"li"},"c++filt"))),(0,i.yg)("p",null,"You can find out more information about the internals of C++ in general, using the following references:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://ocw.cs.pub.ro/courses/cpl/labs/06"},"https://ocw.cs.pub.ro/courses/cpl/labs/06")," (in Romanian)"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.blackhat.com/presentations/bh-dc-07/Sabanal_Yason/Paper/bh-dc-07-Sabanal_Yason-WP.pdf"},"https://www.blackhat.com/presentations/bh-dc-07/Sabanal_Yason/Paper/bh-dc-07-Sabanal_Yason-WP.pdf")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"http://www.hexblog.com/wp-content/uploads/2011/08/Recon-2011-Skochinsky.pdf"},"http://www.hexblog.com/wp-content/uploads/2011/08/Recon-2011-Skochinsky.pdf"))),(0,i.yg)("h2",{id:"challenges"},"Challenges"),(0,i.yg)("h3",{id:"04-crypto_crackme"},"04. ",(0,i.yg)("inlineCode",{parentName:"h3"},"crypto_crackme")),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"crypto_crackme")," binary is an application that asks for a secret and uses it to decrypt a message.\nIn order to solve this task, you have to retrieve the message."),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Open the binary using IDA and determine the program control flow.\nWhat is it doing after fetching the secret?\nIt seems to be consuming a lot of CPU cycles.\nIf possible, use IDA to patch the program and reduce the execution time of the application.\nUse ",(0,i.yg)("inlineCode",{parentName:"li"},"Edit -> Patch program -> Change byte...")),(0,i.yg)("li",{parentName:"ul"},"Next, it looks like the program tries to verify if the secret provided is correct.\nWhere is the secret stored?\nIs it stored in plain text?\nFind out what the validation algorithm is."),(0,i.yg)("li",{parentName:"ul"},"Now break it and retrieve the message!")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Important!"),":\nUnfortunately, the virtual machine doesn't support the ",(0,i.yg)("inlineCode",{parentName:"p"},"libssl1.0.0")," version of ",(0,i.yg)("inlineCode",{parentName:"p"},"SSL")," library.\nUse the library files in the task archive and run the executable using:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"LD_LIBRARY_PATH=. ./crypto_crackme\n")),(0,i.yg)("p",null,"You can break password hashes (including SHA1) on ",(0,i.yg)("a",{parentName:"p",href:"https://crackstation.net/"},(0,i.yg)("inlineCode",{parentName:"a"},"CrackStation")),"."),(0,i.yg)("h3",{id:"05-broken"},"05. broken"),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"broken")," binary is asking you for the correct password.\nInvestigate the binary and provide it with the correct password.\nIf you provided the correct password the message ",(0,i.yg)("inlineCode",{parentName:"p"},"That's correct! The password is '...'"),"."),(0,i.yg)("h3",{id:"06-hyp3rs3rv3r"},"06. ",(0,i.yg)("inlineCode",{parentName:"h3"},"hyp3rs3rv3r")),(0,i.yg)("p",null,"Investigate the ",(0,i.yg)("inlineCode",{parentName:"p"},"hyp3rs3rv3r")," binary and find out where the backdoor function is.\nNote that since it's not directly called, IDA doesn't think of it as a procedure, so it won't come up on the left pane.\nFigure out a way around this.\nWhen you find that code block you can press ",(0,i.yg)("inlineCode",{parentName:"p"},"p")," on the first instruction to help IDA see it as a procedure."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Hint"),":\nIn order to exploit the vulnerability in Ubuntu, you should use ",(0,i.yg)("inlineCode",{parentName:"p"},"netcat-traditional"),".\nYou can switch from ",(0,i.yg)("inlineCode",{parentName:"p"},"netcat-openbsd")," to ",(0,i.yg)("inlineCode",{parentName:"p"},"netcat-traditional")," using the steps described ",(0,i.yg)("a",{parentName:"p",href:"https://stackoverflow.com/questions/10065993/how-to-switch-to-netcat-traditional-in-ubuntu"},"here"),"."))}h.isMDXComponent=!0},3473:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/ida_initial_screen-2ccb264922a514f0f40dbc43ea8dff4f.png"},3550:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/fork_xref_2-cbbaaa29d6a79b16ccf9c7d72cc30a37.png"},3584:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/ida_first_view-15240b5bcf4ffef9a1a20eea4decd16f.png"},3928:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/ida_c++_start-e9f9ebb679d097cf91802b3850951f91.png"},4549:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/fork_xref_1-85f1d0232651a1b8e0dc2df57af3979f.png"},4957:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/ida_c++_main-07869074429c34f45c71bade45f6c02d.png"},5265:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/ida_c++_demangled-849d03717ab1cd61335f6f35be59b9e6.png"},5680:(e,n,t)=>{t.d(n,{xA:()=>c,yg:()=>m});var a=t(6540);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},g=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(t),g=i,m=d["".concat(l,".").concat(g)]||d[g]||h[g]||r;return t?a.createElement(m,s(s({ref:n},c),{},{components:t})):a.createElement(m,s({ref:n},c))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,s=new Array(r);s[0]=g;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o[d]="string"==typeof e?e:i,s[1]=o;for(var p=2;p<r;p++)s[p]=t[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}g.displayName="MDXCreateElement"},7557:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/ida_main-843538c9f43f8c93ebd5a3617728722e.png"}}]);