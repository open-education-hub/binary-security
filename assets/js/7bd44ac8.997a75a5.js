"use strict";(self.webpackChunkbinary_security=self.webpackChunkbinary_security||[]).push([[6584],{5680:(e,n,a)=>{a.d(n,{xA:()=>p,yg:()=>y});var t=a(6540);function i(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function r(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function l(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?r(Object(a),!0).forEach((function(n){i(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function o(e,n){if(null==e)return{};var a,t,i=function(e,n){if(null==e)return{};var a,t,i={},r=Object.keys(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=t.createContext({}),c=function(e){var n=t.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):l(l({},n),e)),a},p=function(e){var n=c(e.components);return t.createElement(s.Provider,{value:n},e.children)},d="mdxType",g={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},m=t.forwardRef((function(e,n){var a=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(a),m=i,y=d["".concat(s,".").concat(m)]||d[m]||g[m]||r;return a?t.createElement(y,l(l({ref:n},p),{},{components:a})):t.createElement(y,l({ref:n},p))}));function y(e,n){var a=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=m;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[d]="string"==typeof e?e:i,l[1]=o;for(var c=2;c<r;c++)l[c]=a[c];return t.createElement.apply(null,l)}return t.createElement.apply(null,a)}m.displayName="MDXCreateElement"},7562:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>g,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var t=a(8168),i=(a(6540),a(5680));const r={},l="Exploration Tools",o={unversionedId:"Binary Analysis/Exploration Tools/Reading/README",id:"Binary Analysis/Exploration Tools/Reading/README",title:"Exploration Tools",description:"Tutorials",source:"@site/docs/Binary Analysis/Exploration Tools/Reading/README.md",sourceDirName:"Binary Analysis/Exploration Tools/Reading",slug:"/Binary Analysis/Exploration Tools/Reading/",permalink:"/binary-security/Binary Analysis/Exploration Tools/Reading/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Exploration Tools",permalink:"/binary-security/Binary Analysis/Exploration Tools/"},next:{title:"Exploration-Tools",permalink:"/binary-security/Binary Analysis/Exploration Tools/Exploration-Tools"}},s={},c=[{value:"Tutorials",id:"tutorials",level:2},{value:"01. Tutorial - Poor Man&#39;s Technique: <code>strings</code>",id:"01-tutorial---poor-mans-technique-strings",level:3},{value:"02. Tutorial - Execution Tracing (<code>ltrace</code> and <code>strace</code>)",id:"02-tutorial---execution-tracing-ltrace-and-strace",level:3},{value:"03. Tutorial - Symbols: <code>nm</code>",id:"03-tutorial---symbols-nm",level:3},{value:"04. Tutorial - Library Dependencies",id:"04-tutorial---library-dependencies",level:3},{value:"Library Wrapper Task",id:"library-wrapper-task",level:4},{value:"05. Tutorial - Network: <code>netstat</code> and <code>netcat</code>",id:"05-tutorial---network-netstat-and-netcat",level:3},{value:"Doing it in Python",id:"doing-it-in-python",level:4},{value:"Doing it Only with <code>netcat</code>",id:"doing-it-only-with-netcat",level:4},{value:"06. Tutorial - Open files",id:"06-tutorial---open-files",level:3},{value:"Misc",id:"misc",level:4},{value:"Challenges",id:"challenges",level:2},{value:"07. Challenge - Perfect Answer",id:"07-challenge---perfect-answer",level:3},{value:"08. Challenge - Lots of strings",id:"08-challenge---lots-of-strings",level:3},{value:"09. Challenge - Sleepy cats",id:"09-challenge---sleepy-cats",level:3},{value:"10. Challenge - Hidden",id:"10-challenge---hidden",level:3},{value:"11. Challenge - Detective",id:"11-challenge---detective",level:3},{value:"Bonus: Get the Second Flag",id:"bonus-get-the-second-flag",level:4},{value:"Extra",id:"extra",level:3},{value:"Further pwning",id:"further-pwning",level:3},{value:"Further Reading",id:"further-reading",level:2}],p={toc:c},d="wrapper";function g(e){let{components:n,...r}=e;return(0,i.yg)(d,(0,t.A)({},p,r,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"exploration-tools"},"Exploration Tools"),(0,i.yg)("h2",{id:"tutorials"},"Tutorials"),(0,i.yg)("p",null,"When faced with a binary with no source or parts of the source missing you can infer some of its functionalities based upon some basic reconnaissance techniques using various tools."),(0,i.yg)("h3",{id:"01-tutorial---poor-mans-technique-strings"},"01. Tutorial - Poor Man's Technique: ",(0,i.yg)("inlineCode",{parentName:"h3"},"strings")),(0,i.yg)("p",null,"The simplest recon technique is to dump the ASCII (or Unicode) text from a binary.\nIt doesn't offer any guarantees but sometimes you can get a lot of useful information out of it."),(0,i.yg)("p",null,"By default, when applied to a binary it only scans the data section.\nTo obtain information such as the compiler version used in producing the binary use:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"strings -a crackme1\n")),(0,i.yg)("p",null,"Let's illustrate how ",(0,i.yg)("inlineCode",{parentName:"p"},"strings")," can be useful in a simple context.\nTry out the ",(0,i.yg)("a",{parentName:"p",href:"activities/01-tutorial-strings/src"},(0,i.yg)("inlineCode",{parentName:"a"},"crackme1"))," binary:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint my_strcmp(char *s1, char *s2)\n{\n    size_t i, len = strlen(s1);\n    if (len == 0)\n        return -1;\n    for (i = 0; i < len; i++)\n        if (s1[i] != s2[i])\n            return -1;\n\n    return 0;\n}\n\nint main()\n{\n    char buf[1000];\n\n    printf("Password:\\n");\n    if (fgets(buf, 1000, stdin) == NULL)\n        exit(-1);\n\n    buf[strlen(buf) - 1] = \'\\0\';\n\n    if (!my_strcmp(buf, ???????????????????????)) {\n        printf("Correct!\\n");\n    } else\n        printf("Nope!\\n");\n\n    return 0;\n}\n')),(0,i.yg)("p",null,"The password has been redacted from the listing but you can retrieve it with ",(0,i.yg)("inlineCode",{parentName:"p"},"strings"),".\nTry it out!"),(0,i.yg)("h3",{id:"02-tutorial---execution-tracing-ltrace-and-strace"},"02. Tutorial - Execution Tracing (",(0,i.yg)("inlineCode",{parentName:"h3"},"ltrace")," and ",(0,i.yg)("inlineCode",{parentName:"h3"},"strace"),")"),(0,i.yg)("p",null,(0,i.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man1/ltrace.1.html"},(0,i.yg)("inlineCode",{parentName:"a"},"ltrace"))," is an utility that can list library function calls or ",(0,i.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man2/syscalls.2.html"},"syscalls")," made by a program.\n",(0,i.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man1/strace.1.html"},(0,i.yg)("inlineCode",{parentName:"a"},"strace"))," is similar, but only lists syscalls.\nA syscall is a service exposed by the kernel itself."),(0,i.yg)("p",null,"The way they work is with the aid of a special syscall, called ",(0,i.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man2/ptrace.2.html"},(0,i.yg)("inlineCode",{parentName:"a"},"ptrace")),".\nThis single syscall forms the basis for most of the functionality provided by ",(0,i.yg)("inlineCode",{parentName:"p"},"ltrace"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"strace"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"gdb")," and similar tools that debug programs.\nIt can receive up to 4 arguments: the operation, the PID to act on, the address to read/write and the data to write.\nThe functionality exposed by ",(0,i.yg)("inlineCode",{parentName:"p"},"ptrace()")," is massive, but think of any functionality you've seen in a debugger:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"attach/detach to/from a process"),(0,i.yg)("li",{parentName:"ul"},"set breakpoints"),(0,i.yg)("li",{parentName:"ul"},"continue a stopped program"),(0,i.yg)("li",{parentName:"ul"},"read/write registers"),(0,i.yg)("li",{parentName:"ul"},"act on signals"),(0,i.yg)("li",{parentName:"ul"},"register syscalls")),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"strace")," provides some pretty printing strictly concerning the syscalls of the traced process.\nHowever, ",(0,i.yg)("inlineCode",{parentName:"p"},"ltrace")," provides further functionality and gathers information about all library calls.\nHere's how ",(0,i.yg)("inlineCode",{parentName:"p"},"ltrace")," does its magic:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"it reads the ",(0,i.yg)("inlineCode",{parentName:"li"},"tracee")," memory and parses it in order to find out about loaded symbols"),(0,i.yg)("li",{parentName:"ul"},"it makes a copy of the binary code pertaining to a symbol using a ",(0,i.yg)("inlineCode",{parentName:"li"},"PTRACE_PEEKTEXT")," directive of ",(0,i.yg)("inlineCode",{parentName:"li"},"ptrace()")),(0,i.yg)("li",{parentName:"ul"},"it injects a breakpoint using a ",(0,i.yg)("inlineCode",{parentName:"li"},"PTRACE_POKETEXT")," directive of ",(0,i.yg)("inlineCode",{parentName:"li"},"ptrace()")),(0,i.yg)("li",{parentName:"ul"},"it listens for a ",(0,i.yg)("inlineCode",{parentName:"li"},"SIGTRAP")," which will be generated when the breakpoint is hit"),(0,i.yg)("li",{parentName:"ul"},"when the breakpoint is hit, ltrace can examine the stack of the ",(0,i.yg)("inlineCode",{parentName:"li"},"tracee")," and print information such as function name, parameters, return codes, etc.")),(0,i.yg)("p",null,"Let's try the next ",(0,i.yg)("inlineCode",{parentName:"p"},"crackme"),".\nIf we remove ",(0,i.yg)("inlineCode",{parentName:"p"},"my_strcmp")," from the previous ",(0,i.yg)("inlineCode",{parentName:"p"},"crackme")," you can solve it even without ",(0,i.yg)("inlineCode",{parentName:"p"},"strings")," because ",(0,i.yg)("inlineCode",{parentName:"p"},"strcmp")," is called from ",(0,i.yg)("inlineCode",{parentName:"p"},"libc.so"),".\nYou can use ",(0,i.yg)("inlineCode",{parentName:"p"},"ltrace")," and see what functions are used and check for their given parameters.\nTry it out on the second ",(0,i.yg)("inlineCode",{parentName:"p"},"crackme")," where ",(0,i.yg)("inlineCode",{parentName:"p"},"strings")," does not help (",(0,i.yg)("a",{parentName:"p",href:"activities/02-tutorial-execution-tracing/src"},(0,i.yg)("inlineCode",{parentName:"a"},"crackme2")),"):"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar correct_pass[] = ????????????????? ;\nchar *deobf(char *s)\n{\n    ???????????????\n}\n\nint main()\n{\n    char buf[1000];\n\n    printf("Password:\\n");\n    if (fgets(buf, 1000, stdin) == NULL)\n        exit(-1);\n\n    buf[strlen(buf) - 1] = \'\\0\';\n\n    if (!strcmp(buf, deobf(correct_pass)))\n        printf("Correct!\\n");\n    else\n        printf("Nope!\\n");\n\n    return 0;\n}\n')),(0,i.yg)("h3",{id:"03-tutorial---symbols-nm"},"03. Tutorial - Symbols: ",(0,i.yg)("inlineCode",{parentName:"h3"},"nm")),(0,i.yg)("p",null,"Symbols are basically tags/labels, either for functions or for variables.\nIf you enable debugging symbols you will get information on all the variables defined but normally symbols are only defined for functions and global variables.\nWhen stripping binaries even these can be deleted without any effect on the binary behavior.\nDynamic symbols, however, have to remain so that the linker knows what functions to import:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ file xy\nxy: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.16, not stripped\n\n$ nm xy\n0804a020 B __bss_start\n0804a018 D __data_start\n0804a018 W data_start\n0804a01c D __dso_handle\n08049f0c d _DYNAMIC\n0804a020 D _edata\n0804a024 B _end\n080484e4 T _fini\n080484f8 R _fp_hw\n0804a000 d _GLOBAL_OFFSET_TABLE_\n         w __gmon_start__\n080482d4 T _init\n08049f04 t __init_array_end\n08049f00 t __init_array_start\n080484fc R _IO_stdin_used\n         w _ITM_deregisterTMCloneTable\n         w _ITM_registerTMCloneTable\n         w _Jv_RegisterClasses\n080484e0 T __libc_csu_fini\n08048470 T __libc_csu_init\n         U __libc_start_main@@GLIBC_2.0\n0804843c T main\n         U puts@@GLIBC_2.0\n08048340 T _start\n0804a020 D __TMC_END__\n08048370 T __x86.get_pc_thunk.bx\n$ strip xy\n$ nm xy\nnm: xy: no symbols\n$ nm -D xy\n         w __gmon_start__\n080484fc R _IO_stdin_used\n         U __libc_start_main\n         U puts\n")),(0,i.yg)("p",null,"Let's take a look at another ",(0,i.yg)("inlineCode",{parentName:"p"},"crackme")," that combines ",(0,i.yg)("inlineCode",{parentName:"p"},"crackme1")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"crackme2"),".\nWhat would you do if you couldn't use neither strings nor ltrace to get anything useful?"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\nchar correct_pass[] = ????????????????????????\n\nint my_strcmp(char *s1, char *s2)\n{\n    size_t i, len = strlen(s1);\n    if (len == 0)\n        return -1;\n    for (i = 0; i < len; i++)\n        if (s1[i] != s2[i])\n            return -1;\n\n    return 0;\n}\n\nchar *deobf(char *s)\n{\n???????????????????????????\n}\n\nint main()\n{\n    char buf[1000];\n    deobf(correct_pass);\n    printf("Password:\\n");\n    if (fgets(buf, 1000, stdin) == NULL)\n        exit(-1);\n\n    buf[strlen(buf) - 1] = \'\\0\';\n\n    if (!my_strcmp(buf, correct_pass)) {\n        printf("Correct!\\n");\n    } else\n        printf("Nope!\\n");\n\n    return 0;\n}\n')),(0,i.yg)("p",null,"In ",(0,i.yg)("a",{parentName:"p",href:"activities/03-tutorial-symbols/src"},(0,i.yg)("inlineCode",{parentName:"a"},"crackme3")),", deobfuscation is done before the password is read.\nSince the ",(0,i.yg)("inlineCode",{parentName:"p"},"correct_pass")," has an associated symbol that is stored at a known location you can obtain the address and peer into it at runtime:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},'$ nm crackme3 | grep pass\n0804a02c D correct_pass\n$ gdb -n ./crackme3\nReading symbols from ./crackme3...(no debugging symbols found)...done.\n(gdb) run\nPassword:\n^C\nProgram received signal SIGINT, Interrupt.\n0xf7fdb430 in __kernel_vsyscall ()\n(gdb) x/s 0x0804a02c\n0x804a02c <correct_pass>:    "JWxb7gE2pjiY3gRG8U"\n')),(0,i.yg)("p",null,"The above ",(0,i.yg)("inlineCode",{parentName:"p"},"x/s 0x0804a02c")," command in GDB is used for printing the string starting from address ",(0,i.yg)("inlineCode",{parentName:"p"},"0x0804a02c"),".\n",(0,i.yg)("inlineCode",{parentName:"p"},"x")," stands for examine memory and ",(0,i.yg)("inlineCode",{parentName:"p"},"s")," stands for string format.\nIn short it dumps memory in string format starting from the address passed as argument.\nYou may print multiple strings by prefixing ",(0,i.yg)("inlineCode",{parentName:"p"},"s")," with a number, for example ",(0,i.yg)("inlineCode",{parentName:"p"},"x/20s 0x0804a02c"),"."),(0,i.yg)("p",null,"For other programs (that are not stripped) you can even get a hint as to what they do using solely ",(0,i.yg)("inlineCode",{parentName:"p"},"nm"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ nm mystery_binary\n.....\n0000000000402bef T drop_privs(char const*)\n00000000004027db T IndexHandler(std::string const&, HttpRequest const&, HttpResponse*)\n0000000000402ad8 T StatusHandler(std::string const&, HttpRequest const&, HttpResponse*)\n000000000040237f T NotFoundHandler(std::string const&, HttpRequest const&, HttpResponse*)\n00000000004024a1 T BadRequestHandler(std::string const&, HttpRequest const&, HttpResponse*)\n00000000004025c3 T MaybeAddCORSHeader(std::string const&, HttpRequest const&, HttpResponse*)\n0000000000402f52 t __static_initialization_and_destruction_0(int, int)\n0000000000402cf8 T handle(int)\n00000000004020fc T recvlen(int, char*, unsigned long)\n0000000000402195 T sendlen(int, char const*, unsigned long)\n0000000000402224 T sendstr(int, char const*)\n0000000000402255 T urldecode(std::string const&)\n.....\n")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Note:")," In this case the signatures are also decoded because the binary was compiled from C++ source code."),(0,i.yg)("p",null,"Dealing with stripped binaries (or worse, statically linked binaries that have been stripped) is harder but can still be done.\nWe'll see how in a future lab."),(0,i.yg)("h3",{id:"04-tutorial---library-dependencies"},"04. Tutorial - Library Dependencies"),(0,i.yg)("p",null,"Most programs you will see make use of existing functionality.\nYou don't want to always reimplement string functions or file functions.\nTherefore, most programs use dynamic libraries.\nThese shared objects, as they are called alternatively, allow you to have a smaller program and also allow multiple programs to use a single copy of the code within the library.\nBut how does that actually work?"),(0,i.yg)("p",null,"What makes all of these programs work is the Linux dynamic linker/loader.\nThis is a statically linked helper program that resolves symbol names from shared objects at runtime.\nWe can use the dynamic linker to gather information about an executable."),(0,i.yg)("p",null,"The first and most common thing to do is see what libraries the executable loads, with the ",(0,i.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man1/ldd.1.html"},(0,i.yg)("inlineCode",{parentName:"a"},"ldd"))," utility:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ ldd /bin/ls\n    linux-vdso.so.1 (0x00007ffff13fe000)\n    librt.so.1 => /lib64/librt.so.1 (0x00007fc9b4893000)\n    libacl.so.1 => /lib64/libacl.so.1 (0x00007fc9b468a000)\n    libc.so.6 => /lib64/libc.so.6 (0x00007fc9b42da000)\n    libpthread.so.0 => /lib64/libpthread.so.0 (0x00007fc9b40bd000)\n    libattr.so.1 => /lib64/libattr.so.1 (0x00007fc9b3eb8000)\n    /lib64/ld-linux-x86-64.so.2 (0x00007fc9b4a9b000)\n")),(0,i.yg)("p",null,"We see that for each dependency in the executable, ",(0,i.yg)("inlineCode",{parentName:"p"},"ldd")," lists where it is found on the filesystem and where it is loaded in the process memory space.\nAlternatively, you can achieve the same result with the ",(0,i.yg)("inlineCode",{parentName:"p"},"LD_TRACE_LOADED_OBJECTS")," environment variable, or with the dynamic loader itself:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ LD_TRACE_LOADED_OBJECTS=whatever /bin/ls\n    linux-vdso.so.1 (0x00007fff325fe000)\n    librt.so.1 => /lib64/librt.so.1 (0x00007f1845386000)\n    libacl.so.1 => /lib64/libacl.so.1 (0x00007f184517d000)\n    libc.so.6 => /lib64/libc.so.6 (0x00007f1844dcd000)\n    libpthread.so.0 => /lib64/libpthread.so.0 (0x00007f1844bb0000)\n    libattr.so.1 => /lib64/libattr.so.1 (0x00007f18449ab000)\n    /lib64/ld-linux-x86-64.so.2 (0x00007f184558e000)\n$ /lib/ld-linux-x86-64.so.2 --list /bin/ls\n    linux-vdso.so.1 (0x00007fff1e712000)\n    librt.so.1 => /lib64/librt.so.1 (0x00007f18a07d8000)\n    libacl.so.1 => /lib64/libacl.so.1 (0x00007f18a05cf000)\n    libc.so.6 => /lib64/libc.so.6 (0x00007f18a021e000)\n    libattr.so.1 => /lib64/libattr.so.1 (0x00007f189fdfc000)\n    libpthread.so.0 => /lib64/libpthread.so.0 (0x00007f18a0001000)\n    /lib64/ld-linux-x86-64.so.2 => /lib/ld-linux-x86-64.so.2 (0x00007f18a0c44000)\n")),(0,i.yg)("p",null,"When using the loader directly, make sure the loader and the executable are compiled for the same platform (e.g.  they are both 64-bit or 32-bit).\nYou may find out more information about dynamic linker/loader variables in its man page.\nIssue the command:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"man ld-linux.so\n")),(0,i.yg)("p",null,"and search for the ",(0,i.yg)("inlineCode",{parentName:"p"},"LD_")," string to find variables information."),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"ldd")," shows us ",(0,i.yg)("strong",{parentName:"p"},"which")," libraries are loaded, but it's not any clearer how the loader knows ",(0,i.yg)("strong",{parentName:"p"},"where")," to load them from.\nFirst of all, the loader checks every dependency for a slash character.\nIf it finds such a dependency it loads the library from that path, whether it is a relative of absolute path.\nBut it is not the case in our example.\nFor dependencies without slashes, the search order is as follows:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"DT_RPATH")," attribute in the ",(0,i.yg)("inlineCode",{parentName:"li"},".dynamic")," section of the executable, provided there is no ",(0,i.yg)("inlineCode",{parentName:"li"},"DT_RUNPATH"),"; this is deprecated"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"LD_LIBRARY_PATH")," environment variable, which is similar to ",(0,i.yg)("inlineCode",{parentName:"li"},"PATH"),"; does not work with ",(0,i.yg)("inlineCode",{parentName:"li"},"setuid")," / ",(0,i.yg)("inlineCode",{parentName:"li"},"setgid")," programs"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"DT_RUNPATH")," attribute in the ",(0,i.yg)("inlineCode",{parentName:"li"},".dynamic")," section of the executable"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"/etc/ld.so.cache"),", generated by ",(0,i.yg)("a",{parentName:"li",href:"https://man7.org/linux/man-pages/man8/ldconfig.8.html"},(0,i.yg)("inlineCode",{parentName:"a"},"ldconfig"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"/lib")," and then ",(0,i.yg)("inlineCode",{parentName:"li"},"/usr/lib"))),(0,i.yg)("p",null,"The last two options are skipped if the program was linked with the ",(0,i.yg)("inlineCode",{parentName:"p"},"-z nodeflib")," option."),(0,i.yg)("p",null,"Now let's see exactly where the loader finds the libraries:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ LD_DEBUG=libs /bin/ls\n     11451:    find library=librt.so.1 [0]; searching\n     11451:     search cache=/etc/ld.so.cache\n     11451:      trying file=/lib64/librt.so.1\n     11451:\n     11451:    find library=libacl.so.1 [0]; searching\n     11451:     search cache=/etc/ld.so.cache\n     11451:      trying file=/lib64/libacl.so.1\n     11451:\n     11451:    find library=libc.so.6 [0]; searching\n     11451:     search cache=/etc/ld.so.cache\n     11451:      trying file=/lib64/libc.so.6\n     11451:\n     11451:    find library=libpthread.so.0 [0]; searching\n     11451:     search cache=/etc/ld.so.cache\n     11451:      trying file=/lib64/libpthread.so.0\n     11451:\n     11451:    find library=libattr.so.1 [0]; searching\n     11451:     search cache=/etc/ld.so.cache\n     11451:      trying file=/lib64/libattr.so.1\n")),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"LD_DEBUG")," environment variable makes the dynamic loader be verbose about what it's doing.\nTry ",(0,i.yg)("inlineCode",{parentName:"p"},"LD_DEBUG=help")," if you're curious about what else you can find out.\nWe can see in the output listed above that all the libraries are found via the loader cache.\nThe number at the beginning of each line is the PID of the ",(0,i.yg)("inlineCode",{parentName:"p"},"ls")," process."),(0,i.yg)("p",null,"And now we can discuss ",(0,i.yg)("strong",{parentName:"p"},"how")," the loader resolves symbols after it has found the libraries containing them.\nWhile variables are resolved when the library is opened, that is not the case for function references.\nWhen dealing with functions, the Linux dynamic loader uses something called lazy binding, which means that a function symbol in the library is not resolved until the very first call to it.\nThink about why this difference exists."),(0,i.yg)("p",null,"You can see the way lazy binding behaves:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ LD_DEBUG=symbols,bindings ./crackme2\n...\n     11480:    initialize program: ./crackme2\n     11480:\n     11480:\n     11480:    transferring control: ./crackme2\n     11480:\n     11480:    symbol=puts;  lookup in file=./crackme2 [0]\n     11480:    symbol=puts;  lookup in file=/lib32/libc.so.6 [0]\n     11480:    binding file ./crackme2 [0] to /lib32/libc.so.6 [0]: normal symbol 'puts' [GLIBC_2.0]\nPassword:\n     11480:    symbol=fgets;  lookup in file=./crackme2 [0]\n     11480:    symbol=fgets;  lookup in file=/lib32/libc.so.6 [0]\n     11480:    binding file ./crackme2 [0] to /lib32/libc.so.6 [0]: normal symbol 'fgets' [GLIBC_2.0]\nI_pity_da_fool_who_gets_here_without_solving_crackme2\n     11480:    symbol=strlen;  lookup in file=./crackme2 [0]\n     11480:    symbol=strlen;  lookup in file=/lib32/libc.so.6 [0]\n     11480:    binding file ./crackme2 [0] to /lib32/libc.so.6 [0]: normal symbol 'strlen' [GLIBC_2.0]\n     11480:    symbol=strcmp;  lookup in file=./crackme2 [0]\n     11480:    symbol=strcmp;  lookup in file=/lib32/libc.so.6 [0]\n     11480:    binding file ./crackme2 [0] to /lib32/libc.so.6 [0]: normal symbol 'strcmp' [GLIBC_2.0]\nNope!\n     11480:\n     11480:    calling fini: ./crackme2 [0]\n     11480:\n")),(0,i.yg)("p",null,"As you can see, functions like ",(0,i.yg)("inlineCode",{parentName:"p"},"puts()"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"fgets()"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"strlen()")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"strcmp()")," are not actually resolved until the first call to them is made.\nMake the loader resolve all the symbols at startup.\n(Hint: ",(0,i.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man8/ld-linux.8.html"},"ld-linux"),")."),(0,i.yg)("h4",{id:"library-wrapper-task"},"Library Wrapper Task"),(0,i.yg)("p",null,"You've previously solved ",(0,i.yg)("inlineCode",{parentName:"p"},"crackme2")," with the help of the ",(0,i.yg)("inlineCode",{parentName:"p"},"ltrace"),".\nCheck out the files from ",(0,i.yg)("a",{parentName:"p",href:"activities/04-tutorial-library-dependencies/src"},"04-tutorial-library-dependencies"),".\nThe folder consists of a ",(0,i.yg)("inlineCode",{parentName:"p"},"Makefile")," and a C source code file reimplementing the ",(0,i.yg)("inlineCode",{parentName:"p"},"strcmp()")," function (library wrapper).\nThe ",(0,i.yg)("inlineCode",{parentName:"p"},"strcmp.c")," implementation uses ",(0,i.yg)("inlineCode",{parentName:"p"},"LD_PRELOAD")," to wrap the actual ",(0,i.yg)("inlineCode",{parentName:"p"},"strcmp()")," call to our own."),(0,i.yg)("p",null,"In order to see how that works, we need to create a shared library and pass it as an argument to ",(0,i.yg)("inlineCode",{parentName:"p"},"LD_PRELOAD"),".\nThe ",(0,i.yg)("inlineCode",{parentName:"p"},"Makefile")," already takes care of this.\nTo build and run the entire thing, simply run:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"make run\n")),(0,i.yg)("p",null,"This will build the shared library file (",(0,i.yg)("inlineCode",{parentName:"p"},"strcmp.so"),") and run the ",(0,i.yg)("inlineCode",{parentName:"p"},"crackme2")," executable under ",(0,i.yg)("inlineCode",{parentName:"p"},"LD_PRELOAD"),"."),(0,i.yg)("p",null,"Our goal is to use the ",(0,i.yg)("inlineCode",{parentName:"p"},"strcmp()")," wrapper to alter the program behavior.\nWe have two ways to make the ",(0,i.yg)("inlineCode",{parentName:"p"},"crackme2")," program behave our way:"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"Leak the password in the ",(0,i.yg)("inlineCode",{parentName:"li"},"strcmp()")," wrapper."),(0,i.yg)("li",{parentName:"ol"},"Pass the check regardless of what password we provide.")),(0,i.yg)("p",null,"Modify the ",(0,i.yg)("inlineCode",{parentName:"p"},"strcmp()")," function in the ",(0,i.yg)("inlineCode",{parentName:"p"},"strcmp.c")," source code file to alter the ",(0,i.yg)("inlineCode",{parentName:"p"},"crackme2")," program behavior in each of the two ways shown above.\nTo test it, use the ",(0,i.yg)("inlineCode",{parentName:"p"},"Makefile"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"make run\n")),(0,i.yg)("h3",{id:"05-tutorial---network-netstat-and-netcat"},"05. Tutorial - Network: ",(0,i.yg)("inlineCode",{parentName:"h3"},"netstat")," and ",(0,i.yg)("inlineCode",{parentName:"h3"},"netcat")),(0,i.yg)("p",null,"Services running on remote machines offer a gateway to those particular machines.\nWhether it's improper handling of the data received from clients, or a flaw in the protocol used between server and clients, certain privileges can be obtained if care is not taken.\nWe'll explore some tools and approaches to analyzing remote services.\nTo follow along, use the server and client programs from ",(0,i.yg)("a",{parentName:"p",href:"activities/05-tutorial-network-netstat-netcat/src"},(0,i.yg)("inlineCode",{parentName:"a"},"05-tutorial-network-netstat-netcat")),"."),(0,i.yg)("p",null,"First of all, start the server:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ ./server\nWelcome to the awesome server.\nValid commands are:\nquit\nstatus\n")),(0,i.yg)("p",null,"Running any of them at this point doesn't offer much help.\nWe'll come back to this later."),(0,i.yg)("p",null,"The most straightforward way to see what a server does is the ",(0,i.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man8/netstat.8.html"},(0,i.yg)("inlineCode",{parentName:"a"},"netstat"))," utility."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ netstat -tlpn\n(Not all processes could be identified, non-owned process info\n will not be shown, you would have to be root to see it all.)\nActive Internet connections (only servers)\nProto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name\ntcp        0      0 0.0.0.0:36732           0.0.0.0:*               LISTEN      3062/steam\ntcp        0      0 127.0.0.1:57343         0.0.0.0:*               LISTEN      3062/steam\ntcp        0      0 127.0.0.1:31337         0.0.0.0:*               LISTEN      15022/./server\ntcp        0      0 0.0.0.0:58154           0.0.0.0:*               LISTEN      3062/steam\ntcp        0      0 127.0.0.1:60783         0.0.0.0:*               LISTEN      2644/SpiderOak\ntcp        0      0 192.168.101.1:53        0.0.0.0:*               LISTEN      -\ntcp        0      0 192.168.100.1:53        0.0.0.0:*               LISTEN      -\ntcp        0      0 0.0.0.0:44790           0.0.0.0:*               LISTEN      2644/SpiderOak\ntcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      -\ntcp6       0      0 :::631                  :::*                    LISTEN      -\n")),(0,i.yg)("p",null,"Here we're looking at all the programs that are listening (",(0,i.yg)("inlineCode",{parentName:"p"},"-l"),") on a TCP port (",(0,i.yg)("inlineCode",{parentName:"p"},"-t"),").\nWe're also telling ",(0,i.yg)("inlineCode",{parentName:"p"},"netcat")," not to resolve hosts (",(0,i.yg)("inlineCode",{parentName:"p"},"-n"),") and to show the process that is listening (",(0,i.yg)("inlineCode",{parentName:"p"},"-p"),").\nWe can see that our server is listening on port ",(0,i.yg)("inlineCode",{parentName:"p"},"31337"),".\nLet's keep that in mind and see how the client behaves:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ ./client\nUsage: ./client <client name> <server IP> <server port>\n\n$ ./client the_laughing_man localhost 31337\nWelcome to the awesome server.\nValid commands are:\nlistclients\ninfoclient <client name> [ADMIN access required]\n    name, IP, port, privileged, connected time\nsendmsg <client name> <message>\n\nEnter a command (or 'quit' to exit):\nlistclients\nConnected clients are:\nthe_laughing_man\nEnter a command (or 'quit' to exit):\nsendmsg the_laughing_man test\nEnter a command (or 'quit' to exit):\nMessage from the_laughing_man\ntest\n\nEnter a command (or 'quit' to exit):\ninfoclient the_laughing_man\nNot enough minerals!\n\nEnter a command (or 'quit' to exit):\n")),(0,i.yg)("p",null,"So we can do anything except the privileged command ",(0,i.yg)("inlineCode",{parentName:"p"},"infoclient"),".\nRunning ",(0,i.yg)("inlineCode",{parentName:"p"},"status")," on the server yields no information.\nWhat can we do now?"),(0,i.yg)("p",null,"We can see what the server and client are exchanging at an application level by capturing the traffic with the ",(0,i.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man1/tcpdump.1.html"},(0,i.yg)("inlineCode",{parentName:"a"},"tcpdump"))," utility.\nStart ",(0,i.yg)("inlineCode",{parentName:"p"},"tcpdump"),", the server and then the client, and run the commands again.\nWhen you're done, stop ",(0,i.yg)("inlineCode",{parentName:"p"},"tcpdump")," with ",(0,i.yg)("inlineCode",{parentName:"p"},"Ctrl+C"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"# tcpdump -i any -w crackme5.pcap 'port 31337'\ntcpdump: listening on any, link-type LINUX_SLL (Linux cooked), capture size 65535 bytes\n^C21 packets captured\n42 packets received by filter\n0 packets dropped by kernel\n")),(0,i.yg)("p",null,"Here we're telling ",(0,i.yg)("inlineCode",{parentName:"p"},"tcpdump")," to listen on all available interfaces, write the capture to the ",(0,i.yg)("inlineCode",{parentName:"p"},"crackme5.pcap")," file and only log packets that have the source or destination port equal to 31337."),(0,i.yg)("p",null,"We can then open our capture with ",(0,i.yg)("a",{parentName:"p",href:"https://www.wireshark.org/"},(0,i.yg)("inlineCode",{parentName:"a"},"Wireshark"))," in order to analyze the packets in a friendlier manner.\nYou can look at the packets exchanged between server and client.\nNotice that there seems to be some sort of protocol where values are delimited by the pipe character.\nWhat is especially interesting is the first data packet sent from the client to the server, which sends ",(0,i.yg)("inlineCode",{parentName:"p"},"the_laughing_man|false"),".\nWhile we've specified the client name, there was nothing we could specify via the client command-line in order to control the second value."),(0,i.yg)("p",null,"However, since this seems to be a plain text protocol, there is an alternative course of action available.\nThe ",(0,i.yg)("a",{parentName:"p",href:"https://linux.die.net/man/1/nc"},(0,i.yg)("inlineCode",{parentName:"a"},"netcat")),' utility allows for arbitrary clients and servers.\nIt just needs a server address and a server port in client mode.\nWe can use it instead of the "official" client and see what happens when we craft the first message.\nGo ahead!\nStart the server again and a normal client.'),(0,i.yg)("p",null,"Connect to the server using ",(0,i.yg)("inlineCode",{parentName:"p"},"netcat"),".\nThen send out the required string through the ",(0,i.yg)("inlineCode",{parentName:"p"},"netcat")," connection with true as the second parameter and see if you can find out anything about the normal client."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"# netcat localhost 31337\nWelcome to the awesome server.\nValid commands are:\nlistclients\ninfoclient <client name> [ADMIN access required]\n    name, IP, port, privileged, connected time\nsendmsg <client name> <message>\n")),(0,i.yg)("h4",{id:"doing-it-in-python"},"Doing it in Python"),(0,i.yg)("p",null,"You can create a sever and a client in Python only.\nWe can use the ",(0,i.yg)("inlineCode",{parentName:"p"},"server.py")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"client.py")," scripts.\nCheck them out first."),(0,i.yg)("p",null,"Then run the server by using:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"python server.py\n")),(0,i.yg)("p",null,"It now accepts connections on TCP port 9999 as you can see by using ",(0,i.yg)("inlineCode",{parentName:"p"},"netstat"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ netstat -tlpn\n[...]\nProto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name\ntcp        0      0 127.0.0.1:9999          0.0.0.0:*               LISTEN      12541/python\n[...]\n")),(0,i.yg)("p",null,"Now you can test it using the Python client:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ python client.py\nsending 'anaaremere'\nreceived 'ANAAREMERE'\n")),(0,i.yg)("p",null,"We can do the same using ",(0,i.yg)("inlineCode",{parentName:"p"},"netcat")," as the client:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ nc localhost 9999\nanaaremere\nANAAREMERE\n")),(0,i.yg)("h4",{id:"doing-it-only-with-netcat"},"Doing it Only with ",(0,i.yg)("inlineCode",{parentName:"h4"},"netcat")),(0,i.yg)("p",null,"We can still simulate a network connection using ",(0,i.yg)("inlineCode",{parentName:"p"},"netcat")," only, both for starting the server and for running the client."),(0,i.yg)("p",null,"Start the server with:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"nc -l -p 4444\n")),(0,i.yg)("p",null,"Now run the client and send messages by writing them to standard input:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ nc localhost 4444\naaaaa\nbbbbb\n")),(0,i.yg)("p",null,"Messages you write to the client and up in the server."),(0,i.yg)("p",null,"This goes both ways: if you write messages on the server they end up in the client.\nTry that."),(0,i.yg)("p",null,"If you want to send a large chunk of data you can redirect a file.\nStart the server again:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"nc -l -p 4444\n")),(0,i.yg)("p",null,"and now send the file to it:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"cat /etc/services | nc localhost 4444\n")),(0,i.yg)("p",null,"It's now on the server-side."),(0,i.yg)("p",null,"You can also do it with UDP, instead of TCP by using the ",(0,i.yg)("inlineCode",{parentName:"p"},"-u")," flag both for the server and the client.\nStart the server using:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"nc -u -l -p 4444\n")),(0,i.yg)("p",null,"And run the client using:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"cat /etc/services | nc -u localhost 4444\n")),(0,i.yg)("p",null,"That's how we use ",(0,i.yg)("inlineCode",{parentName:"p"},"netcat")," (the network swiss army knife)."),(0,i.yg)("p",null,"You can also look into ",(0,i.yg)("a",{parentName:"p",href:"https://linux.die.net/man/1/socat"},(0,i.yg)("inlineCode",{parentName:"a"},"socat"))," for a complex tool on dealing with sockets."),(0,i.yg)("h3",{id:"06-tutorial---open-files"},"06. Tutorial - Open files"),(0,i.yg)("p",null,"Let's remember how files and programs relate in Linux."),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"Files",src:a(366).A,width:"960",height:"720"})),(0,i.yg)("p",null,"Let's also remember that, in Linux, ",(0,i.yg)("inlineCode",{parentName:"p"},"file")," can mean one of many things:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"regular file"),(0,i.yg)("li",{parentName:"ul"},"directory"),(0,i.yg)("li",{parentName:"ul"},"block device"),(0,i.yg)("li",{parentName:"ul"},"character device"),(0,i.yg)("li",{parentName:"ul"},"named pipe"),(0,i.yg)("li",{parentName:"ul"},"symbolic or hard link"),(0,i.yg)("li",{parentName:"ul"},"socket")),(0,i.yg)("p",null,"Let's look at the previous server from ",(0,i.yg)("inlineCode",{parentName:"p"},"crackme5"),".\nStart it up once again."),(0,i.yg)("p",null,"While previously we've used ",(0,i.yg)("inlineCode",{parentName:"p"},"netstat")," to gather information about it, that was by no means the only solution.\n",(0,i.yg)("a",{parentName:"p",href:"https://linux.die.net/man/8/lsof"},(0,i.yg)("inlineCode",{parentName:"a"},"lsof"))," is a tool that can show us what files a process has opened:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ lsof -c server\nCOMMAND  PID   USER   FD   TYPE DEVICE SIZE/OFF    NODE NAME\nserver  9678 amadan  cwd    DIR    8,6     4096 1482770 /home/amadan/projects/sss/session01/crackmes/crackme5\nserver  9678 amadan  rtd    DIR    8,6     4096       2 /\nserver  9678 amadan  txt    REG    8,6    17524 1442625 /home/amadan/projects/sss/session01/crackmes/crackme5/server\nserver  9678 amadan  mem    REG    8,6  1753240 3039007 /lib64/libc-2.17.so\nserver  9678 amadan  mem    REG    8,6    88088 3039019 /lib64/libnsl-2.17.so\nserver  9678 amadan  mem    REG    8,6   144920 3038998 /lib64/ld-2.17.so\nserver  9678 amadan    0u   CHR  136,2      0t0       5 /dev/pts/2\nserver  9678 amadan    1u   CHR  136,2      0t0       5 /dev/pts/2\nserver  9678 amadan    2u   CHR  136,2      0t0       5 /dev/pts/2\nserver  9678 amadan    3u  IPv4 821076      0t0     TCP *:31337 (LISTEN)\n")),(0,i.yg)("p",null,"We can see the standard file descriptors found in any process, as well as our socket."),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"The ",(0,i.yg)("inlineCode",{parentName:"li"},"FD")," column shows the file descriptor entry for a file, or a role in case of special files.\nWe notice the current working directory (",(0,i.yg)("inlineCode",{parentName:"li"},"cwd"),"), the root directory (",(0,i.yg)("inlineCode",{parentName:"li"},"rtd"),"), the current executable (",(0,i.yg)("inlineCode",{parentName:"li"},"txt"),"), some memory mapped files (",(0,i.yg)("inlineCode",{parentName:"li"},"mem"),") and the file descriptors (0-3).\nFor normal file descriptors, ",(0,i.yg)("inlineCode",{parentName:"li"},"r")," means read access, ",(0,i.yg)("inlineCode",{parentName:"li"},"w")," means write access and ",(0,i.yg)("inlineCode",{parentName:"li"},"u")," means both."),(0,i.yg)("li",{parentName:"ul"},"The ",(0,i.yg)("inlineCode",{parentName:"li"},"TYPE")," column shows whether we're dealing with a directory (",(0,i.yg)("inlineCode",{parentName:"li"},"DIR"),"), a regular file (",(0,i.yg)("inlineCode",{parentName:"li"},"REG"),"), a character device (",(0,i.yg)("inlineCode",{parentName:"li"},"CHR"),"), a socket (",(0,i.yg)("inlineCode",{parentName:"li"},"IPv4"),") or other type of file."),(0,i.yg)("li",{parentName:"ul"},"The ",(0,i.yg)("inlineCode",{parentName:"li"},"NODE")," column shows the inode of the file, or a class marker as is the case for the socket."),(0,i.yg)("li",{parentName:"ul"},"The ",(0,i.yg)("inlineCode",{parentName:"li"},"NAME")," column shows the path to the file, or the bound address and port for a socket.")),(0,i.yg)("p",null,"We've left out some details since they are not relevant for our purposes.\nFeel free to read the manual page."),(0,i.yg)("p",null,"You could also get some hint that there is an open socket by looking into the ",(0,i.yg)("inlineCode",{parentName:"p"},"/proc")," virtual filesystem:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ ls -l /proc/`pidof server`/fd\ntotal 0\nlrwx------ 1 amadan amadan 64 Jun 15 22:04 0 -> /dev/pts/2\nlrwx------ 1 amadan amadan 64 Jun 15 22:04 1 -> /dev/pts/2\nlrwx------ 1 amadan amadan 64 Jun 15 22:03 2 -> /dev/pts/2\nlrwx------ 1 amadan amadan 64 Jun 15 22:04 3 -> socket:[883625]\n")),(0,i.yg)("p",null,"We'll be using ",(0,i.yg)("a",{parentName:"p",href:"activities/06-tutorial-open-files/src"},(0,i.yg)("inlineCode",{parentName:"a"},"crackme6"))," for the next part of this section.\nTry the conventional means of ",(0,i.yg)("inlineCode",{parentName:"p"},"strings")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"ltrace")," on it.\nThen run it normally:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ ./crackme6\nType 'start' to begin authentication test\n")),(0,i.yg)("p",null,"Before complying to what the program tells us, let's use ",(0,i.yg)("inlineCode",{parentName:"p"},"lsof")," to see what we can find out:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ lsof -c crackme6\nCOMMAND    PID   USER   FD   TYPE DEVICE SIZE/OFF    NODE NAME\ncrackme6 10466 amadan  cwd    DIR    8,6     4096 1482769 /home/amadan/projects/sss/session01/06-tutorial-open-files\ncrackme6 10466 amadan  rtd    DIR    8,6     4096       2 /\ncrackme6 10466 amadan  txt    REG    8,6    12922 5377126 /home/amadan/projects/sss/session01/06-tutorial-open-files/crackme6\ncrackme6 10466 amadan  mem    REG    8,6  1753240 3039007 /lib64/libc-2.17.so\ncrackme6 10466 amadan  mem    REG    8,6   100680 3039039 /lib64/libpthread-2.17.so\ncrackme6 10466 amadan  mem    REG    8,6   144920 3038998 /lib64/ld-2.17.so\ncrackme6 10466 amadan    0u   CHR  136,2      0t0       5 /dev/pts/2\ncrackme6 10466 amadan    1u   CHR  136,2      0t0       5 /dev/pts/2\ncrackme6 10466 amadan    2u   CHR  136,2      0t0       5 /dev/pts/2\ncrackme6 10466 amadan    3w  FIFO   0,32      0t0  988920 /tmp/crackme6.fifo\ncrackme6 10466 amadan    4r  FIFO   0,32      0t0  988920 /tmp/crackme6.fifo\n")),(0,i.yg)("p",null,"There seems to be a named pipe used by the executable.\nLet's look at it:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"more /tmp/crackme6.fifo\n")),(0,i.yg)("p",null,"Now go back again at the ",(0,i.yg)("inlineCode",{parentName:"p"},"crackme6")," console and type ",(0,i.yg)("inlineCode",{parentName:"p"},"start"),".\nIf you see the message that the authentication test has succeeded, quit and try again.\nIf you do not see the message, kill the ",(0,i.yg)("inlineCode",{parentName:"p"},"crackme6")," process, look at the more command output and then delete the pipe file.\nNow try the password."),(0,i.yg)("h4",{id:"misc"},"Misc"),(0,i.yg)("p",null,"There are other sources of information available about running processes if you prefer to do things by hand such as:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"/proc/<PID>/environ"),": all environment variables given when the process was started"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"/proc/<PID>/fd"),": opened file descriptors."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"/proc/<PID>/mem"),": address space layout"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"/proc/<PID>/cwd"),": symlink to working directory"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"/proc/<PID>/exe"),": symlink to binary image"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"/proc/<PID>/cmdline"),": complete program command-line, with arguments")),(0,i.yg)("h2",{id:"challenges"},"Challenges"),(0,i.yg)("p",null,"Challenges can be found in the ",(0,i.yg)("inlineCode",{parentName:"p"},"activities/<CHALLENGE_NUMBER>-challenge-<CHALLENGE_NAME>")," directory."),(0,i.yg)("h3",{id:"07-challenge---perfect-answer"},"07. Challenge - Perfect Answer"),(0,i.yg)("p",null,"For this task use the ",(0,i.yg)("a",{parentName:"p",href:"activities/07-challenge-perfect-answer/src"},(0,i.yg)("inlineCode",{parentName:"a"},"perfect"))," binary."),(0,i.yg)("p",null,"Can you find the flag?"),(0,i.yg)("h3",{id:"08-challenge---lots-of-strings"},"08. Challenge - Lots of strings"),(0,i.yg)("p",null,"Use the ",(0,i.yg)("a",{parentName:"p",href:"activities/08-challenge-lots-of-strings/src"},(0,i.yg)("inlineCode",{parentName:"a"},"lots_of_strings"))," binary."),(0,i.yg)("p",null,"Can you find the ",(0,i.yg)("strong",{parentName:"p"},"password"),"?"),(0,i.yg)("p",null,"Hint: use the tools presented in the tutorials."),(0,i.yg)("h3",{id:"09-challenge---sleepy-cats"},"09. Challenge - Sleepy cats"),(0,i.yg)("p",null,"For this task use the ",(0,i.yg)("a",{parentName:"p",href:"activities/09-challenge-sleepy-cats/src"},(0,i.yg)("inlineCode",{parentName:"a"},"sleepy"))," binary."),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"sleep()")," function takes too much.\nAin't nobody got time for that.\nWe want the flag NOW!"),(0,i.yg)("p",null,"Modify the binary in order to get the flag."),(0,i.yg)("p",null,"To edit a binary, you can use ",(0,i.yg)("a",{parentName:"p",href:"https://vim.fandom.com/wiki/Hex_dump#Editing_binary_files"},(0,i.yg)("inlineCode",{parentName:"a"},"vim")," + ",(0,i.yg)("inlineCode",{parentName:"a"},"xxd"))," or ",(0,i.yg)("inlineCode",{parentName:"p"},"Bless"),".\nWe strongly encourage you to use ",(0,i.yg)("inlineCode",{parentName:"p"},"Bless")),(0,i.yg)("h3",{id:"10-challenge---hidden"},"10. Challenge - Hidden"),(0,i.yg)("p",null,"For this challenge use the ",(0,i.yg)("a",{parentName:"p",href:"activities/10-challenge-hidden/src"},(0,i.yg)("inlineCode",{parentName:"a"},"hidden"))," binary."),(0,i.yg)("p",null,"Can you find the hidden flag?"),(0,i.yg)("p",null,"You could use ",(0,i.yg)("inlineCode",{parentName:"p"},"ltrace")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"strace")," to find the flag.\nBut try to make it give you the flag by simply altering the environment, do not attach to the executable."),(0,i.yg)("h3",{id:"11-challenge---detective"},"11. Challenge - Detective"),(0,i.yg)("p",null,"This challenge runs remotely at ",(0,i.yg)("inlineCode",{parentName:"p"},"141.85.224.104:31337"),".\nYou can use ",(0,i.yg)("inlineCode",{parentName:"p"},"netcat")," to connect to it."),(0,i.yg)("p",null,"Investigate the ",(0,i.yg)("a",{parentName:"p",href:"activities/11-challenge-detective/src"},(0,i.yg)("inlineCode",{parentName:"a"},"detective"))," binary.\nSee what it does and work to get the flag."),(0,i.yg)("p",null,"You can start from the ",(0,i.yg)("a",{parentName:"p",href:"activities/11-challenge-detective/sol/exploit_template.py"},(0,i.yg)("inlineCode",{parentName:"a"},"sol/exploit_template.py"))," solution template script."),(0,i.yg)("p",null,"There is a bonus to this challenge and you will be able to find another flag.\nSee that below."),(0,i.yg)("h4",{id:"bonus-get-the-second-flag"},"Bonus: Get the Second Flag"),(0,i.yg)("p",null,"You can actually exploit the remote ",(0,i.yg)("a",{parentName:"p",href:"activities/11-challenge-detective/src"},(0,i.yg)("inlineCode",{parentName:"a"},"detective"))," executable and get the second flag.\nLook thoroughly through the executable and craft your payload to exploit the remote service."),(0,i.yg)("p",null,"You need to keep the connection going.\nUse the construction: ",(0,i.yg)("inlineCode",{parentName:"p"},"cat /path/to/file - | nc <host> <port>")),(0,i.yg)("h3",{id:"extra"},"Extra"),(0,i.yg)("p",null,"If you want some more, have a go at the ",(0,i.yg)("a",{parentName:"p",href:"activities/bonus/src"},(0,i.yg)("inlineCode",{parentName:"a"},"bonus"))," task.\nIt is a simplified CTF task that you should be able to solve using the information learned in this lab."),(0,i.yg)("p",null,"Hint: This executable needs elevated permissions (run with ",(0,i.yg)("inlineCode",{parentName:"p"},"sudo"),")."),(0,i.yg)("h3",{id:"further-pwning"},"Further pwning"),(0,i.yg)("p",null,(0,i.yg)("a",{parentName:"p",href:"http://pwnable.kr/"},(0,i.yg)("inlineCode",{parentName:"a"},"pwnable.kr"))," is a wargames site with fun challenges of different difficulty levels.\nAfter completing all tutorials and challenges in this session, you should be able to go there and try your hand at the following games from Toddler's bottle: ",(0,i.yg)("inlineCode",{parentName:"p"},"fd"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"collision"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"bof"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"passcode"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"mistake"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"cmd1"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"blukat")," (of course, you are encouraged to try any other challenges, but they might get frustrating, as they require knowledge of notions we will explore in future sessions)."),(0,i.yg)("h2",{id:"further-reading"},"Further Reading"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://man7.org/linux/man-pages/man1/ltrace.1.html"},(0,i.yg)("inlineCode",{parentName:"a"},"ltrace"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://man7.org/linux/man-pages/man2/syscalls.2.html"},(0,i.yg)("inlineCode",{parentName:"a"},"syscalls"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://man7.org/linux/man-pages/man2/ptrace.2.html"},(0,i.yg)("inlineCode",{parentName:"a"},"ptrace"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://man7.org/linux/man-pages/man2/ptrace.2.html"},(0,i.yg)("inlineCode",{parentName:"a"},"ldconfig"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://linux.die.net/man/1/socat"},(0,i.yg)("inlineCode",{parentName:"a"},"socat"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://linux.die.net/man/8/lsof"},(0,i.yg)("inlineCode",{parentName:"a"},"lsof"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://vim.fandom.com/wiki/Hex_dump#Editing_binary_files"},(0,i.yg)("inlineCode",{parentName:"a"},"vim")," + ",(0,i.yg)("inlineCode",{parentName:"a"},"xxd")))))}g.isMDXComponent=!0},366:(e,n,a)=>{a.d(n,{A:()=>t});const t=a.p+"assets/images/files-f31b9a44ab36ace0e629c47195b09d24.png"}}]);