"use strict";(self.webpackChunkbinary_security=self.webpackChunkbinary_security||[]).push([[102],{751:(e,n,a)=>{a.d(n,{A:()=>t});const t=a.p+"assets/images/elf-dependency-dd5b7e5505ce86cb6fa3af17d55db1c4.png"},1199:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>c,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var t=a(8168),i=(a(6540),a(5680));const l={},r="Executables and Processes",o={unversionedId:"Binary Analysis/Executables and Processes/Reading/README",id:"Binary Analysis/Executables and Processes/Reading/README",title:"Executables and Processes",description:"From a user's perspective, the main purpose of the computing system is to run applications.",source:"@site/docs/Binary Analysis/Executables and Processes/Reading/README.md",sourceDirName:"Binary Analysis/Executables and Processes/Reading",slug:"/Binary Analysis/Executables and Processes/Reading/",permalink:"/binary-security/Binary Analysis/Executables and Processes/Reading/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Executables and Processes",permalink:"/binary-security/Binary Analysis/Executables and Processes/"},next:{title:"Drills",permalink:"/binary-security/Binary Analysis/Executables and Processes/Drills/"}},s={},p=[{value:"Process Memory Layout",id:"process-memory-layout",level:2},{value:"Executable",id:"executable",level:3},{value:"Heap",id:"heap",level:3},{value:"Memory Mappings and Libraries",id:"memory-mappings-and-libraries",level:3},{value:"Stack",id:"stack",level:3},{value:"Segmentation Fault",id:"segmentation-fault",level:3},{value:"Tutorials",id:"tutorials",level:2},{value:"Big Picture View",id:"big-picture-view",level:3},{value:"Static/Dynamic linking",id:"staticdynamic-linking",level:3},{value:"ELF Types",id:"elf-types",level:3},{value:"ELF Type - Relocatable Files",id:"elf-type---relocatable-files",level:4},{value:"ELF Type - Shared Objects",id:"elf-type---shared-objects",level:4},{value:"ELF Type - Executable Files",id:"elf-type---executable-files",level:4},{value:"ELF Structure",id:"elf-structure",level:3},{value:"ELF Header",id:"elf-header",level:4},{value:"Program Headers",id:"program-headers",level:4},{value:"Section Table",id:"section-table",level:4},{value:"Symbol Table",id:"symbol-table",level:4},{value:"Relocations",id:"relocations",level:4},{value:"Challenges",id:"challenges",level:2},{value:"01. Binary Puzzle",id:"01-binary-puzzle",level:3},{value:"02. Case of the Missing Function",id:"02-case-of-the-missing-function",level:3},{value:"03. Memory Dump Analysis",id:"03-memory-dump-analysis",level:3},{value:"04. Compiler Flags",id:"04-compiler-flags",level:3},{value:"05. Print Flag",id:"05-print-flag",level:3},{value:"06. <code>matryoshka</code>",id:"06-matryoshka",level:3},{value:"Bonus: 07. Fix Me",id:"bonus-07-fix-me",level:3},{value:"Further Pwning",id:"further-pwning",level:3},{value:"Further Reading",id:"further-reading",level:3}],d={toc:p},m="wrapper";function c({components:e,...n}){return(0,i.yg)(m,(0,t.A)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"executables-and-processes"},"Executables and Processes"),(0,i.yg)("p",null,"From a user's perspective, the main purpose of the computing system is to run applications.\nApplications are used for the user's benefit: listen to music, organize files, play games, develop applications, chat over the Internet, etc."),(0,i.yg)("p",null,"A running application is called ",(0,i.yg)("strong",{parentName:"p"},"a process"),".\nA user starts a process, interacts with a process, ends a process."),(0,i.yg)("p",null,"When a process runs for the benefit of the user, it ",(0,i.yg)("strong",{parentName:"p"},"executes instructions")," that ",(0,i.yg)("strong",{parentName:"p"},"operate on data"),".\nThese two items (executing instructions and operating on data) are the most relevant items to understanding processes and executables.\nInstructions, also called ",(0,i.yg)("strong",{parentName:"p"},"code"),", and ",(0,i.yg)("strong",{parentName:"p"},"data")," reside in memory.\nCode is read from memory by the processor / CPU (",(0,i.yg)("em",{parentName:"p"},"Central Processing Unit"),"), then it is decoded and interpreted by the CPU, then it is executed on data that is also read from memory by the CPU.\nFinally, the result of the operation is stored back into memory.\nSo, each process has its memory space that stores code and data."),(0,i.yg)("p",null,"TODO: diagram with memory (code, data) and CPU interaction"),(0,i.yg)("p",null,"We say that each process has its own memory space, also called address space.\nWe refer to this as ",(0,i.yg)("strong",{parentName:"p"},"process address space"),", or ",(0,i.yg)("strong",{parentName:"p"},"process virtual address space")," (",(0,i.yg)("inlineCode",{parentName:"p"},"(P)VAS"),") (why this is named ",(0,i.yg)("em",{parentName:"p"},"virtual")," is outside the scope of this section).\nThis space is populated with data and code.\nData is dynamic with respect to contents and size: it can be modified, it can be enlarged or shrinked.\nCode is static: it can't be (easily) modified, it can't be (easily) enlarged.\nData can be read from or written to outside the process memory, to outside devices (I/O - ",(0,i.yg)("em",{parentName:"p"},"Input/Output"),") - keyboard, monitor, network, disk.\nCode is however read at process birth time."),(0,i.yg)("p",null,"The origin of the code and some parts of the data is ",(0,i.yg)("strong",{parentName:"p"},"the application executable")," (or program executable).\nThe application executable is a binary file with a given format that stores the code and initial data that will be used to set up the process.\nThe birth of a process means loading the code and initial data from the program executable into memory.\nThis creates the process virtual address space.\nThen the CPU is pointed to execute instructions from the new process virtual address spaces and now the process is running."),(0,i.yg)("p",null,"TODO: diagram with executable (code, data) and process memory (code, data) + CPU (code + data interaction) + I/O (for parts of data)"),(0,i.yg)("p",null,"We call the starting of a process from a program executable ",(0,i.yg)("strong",{parentName:"p"},"loading"),".\nThe ",(0,i.yg)("strong",{parentName:"p"},"loader")," is the piece of software responsible for this.\nWhatever happens during loading is said to happen during ",(0,i.yg)("strong",{parentName:"p"},"load-time"),".\nAfter the process starts, whatever happens is said to happen at / during ",(0,i.yg)("strong",{parentName:"p"},"runtime"),"."),(0,i.yg)("p",null,"For this session we will first look at the process virtual address space and see how it is updated at runtime.\nWe will then map that information to the program executable and what's hapenning at load-time.\nWe will then spend more time dissecting and executable and make the first steps on static analysis, the subject of the ",(0,i.yg)("a",{parentName:"p",href:"../../Static%20Analysis/Reading"},"next section"),"."),(0,i.yg)("h2",{id:"process-memory-layout"},"Process Memory Layout"),(0,i.yg)("p",null,"To understand the full picture of program execution it is vital to understand the memory layout of processes from ELF executables.\nThe kernel provides an interface in ",(0,i.yg)("inlineCode",{parentName:"p"},"/proc/<PID>/maps")," for each process to see how the memory layout looks like."),(0,i.yg)("p",null,"Let's write a simple Hello World application and investigate."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"IMPORTANT:")," Note that we have removed ",(0,i.yg)("strong",{parentName:"p"},"Address Space Layout Randomization")," for these examples.\nWe'll explain this later."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\nint main()\n{\n    printf("Hello world\\n");\n    malloc(10000);\n    while(1){\n        ;\n    }\n    return 0;\n}\n')),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ gcc -Wall hw.c -o hw -m32\n\n$ ./hw  &\n[1] 4771\nHello world\n\n$ cat /proc/4771/maps\n08048000-08049000 r-xp 00000000 08:06 1843771                            /tmp/hw\n08049000-0804a000 r--p 00000000 08:06 1843771                            /tmp/hw\n0804a000-0804b000 rw-p 00001000 08:06 1843771                            /tmp/hw\n0804b000-0806e000 rw-p 00000000 00:00 0                                  [heap]\nf7ded000-f7dee000 rw-p 00000000 00:00 0\nf7dee000-f7f93000 r-xp 00000000 08:06 917808                             /lib32/libc-2.17.so\nf7f93000-f7f95000 r--p 001a5000 08:06 917808                             /lib32/libc-2.17.so\nf7f95000-f7f96000 rw-p 001a7000 08:06 917808                             /lib32/libc-2.17.so\nf7f96000-f7f99000 rw-p 00000000 00:00 0\nf7fd9000-f7fdb000 rw-p 00000000 00:00 0\nf7fdb000-f7fdc000 r-xp 00000000 00:00 0                                  [vdso]\nf7fdc000-f7ffc000 r-xp 00000000 08:06 917869                             /lib32/ld-2.17.so\nf7ffc000-f7ffd000 r--p 0001f000 08:06 917869                             /lib32/ld-2.17.so\nf7ffd000-f7ffe000 rw-p 00020000 08:06 917869                             /lib32/ld-2.17.so\nfffdd000-ffffe000 rw-p 00000000 00:00 0                                  [stack]\n")),(0,i.yg)("p",null,"If we start another process in the background the output for it will be exactly the same as this one.\nWhy is that?\nThe answer, of course, is virtual memory.\nThe kernel provides this mechanism through which each process has an address space ",(0,i.yg)("strong",{parentName:"p"},"completely isolated")," from that of other running processes.\nThey can still communicate using inter-process communication mechanisms provided by the kernel but we won't get into that here.\nShortly put, there would be two processes with the same name and with two ",(0,i.yg)("strong",{parentName:"p"},"apparently")," identical mappings, but still the two programs would be isolated from one another."),(0,i.yg)("p",null,"An initial schematic of the memory layout would be the following:"),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"ELF Memory Layout",src:a(4052).A,width:"481",height:"492"})),(0,i.yg)("h3",{id:"executable"},"Executable"),(0,i.yg)("p",null,"As we have seen, there are three memory regions associated with the executable:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"08048000-08049000 r-xp 00000000 08:06 1843771                            /tmp/hw\n08049000-0804a000 r--p 00000000 08:06 1843771                            /tmp/hw\n0804a000-0804b000 rw-p 00001000 08:06 1843771                            /tmp/hw\n")),(0,i.yg)("p",null,"From their permissions we can infer what they correspond to:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"08048000-08049000 r-xp")," is the ",(0,i.yg)("inlineCode",{parentName:"li"},".text")," section along with the rest of the executable parts"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"08049000-0804a000 r\u2013p")," is the ",(0,i.yg)("inlineCode",{parentName:"li"},".rodata")," section"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"0804a000-0804b000 rw-p")," consists of the ",(0,i.yg)("inlineCode",{parentName:"li"},".data"),", ",(0,i.yg)("inlineCode",{parentName:"li"},".bss")," sections and other R/W sections")),(0,i.yg)("p",null,"It is interesting to note that the executable is almost identically mapped into memory.\nThe only region that is ",(0,i.yg)("em",{parentName:"p"},"compressed")," in the binary is the ",(0,i.yg)("inlineCode",{parentName:"p"},".bss")," section.\nLet's see this in action by dumping the header of the file:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ hexdump -Cv hw | head\n00000000  7f 45 4c 46 01 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|\n00000010  02 00 03 00 01 00 00 00  b0 83 04 08 34 00 00 00  |............4...|\n00000020  78 11 00 00 00 00 00 00  34 00 20 00 0a 00 28 00  |x.......4. ...(.|\n00000030  1e 00 1b 00 06 00 00 00  34 00 00 00 34 80 04 08  |........4...4...|\n00000040  34 80 04 08 40 01 00 00  40 01 00 00 05 00 00 00  |4...@...@.......|\n00000050  04 00 00 00 03 00 00 00  74 01 00 00 74 81 04 08  |........t...t...|\n00000060  74 81 04 08 13 00 00 00  13 00 00 00 04 00 00 00  |t...............|\n00000070  01 00 00 00 01 00 00 00  00 00 00 00 00 80 04 08  |................|\n00000080  00 80 04 08 6c 06 00 00  6c 06 00 00 05 00 00 00  |....l...l.......|\n00000090  00 10 00 00 01 00 00 00  00 0f 00 00 00 9f 04 08  |................|\n\n$ gdb ./hw\n\ngdb-peda$ hexdump 0x08048000 /10\n0x08048000 : 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00   .ELF............\n0x08048010 : 02 00 03 00 01 00 00 00 b0 83 04 08 34 00 00 00   ............4...\n0x08048020 : 78 11 00 00 00 00 00 00 34 00 20 00 0a 00 28 00   x.......4. ...(.\n0x08048030 : 1e 00 1b 00 06 00 00 00 34 00 00 00 34 80 04 08   ........4...4...\n0x08048040 : 34 80 04 08 40 01 00 00 40 01 00 00 05 00 00 00   4...@...@.......\n0x08048050 : 04 00 00 00 03 00 00 00 74 01 00 00 74 81 04 08   ........t...t...\n0x08048060 : 74 81 04 08 13 00 00 00 13 00 00 00 04 00 00 00   t...............\n0x08048070 : 01 00 00 00 01 00 00 00 00 00 00 00 00 80 04 08   ................\n0x08048080 : 00 80 04 08 6c 06 00 00 6c 06 00 00 05 00 00 00   ....l...l.......\n0x08048090 : 00 10 00 00 01 00 00 00 00 0f 00 00 00 9f 04 08   ................\n")),(0,i.yg)("h3",{id:"heap"},"Heap"),(0,i.yg)("p",null,"The heap comes right after the executable at ",(0,i.yg)("inlineCode",{parentName:"p"},"0x0804b000")," and ends at ",(0,i.yg)("inlineCode",{parentName:"p"},"0x0806e000")," which is the current ",(0,i.yg)("inlineCode",{parentName:"p"},"brk")," point.\nThe memory allocator will increase the ",(0,i.yg)("inlineCode",{parentName:"p"},"brk")," when more allocations are made but will not decrease it when memory is freed so as to reuse the memory regions for future allocations.\nThe allocator in libc actually keeps a list of past allocations and their sizes.\nWhen future allocations will require the same size as a previously freed region, the allocator will reuse one from this lookup table.\nThe process is called ",(0,i.yg)("strong",{parentName:"p"},"binning"),"."),(0,i.yg)("p",null,"Let's see how the ",(0,i.yg)("inlineCode",{parentName:"p"},"brk")," evolves in our executable using strace:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ strace -i -e brk ./hw\n[ Process PID=1995 runs in 32 bit mode. ]\n[f7ff2314] brk(0)                       = 0x804b000\nHello world\n[f7fdb430] brk(0)                       = 0x804b000\n[f7fdb430] brk(0x806e000)               = 0x806e000\n")),(0,i.yg)("p",null,"Let's test the fact that the ",(0,i.yg)("inlineCode",{parentName:"p"},"brk")," does not decrease and that future ",(0,i.yg)("inlineCode",{parentName:"p"},"malloc")," calls can reuse previously freed regions:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},"#include <stdio.h>\nint main()\n{\n    void * buf[15];\n    int i;\n    for( i = 0 ; i < 15; i++)\n        buf[i] = malloc( i * 100) ;\n\n    for( i = 0 ; i < 15; i++)\n        free( buf[i] );\n\n    for( i = 0 ; i < 15; i++)\n        buf[i] = malloc( i * 100) ;\n\n\n    return 0;\n}\n")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ strace -e brk ./hw\n[ Process PID=2424 runs in 32 bit mode. ]\nbrk(0)                              = 0x804b000\nbrk(0)                              = 0x804b000\nbrk(0x806c000)                      = 0x806c000\n+++ exited with 0 +++\n\n$ ltrace -e malloc ./hw\nhw->malloc(0)                       = 0x804b008\nhw->malloc(100)                     = 0x804b018\nhw->malloc(200)                     = 0x804b080\nhw->malloc(300)                     = 0x804b150\nhw->malloc(400)                     = 0x804b280\nhw->malloc(500)                     = 0x804b418\nhw->malloc(600)                     = 0x804b610\nhw->malloc(700)                     = 0x804b870\nhw->malloc(800)                     = 0x804bb30\nhw->malloc(900)                     = 0x804be58\nhw->malloc(1000)                    = 0x804c1e0\nhw->malloc(1100)                    = 0x804c5d0\nhw->malloc(1200)                    = 0x804ca20\nhw->malloc(1300)                    = 0x804ced8\nhw->malloc(1400)                    = 0x804d3f0\n\nhw->malloc(0)                       = 0x804b008\nhw->malloc(100)                     = 0x804b018\nhw->malloc(200)                     = 0x804b080\nhw->malloc(300)                     = 0x804b150\nhw->malloc(400)                     = 0x804b280\nhw->malloc(500)                     = 0x804b418\nhw->malloc(600)                     = 0x804b610\nhw->malloc(700)                     = 0x804b870\nhw->malloc(800)                     = 0x804bb30\nhw->malloc(900)                     = 0x804be58\nhw->malloc(1000)                    = 0x804c1e0\nhw->malloc(1100)                    = 0x804c5d0\nhw->malloc(1200)                    = 0x804ca20\nhw->malloc(1300)                    = 0x804ced8\nhw->malloc(1400)                    = 0x804d3f0\n+++ exited (status 0) +++\n")),(0,i.yg)("p",null,"As you can see, only one ",(0,i.yg)("inlineCode",{parentName:"p"},"brk")," call is made.\nFurthermore, after the regions are freed they are reused."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"IMPORTANT:")," This behaviour of the allocator is important in the ",(0,i.yg)("strong",{parentName:"p"},"Use After Free")," class of vulnerabilities which we will be covering in the next labs."),(0,i.yg)("h3",{id:"memory-mappings-and-libraries"},"Memory Mappings and Libraries"),(0,i.yg)("p",null,"In our example we had the following memory mappings:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"f7ded000-f7dee000 rw-p 00000000 00:00 0\nf7dee000-f7f93000 r-xp 00000000 08:06 917808                             /lib32/libc-2.17.so\nf7f93000-f7f95000 r--p 001a5000 08:06 917808                             /lib32/libc-2.17.so\nf7f95000-f7f96000 rw-p 001a7000 08:06 917808                             /lib32/libc-2.17.so\nf7f96000-f7f99000 rw-p 00000000 00:00 0\nf7fd9000-f7fdb000 rw-p 00000000 00:00 0\nf7fdb000-f7fdc000 r-xp 00000000 00:00 0                                  [vdso]\nf7fdc000-f7ffc000 r-xp 00000000 08:06 917869                             /lib32/ld-2.17.so\nf7ffc000-f7ffd000 r--p 0001f000 08:06 917869                             /lib32/ld-2.17.so\nf7ffd000-f7ffe000 rw-p 00020000 08:06 917869                             /lib32/ld-2.17.so\n")),(0,i.yg)("p",null,"All functions that are called from external libraries ",(0,i.yg)("em",{parentName:"p"},"pull")," in the whole library into the address space.\nAs these are also ELF files you can see that they have similar patterns: multiple sections with different permissions just like the main executable."),(0,i.yg)("p",null,"One more thing to note here is that large calls to ",(0,i.yg)("inlineCode",{parentName:"p"},"malloc")," result in calls to ",(0,i.yg)("inlineCode",{parentName:"p"},"mmap2"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\nint main()\n{\n    printf("Hello world\\n");\n    printf("Small allocation %p\\n", malloc(10000));\n    printf("Big allocation %p\\n", malloc(10000000));\n    return 0;\n}\n')),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"# strace -e brk,mmap2  ./hw_large\n[ Process PID=3445 runs in 32 bit mode. ]\nbrk(0)                                  = 0x804b000\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xfffffffff7fda000\nmmap2(NULL, 265183, PROT_READ, MAP_PRIVATE, 3, 0) = 0xfffffffff7f99000\nmmap2(NULL, 1747628, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xfffffffff7dee000\nmmap2(0xf7f93000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1a5000) = 0xfffffffff7f93000\nmmap2(0xf7f96000, 10924, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xfffffffff7f96000\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xfffffffff7ded000\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xfffffffff7fd9000\nHello world\nbrk(0)                                  = 0x804b000\nbrk(0x806e000)                          = 0x806e000\nSmall allocation 0x804b008\nmmap2(NULL, 10002432, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xfffffffff7463000\nBig allocation 0xf7463008\n")),(0,i.yg)("p",null,"As expected, the ",(0,i.yg)("inlineCode",{parentName:"p"},"brk")," is increased when the first allocation is made.\nHowever, larger regions are backed by memory mappings."),(0,i.yg)("h3",{id:"stack"},"Stack"),(0,i.yg)("p",null,"If you observed from previous traces, the ",(0,i.yg)("inlineCode",{parentName:"p"},"mmap2")," call returns addresses towards NULL (lower addresses).\nIt behaves like this because there is another important memory region called the ",(0,i.yg)("inlineCode",{parentName:"p"},"stack")," that has a fixed size: usually 8 MB.\nSince the heap and the ",(0,i.yg)("inlineCode",{parentName:"p"},"mmap")," region do not have this limit imposed the optimization is to start mappings from a known boundary: the stack end boundary.\nLet's put this into perspective.\nYou can view the current stack limit using ",(0,i.yg)("inlineCode",{parentName:"p"},"ulimit -s"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ ulimit -s\n8192\n\n$ python\n>>> hex(0xffffffff - 8192*1024)\n'0xff7fffff'\n")),(0,i.yg)("p",null,"This address is the stack boundary.\nIt seems odd then that the first ",(0,i.yg)("inlineCode",{parentName:"p"},"mmap")," in the program above ends at ",(0,i.yg)("inlineCode",{parentName:"p"},"0xf7ffe000")," and not ",(0,i.yg)("inlineCode",{parentName:"p"},"0xff7fffff"),".\nThis is probably an optimization."),(0,i.yg)("p",null,"However, we can set the stack size to unlimited and the ",(0,i.yg)("inlineCode",{parentName:"p"},"mmap")," allocation direction will reverse:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ ulimit -s unlimited\n\n$ strace -e mmap2,brk ./hw_large\n[ Process PID=4617 runs in 32 bit mode. ]\nbrk(0)                                  = 0x804b000\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x55578000\nmmap2(NULL, 265183, PROT_READ, MAP_PRIVATE, 3, 0) = 0x55579000\nmmap2(NULL, 1747628, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x555ba000\nmmap2(0x5575f000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1a5000) = 0x5575f000\nmmap2(0x55762000, 10924, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x55762000\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x55765000\nmmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x55579000\nHello world\nbrk(0)                                  = 0x804b000\nbrk(0x806e000)                          = 0x806e000\nSmall allocation 0x804b008\nmmap2(NULL, 10002432, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x55766000\nBig allocation 0x55766008\n^Z\n[1]+  Stopped                 strace -e mmap2,brk ./hw_large\n\n$ cat /proc/4617/maps\n08048000-08049000 r-xp 00000000 08:06 1843771                            /tmp/hw_large\n08049000-0804a000 r--p 00000000 08:06 1843771                            /tmp/hw_large\n0804a000-0804b000 rw-p 00001000 08:06 1843771                            /tmp/hw_large\n0804b000-0806e000 rw-p 00000000 00:00 0                                  [heap]\n55555000-55575000 r-xp 00000000 08:06 917869                             /lib32/ld-2.17.so\n55575000-55576000 r--p 0001f000 08:06 917869                             /lib32/ld-2.17.so\n55576000-55577000 rw-p 00020000 08:06 917869                             /lib32/ld-2.17.so\n55577000-55578000 r-xp 00000000 00:00 0                                  [vdso]\n55578000-5557a000 rw-p 00000000 00:00 0\n555ba000-5575f000 r-xp 00000000 08:06 917808                             /lib32/libc-2.17.so\n5575f000-55761000 r--p 001a5000 08:06 917808                             /lib32/libc-2.17.so\n55761000-55762000 rw-p 001a7000 08:06 917808                             /lib32/libc-2.17.so\n55762000-560f0000 rw-p 00000000 00:00 0\nfffdd000-ffffe000 rw-p 00000000 00:00 0                                  [stack]\n")),(0,i.yg)("p",null,"As you can see, the big allocation is now towards the stack instead of towards the heap."),(0,i.yg)("p",null,"Returning to the main functionality of the stack, remember from the previous lab that local variables are declared on the stack.\nThis translates into assembly code in the following way:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},"int main()\n{\n\n        char buf[1000];\n        int i;\n............\n}\n")),(0,i.yg)("p",null,"The C snippet would be translated into ASM something like:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"0804840c <main>:\n 804840c:   55                      push   ebp\n 804840d:   89 e5                   mov    ebp,esp\n 804840f:   81 ec f0 03 00 00       sub    esp,0x3f0\n..........\n")),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"0x3f0")," hex value is equal to ",(0,i.yg)("inlineCode",{parentName:"p"},"1008")," in decimal, which is precisely 1000 (from ",(0,i.yg)("inlineCode",{parentName:"p"},"buf"),") + 4 (from ",(0,i.yg)("inlineCode",{parentName:"p"},"i"),") + 4 (the storage of another int that the compiler used later in the code)."),(0,i.yg)("p",null,"As the program subtracts more from ",(0,i.yg)("inlineCode",{parentName:"p"},"esp")," the kernel will provide pages on-demand until the stack boundary or another ",(0,i.yg)("inlineCode",{parentName:"p"},"mmap"),"-ing is hit.\nThe kernel will, in this case, kill the application because of the Segmentation Fault."),(0,i.yg)("h3",{id:"segmentation-fault"},"Segmentation Fault"),(0,i.yg)("p",null,"Now that we know everything about the memory address space we can say more about the infamous ",(0,i.yg)("inlineCode",{parentName:"p"},"Segmentation Fault")," that all of us have, at some time, encountered.\nIt is basically a permission violation.\nApart from the mappings that appear in ",(0,i.yg)("inlineCode",{parentName:"p"},"/proc/<PID>/maps")," with ",(0,i.yg)("inlineCode",{parentName:"p"},"r--"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"rw-"),", etc, you can consider that everything else is ",(0,i.yg)("inlineCode",{parentName:"p"},"---"),".\nThus, a read access at such a location will violate the permission of that region so the whole app will be killed by the signal received (unless it has a signal handler).\nExamples:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Dereferencing a ",(0,i.yg)("inlineCode",{parentName:"li"},"NULL")," pointer will try to read from ",(0,i.yg)("inlineCode",{parentName:"li"},"0x00000000")," which is not (usually) mapped => ",(0,i.yg)("inlineCode",{parentName:"li"},"SIGSEGV")," (read access on none)"),(0,i.yg)("li",{parentName:"ul"},"Writing after the end of a heap buffer (if the heap buffer is exactly at the end of a mapping) will determine writes into unmapped pages => ",(0,i.yg)("inlineCode",{parentName:"li"},"SIGSEGV")," (write access on none)"),(0,i.yg)("li",{parentName:"ul"},"Trying to write to ",(0,i.yg)("inlineCode",{parentName:"li"},".rodata")," => ",(0,i.yg)("inlineCode",{parentName:"li"},"SIGSEGV")," (write access on read only)"),(0,i.yg)("li",{parentName:"ul"},"Overwriting the stack with ",(0,i.yg)("inlineCode",{parentName:"li"},'"AAAAAAAAAAAAAAAAAAA"')," will also overwrite the return address and make the execution go to ",(0,i.yg)("inlineCode",{parentName:"li"},"0x41414141")," => ",(0,i.yg)("inlineCode",{parentName:"li"},"SIGSEGV")," (execute access on none)"),(0,i.yg)("li",{parentName:"ul"},"Overwriting the stack and return address with another address to a shellcode on the stack => ",(0,i.yg)("inlineCode",{parentName:"li"},"SIGSEGV")," (execute access on read/write only)"),(0,i.yg)("li",{parentName:"ul"},"Trying to rewrite the binary (",(0,i.yg)("inlineCode",{parentName:"li"},"int *v = main; *v = 0x90909090;"),") => ",(0,i.yg)("inlineCode",{parentName:"li"},"SIGSEGV")," (write access on read/execute only)")),(0,i.yg)("h2",{id:"tutorials"},"Tutorials"),(0,i.yg)("p",null,"This session is focused on the transformation of an ",(0,i.yg)("strong",{parentName:"p"},"ELF file")," (stored on disk) as it is loaded into memory and becomes ",(0,i.yg)("strong",{parentName:"p"},"a process")," (stored into memory).\nWe will first analyze the structure of an ",(0,i.yg)("strong",{parentName:"p"},"ELF file")," and how this structure evolves when going from ",(0,i.yg)("strong",{parentName:"p"},"C source code"),", to ",(0,i.yg)("strong",{parentName:"p"},"object file")," and then to either ",(0,i.yg)("strong",{parentName:"p"},"an executable")," or ",(0,i.yg)("strong",{parentName:"p"},"a shared library"),".\nWe will also skim over how various elements are interpreted by the ",(0,i.yg)("strong",{parentName:"p"},"linker")," and the ",(0,i.yg)("strong",{parentName:"p"},"loader"),".\nFinally, we will see the layout of a process once it is loaded into memory."),(0,i.yg)("h3",{id:"big-picture-view"},"Big Picture View"),(0,i.yg)("p",null,"Sun Microsystems' SunOS came up with the concept of dynamic shared libraries and introduced it to UNIX in the late 1980s.\nUNIX System V Release 4, which Sun co-developed, introduced the ELF object format adaptation from the Sun scheme.\nLater it was developed and published as part of the ",(0,i.yg)("inlineCode",{parentName:"p"},"ABI")," (",(0,i.yg)("em",{parentName:"p"},"Application Binary Interface"),") as an improvement over ",(0,i.yg)("inlineCode",{parentName:"p"},"COFF"),", the previous object format and by the late 1990s it had become the standard for UNIX and UNIX-like systems including Linux and BSD derivatives.\nDepending on processor architectures, several specifications have emerged with minor changes, but for this session we will be focusing on the ",(0,i.yg)("a",{parentName:"p",href:"http://www.skyfree.org/linux/references/ELF_Format.pdf"},"ELF-32")," format."),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"Linking View and Execution View",src:a(3316).A,width:"400",height:"356"})),(0,i.yg)("p",null,"The structure of an ELF file during the linking process is the same with that of an object file.\nThe linking process involves collecting and combining code and data into a single file that will later be loaded into memory and executed.\nOn the right hand side we can see how the the ELF file structure will be transformed in memory.\n",(0,i.yg)("strong",{parentName:"p"},"Sections")," instruct the Linker while ",(0,i.yg)("strong",{parentName:"p"},"Segments")," instruct the Operating System."),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"ELF Merging",src:a(9299).A,width:"300",height:"332"})),(0,i.yg)("p",null,"As we can see, the information inside the two program headers and the section headers gets merged as needed inside the more familiar program segments.\nThe basic role of the ELF file format is to serve as a roadmap for the linker and the OS Loader to generate a running process."),(0,i.yg)("h3",{id:"staticdynamic-linking"},"Static/Dynamic linking"),(0,i.yg)("p",null,"Out of practical considerations, for very large programs, even early on, it was very impractical to store all of the source code inside a single file.\nOne of the most mundane of all actions, namely splitting your source code into functions across multiple files while still obtaining a valid running program was a difficult engineering challenge.\nThe initial paradigm was called ",(0,i.yg)("strong",{parentName:"p"},"static linking")," and was the only option inside the ",(0,i.yg)("inlineCode",{parentName:"p"},"COFF")," file format.\nIt involves interpreting each piece of code from each file and then merging all the information inside a single binary that would contain all the machine code necessary for the program.\nThis way of doing things, still in use today, involves loading all of the code and data into memory regardless of use case.\nThis basically meant that, the required resources to run a program were determined by the number of instances, with no possibility of optimization.\nRunning 10 instances of the same program meant that there was a lot of code duplication going on in the memory space."),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"ELF Static Linking",src:a(3513).A,width:"500",height:"262"})),(0,i.yg)("p",null,"Along with the ELF format came a new way of doing things.\nInstead of linking all the source files that contained subroutines into the final binaries, separate binaries were organized in libraries that could be loaded per use case, on demand.\nEssentially, the libraries were loaded only once into memory and when a program instance required a subroutine from a specific library it would inquire a special OS component about it and new resources would be allocated only for the volatile parts of the library image (",(0,i.yg)("inlineCode",{parentName:"p"},".bss")," and ",(0,i.yg)("inlineCode",{parentName:"p"},".data"),").\nThe new process allowed for a much more efficient resource utilization and was named dynamic linking and the new type of library files were called shared objects.\nRunning 10 instances of the same program now meant that only the volatile parts of those binaries would be duplicated.\nIn cases where the same code can be reused, it is allocated only once and used by multiple instances of the same program."),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"ELF Dynamic Linking",src:a(2034).A,width:"500",height:"283"})),(0,i.yg)("h3",{id:"elf-types"},"ELF Types"),(0,i.yg)("p",null,"There are several ELF types but the most common types we will be dealing with are:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Relocatable Files"),(0,i.yg)("li",{parentName:"ul"},"Shared Objects"),(0,i.yg)("li",{parentName:"ul"},"Executable Files")),(0,i.yg)("h4",{id:"elf-type---relocatable-files"},"ELF Type - Relocatable Files"),(0,i.yg)("p",null,"Relocatable files are obtained using the core compiler and basically contain all the ELF information necessary except for data like external variables or subroutines that are present in other files."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"gcc -c -o reloc.o source.c\ngcc -c -fPIC -o reloc.o source.c\n")),(0,i.yg)("p",null,"The first command will produce a relocatable file that will later constitute an executable or a static library.\nIf we want to use the relocatable file to later create a shared library we need to use the second variant to create a relocatable file that has ",(0,i.yg)("a",{parentName:"p",href:"https://wiki.gentoo.org/wiki/Hardened/Introduction_to_Position_Independent_Code"},"Position Independent Code")," (PIC)."),(0,i.yg)("h4",{id:"elf-type---shared-objects"},"ELF Type - Shared Objects"),(0,i.yg)("p",null,"Shared libraries are loaded up at runtime as needed by an OS component named the dynamic loader.\nShared objects may include other shared objects and this aspect is very important because, when loading specific subroutines, the ELF file must provide its dependencies.\nAs such, the process of dynamic linking does a breadth first search gradually building the full dependency list."),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"Shared Objects",src:a(751).A,width:"500",height:"308"})),(0,i.yg)("p",null,"You can view the list of shared object dependencies for any given binary as well as the addresses where they will be loaded in memory by using the ",(0,i.yg)("inlineCode",{parentName:"p"},"ldd")," command."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"ldd /bin/ls\n    linux-gate.so.1 =>  (0x00e02000)\n    librt.so.1 => /lib/tls/i686/cmov/librt.so.1 (0x004f9000)\n    libselinux.so.1 => /lib/libselinux.so.1 (0x00c62000)\n    libacl.so.1 => /lib/libacl.so.1 (0x00a87000)\n    libc.so.6 => /lib/tls/i686/cmov/libc.so.6 (0x00110000)\n    libpthread.so.0 => /lib/tls/i686/cmov/libpthread.so.0 (0x00325000)\n    /lib/ld-linux.so.2 (0x00a45000)\n    libdl.so.2 => /lib/tls/i686/cmov/libdl.so.2 (0x0077d000)\n    libattr.so.1 => /lib/libattr.so.1 (0x00dd7000)\n")),(0,i.yg)("p",null,"All libraries should adhere to a strict naming convention.\nShared objects have two names:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"strong"},"soname"))," - that consists of the prefix ",(0,i.yg)("inlineCode",{parentName:"li"},"lib"),", followed by the library name, then a ",(0,i.yg)("inlineCode",{parentName:"li"},".so"),", another dot, then the major version (e.g. ",(0,i.yg)("inlineCode",{parentName:"li"},"libtest.so.1"),")"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"real name")," - is actually a filename, that usually extends the ",(0,i.yg)("inlineCode",{parentName:"li"},"soname")," by adding a dot and minor version number along with the release version (e.g. ",(0,i.yg)("inlineCode",{parentName:"li"},"libtest.so.1.23.3"),")")),(0,i.yg)("p",null,"Additionally, each library source file should have an accompanying header file with the extension ",(0,i.yg)("inlineCode",{parentName:"p"},".h")," and the same name."),(0,i.yg)("p",null,"Adhering to these naming conventions is quite important as dependencies are resolved based on the ",(0,i.yg)("inlineCode",{parentName:"p"},"soname"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},'gcc -c -fPIC libtesting.c\nld -shared -soname libtesting.so.1 -o libtesting.so.1.0 -lc libtesting.o\nldconfig -v -n .\nln -sf libtesting.so.1 libtesting.so\nexport LD_LIBRARY_PATH=.:"$LD_LIBRARY_PATH"\ngcc -o main_program main_program.c -L. -ltesting\n')),(0,i.yg)("p",null,"The first line creates an object file with position independent code.\nThe second line will create the shared object with ",(0,i.yg)("inlineCode",{parentName:"p"},"soname")," ",(0,i.yg)("inlineCode",{parentName:"p"},"libtesting.so.1")," and a real filename of ",(0,i.yg)("inlineCode",{parentName:"p"},"libtesting.so.1.0")," by using the linker.\nShared objects are usually installed in other directories but the line containing ",(0,i.yg)("inlineCode",{parentName:"p"},"ldconfig"),", will install it in the current directory.\nAt runtime the standard directories like ",(0,i.yg)("inlineCode",{parentName:"p"},"/usr/lib")," are searched, but we add the local directory to the search path by modifying the ",(0,i.yg)("inlineCode",{parentName:"p"},"LD_LIBRARY_PATH")," environment variable."),(0,i.yg)("p",null,"Finally, the executable is created by dynamic linking against the shared object."),(0,i.yg)("p",null,"A good tutorial on how to create a basic shared object can be found ",(0,i.yg)("a",{parentName:"p",href:"https://www.ibm.com/developerworks/library/l-shobj/"},"here"),"."),(0,i.yg)("h4",{id:"elf-type---executable-files"},"ELF Type - Executable Files"),(0,i.yg)("p",null,"They are regarded as the end result and contain all the information necessary to create a running process."),(0,i.yg)("h3",{id:"elf-structure"},"ELF Structure"),(0,i.yg)("p",null,"The following wiki sections on ELF structure are dense and are ",(0,i.yg)("strong",{parentName:"p"},"not")," meant to be known by heart.\n",(0,i.yg)("strong",{parentName:"p"},"Do not")," try to read them all at once and memorize them, but rather use the following chapters as ",(0,i.yg)("strong",{parentName:"p"},"reference"),"."),(0,i.yg)("p",null,"Tools of the trade are:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"readelf")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"objdump")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"ldd")),(0,i.yg)("li",{parentName:"ul"},"Ghidra/IDA (Ghidra is Open Source, while IDA is not and it is really expensive)")),(0,i.yg)("p",null,"The command outputs that follow are rather large so we will only be discussing the less obvious parts.\nWe will also leave out information that's not really that important or generally weird."),(0,i.yg)("h4",{id:"elf-header"},"ELF Header"),(0,i.yg)("p",null,"Using ",(0,i.yg)("inlineCode",{parentName:"p"},"readelf")," is straight-forward enough:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"readelf -h program\n\nELF Header:\n  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00\n  Class:                             ELF32\n  Data:                              2's complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              EXEC (Executable file)\n  Machine:                           Intel 80386\n  Version:                           0x1\n  Entry point address:               0x8048330\n  Start of program headers:          52 (bytes into file)\n  Start of section headers:          4392 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               52 (bytes)\n  Size of program headers:           32 (bytes)\n  Number of program headers:         8\n  Size of section headers:           40 (bytes)\n  Number of section headers:         30\n  Section header string table index: 27\n")),(0,i.yg)("p",null,"Below we will discuss the less evident aspects of the above output"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Elf Identification")," (16 bytes)",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Magic")," - the first bytes of the binary that identify the file as ELF"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Class")," - identifies the type of ELF (ex: ELF-32, ELF-64)"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Data")," - specifies the type of data encoding"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Version")," - version of the ELF header"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"OS/ABI")," - version of the OS"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"ABI")," - version of the ABI specification"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Type")," - Relocatable, Executable, Shared Object"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Machine")," - Required Machine architecture to run the executable"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Entry Point Address")," - the memory address where the OS loader transfers control to the process code for the first time."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Start of Program Headers")," - File offset where the array of program headers start"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Start of Section Headers")," - File offset where the array of section headers starts"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Section Header String Table Index")," - the index in the section table name where the information about the section name string table can be found")),(0,i.yg)("h4",{id:"program-headers"},"Program Headers"),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Program Headers")," are only present inside ",(0,i.yg)("strong",{parentName:"p"},"Executable")," and ",(0,i.yg)("strong",{parentName:"p"},"Shared Object")," files."),(0,i.yg)("p",null,"Again, ",(0,i.yg)("inlineCode",{parentName:"p"},"readelf")," is used with minimum syntax:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ readelf -l program\n\nElf file type is EXEC (Executable file)\nEntry point 0x8048330\nThere are 8 program headers, starting at offset 52\n\nProgram Headers:\n  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n  PHDR           0x000034 0x08048034 0x08048034 0x00100 0x00100 R E 0x4\n  INTERP         0x000134 0x08048134 0x08048134 0x00013 0x00013 R   0x1\n      [Requesting program interpreter: /lib/ld-linux.so.2]\n  LOAD           0x000000 0x08048000 0x08048000 0x004e4 0x004e4 R E 0x1000\n  LOAD           0x000f0c 0x08049f0c 0x08049f0c 0x00108 0x00110 RW  0x1000\n  DYNAMIC        0x000f20 0x08049f20 0x08049f20 0x000d0 0x000d0 RW  0x4\n  NOTE           0x000148 0x08048148 0x08048148 0x00044 0x00044 R   0x4\n  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4\n  GNU_RELRO      0x000f0c 0x08049f0c 0x08049f0c 0x000f4 0x000f4 R   0x1\n\n Section to Segment mapping:\n  Segment Sections...\n   00\n   01     .interp\n   02     .interp .note.ABI-tag .note.gnu.build-id .hash .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame\n   03     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss\n   04     .dynamic\n   05     .note.ABI-tag .note.gnu.build-id\n   06\n   07     .ctors .dtors .jcr .dynamic .got\n")),(0,i.yg)("p",null,"The ",(0,i.yg)("strong",{parentName:"p"},"Program Header")," table features an array of structures that shows how parts of the file will be mapped into memory at runtime.\nThe last parts of the output show what sections will be merged into various program headers before loading the ELF into memory and becoming segments."),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Type"),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"PHDR")," - information about the program header table itself"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"INTERP")," - information about the null terminated string that specifies the path to the dynamic loader.\nThis header is only present in executable that use shared object code"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"LOAD")," - use to specify a general purpose loadable segment"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"DYNAMIC")," - information necessary to the dynamic linking process"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Offset")," - offset from the beginning of the file where the segment begins"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"VirtAddr")," - the address where the segment will start in memory"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"FileSz")," - number of bytes occupied by the segment on disk"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"MemSiz")," - number of bytes occupied by the segment in memory"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Align")," - specifies a boundary to which the segments are aligned on file and in memory")),(0,i.yg)("p",null,"Here are two resources to read about ",(0,i.yg)("a",{parentName:"p",href:"https://www.airs.com/blog/archives/189"},(0,i.yg)("inlineCode",{parentName:"a"},"GNU_RELRO"))," and ",(0,i.yg)("a",{parentName:"p",href:"https://guru.multimedia.cx/pt_gnu_stack/"},(0,i.yg)("inlineCode",{parentName:"a"},"GNU_STACK"))," ",(0,i.yg)("strong",{parentName:"p"},"Program Headers"),"."),(0,i.yg)("h4",{id:"section-table"},"Section Table"),(0,i.yg)("p",null,"Section headers are the central piece of reference used to organize the ELF files both on disk and in memory."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"readelf -S program\nThere are 30 section headers, starting at offset 0x1128:\n\nSection Headers:\n  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n  [ 0]                   NULL            00000000 000000 000000 00      0   0  0\n  [ 1] .interp           PROGBITS        08048134 000134 000013 00   A  0   0  1\n  [ 2] .note.ABI-tag     NOTE            08048148 000148 000020 00   A  0   0  4\n  [ 3] .note.gnu.build-i NOTE            08048168 000168 000024 00   A  0   0  4\n  [ 4] .hash             HASH            0804818c 00018c 000028 04   A  6   0  4\n  [ 5] .gnu.hash         GNU_HASH        080481b4 0001b4 000020 04   A  6   0  4\n  [ 6] .dynsym           DYNSYM          080481d4 0001d4 000050 10   A  7   1  4\n  [ 7] .dynstr           STRTAB          08048224 000224 00004c 00   A  0   0  1\n  [ 8] .gnu.version      VERSYM          08048270 000270 00000a 02   A  6   0  2\n  [ 9] .gnu.version_r    VERNEED         0804827c 00027c 000020 00   A  7   1  4\n  [10] .rel.dyn          REL             0804829c 00029c 000008 08   A  6   0  4\n  [11] .rel.plt          REL             080482a4 0002a4 000018 08   A  6  13  4\n  [12] .init             PROGBITS        080482bc 0002bc 000030 00  AX  0   0  4\n  [13] .plt              PROGBITS        080482ec 0002ec 000040 04  AX  0   0  4\n  [14] .text             PROGBITS        08048330 000330 00017c 00  AX  0   0 16\n  [15] .fini             PROGBITS        080484ac 0004ac 00001c 00  AX  0   0  4\n  [16] .rodata           PROGBITS        080484c8 0004c8 000015 00   A  0   0  4\n  [17] .eh_frame         PROGBITS        080484e0 0004e0 000004 00   A  0   0  4\n  [18] .ctors            PROGBITS        08049f0c 000f0c 000008 00  WA  0   0  4\n  [19] .dtors            PROGBITS        08049f14 000f14 000008 00  WA  0   0  4\n  [20] .jcr              PROGBITS        08049f1c 000f1c 000004 00  WA  0   0  4\n  [21] .dynamic          DYNAMIC         08049f20 000f20 0000d0 08  WA  7   0  4\n  [22] .got              PROGBITS        08049ff0 000ff0 000004 04  WA  0   0  4\n  [23] .got.plt          PROGBITS        08049ff4 000ff4 000018 04  WA  0   0  4\n  [24] .data             PROGBITS        0804a00c 00100c 000008 00  WA  0   0  4\n  [25] .bss              NOBITS          0804a014 001014 000008 00  WA  0   0  4\n  [26] .comment          PROGBITS        00000000 001014 000023 01  MS  0   0  1\n  [27] .shstrtab         STRTAB          00000000 001037 0000ee 00      0   0  1\n  [28] .symtab           SYMTAB          00000000 0015d8 000410 10     29  45  4\n  [29] .strtab           STRTAB          00000000 0019e8 0001fd 00      0   0  1\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Name")," - is obtained by reading the value of the section names table at the specified index"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Type"),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"PROGBITS")," - information that is given meaning by the program when loaded into memory"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"NOBITS")," - similar to ",(0,i.yg)("inlineCode",{parentName:"li"},"PROGBITS")," in meaning but occupies no space in the file"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"STRTAB")," - contains the program string table"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"SYMTAB")," - contains the symbol table"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"DYNAMIC")," - holds information necessary for dynamic linking"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"DYNSYM")," - holds a set of symbols used in the dynamic linking process"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"REL")," - holds relocation entries"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Addr")," - if the section is part of an executable it will hold the virtual address where the section could be found in memory.\nIf not it would be 0."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Off")," - offset from the beginning of the file to where the section starts"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Size")," - size of the section in bytes"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"ES")," - size in bytes per entry, if fixed entry size is used"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"FLG")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"X")," - contains executable code"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"W")," - contains writable code"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"A")," - will be loaded into memory as-is during process execution"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Al")," - section alignment constraints")),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"Inf")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"Lnk")," columns have specific interpretations depending on the section type, as can be seen in the following image:"),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"ELF Sections Inf and Lnk",src:a(4603).A,width:"500",height:"282"})),(0,i.yg)("p",null,"Additionally, the raw contents of each section can be dumped using both ",(0,i.yg)("inlineCode",{parentName:"p"},"objdump")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"readelf"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"readelf -x .got program\n\nHex dump of section '.got':\n  0x08049ff0 00000000                            ....\n")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},'objdump -s -j ".got"  program\n\nprogram:     file format elf32-i386\n\nContents of section .got:\n 8049ff0 00000000                             ....\n')),(0,i.yg)("p",null,"For more details about the kind of data stored by ELF sections, refer to this ",(0,i.yg)("a",{parentName:"p",href:"https://refspecs.linuxfoundation.org/LSB_3.0.0/LSB-Core-generic/LSB-Core-generic/specialsections.html"},"resource"),"."),(0,i.yg)("p",null,"When trying to dump contents of section using ",(0,i.yg)("inlineCode",{parentName:"p"},"readelf")," you can interpret the output like strings by using the ",(0,i.yg)("inlineCode",{parentName:"p"},"-p")," flag."),(0,i.yg)("h4",{id:"symbol-table"},"Symbol Table"),(0,i.yg)("p",null,"One of the initial goals of the ELF format was to enable dynamic linking.\nGiven the machine code of a binary, various elements inside it will use absolute addresses that are based on the memory address where the binary expects to be loaded.\nThe entire idea of shared libraries is that these can be loaded and unloaded on demand inside the memory space of whichever process needs them at whichever address is available.\nAs such, a map of how to locate and relocate absolute data points inside the machine code is needed and that's where the symbol table comes in."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"readelf -s libtesting.so.1\n\nSymbol table '.dynsym' contains 8 entries:\n   Num:    Value  Size Type    Bind   Vis      Ndx Name\n     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND\n     1: 00001339     1 OBJECT  GLOBAL DEFAULT   12 cPub\n     2: 000001f8    10 FUNC    GLOBAL DEFAULT    7 fPub\n     3: 0000020c   100 FUNC    GLOBAL DEFAULT    7 foo\n     4: 00001328    16 OBJECT  GLOBAL DEFAULT   11 a\n     5: 00001338     0 NOTYPE  GLOBAL DEFAULT  ABS __bss_start\n     6: 0000133c     0 NOTYPE  GLOBAL DEFAULT  ABS _end\n     7: 00001338     0 NOTYPE  GLOBAL DEFAULT  ABS _edata\n\nSymbol table '.symtab' contains 27 entries:\n   Num:    Value  Size Type    Bind   Vis      Ndx Name\n     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND\n     1: 000000b4     0 SECTION LOCAL  DEFAULT    1\n     2: 000000e8     0 SECTION LOCAL  DEFAULT    2\n     3: 00000168     0 SECTION LOCAL  DEFAULT    3\n     4: 000001a8     0 SECTION LOCAL  DEFAULT    4\n     5: 000001d0     0 SECTION LOCAL  DEFAULT    5\n     6: 000001d8     0 SECTION LOCAL  DEFAULT    6\n     7: 000001f8     0 SECTION LOCAL  DEFAULT    7\n     8: 00001274     0 SECTION LOCAL  DEFAULT    8\n     9: 00001314     0 SECTION LOCAL  DEFAULT    9\n    10: 00001318     0 SECTION LOCAL  DEFAULT   10\n    11: 00001328     0 SECTION LOCAL  DEFAULT   11\n    12: 00001338     0 SECTION LOCAL  DEFAULT   12\n    13: 00000000     0 SECTION LOCAL  DEFAULT   13\n    14: 00000000     0 FILE    LOCAL  DEFAULT  ABS libtesting.c\n    15: 00000202    10 FUNC    LOCAL  DEFAULT    7 fLocal\n    16: 00001338     1 OBJECT  LOCAL  DEFAULT   12 cLocal\n    17: 00001318     0 OBJECT  LOCAL  HIDDEN  ABS _GLOBAL_OFFSET_TABLE_\n    18: 00000270     0 FUNC    LOCAL  HIDDEN    7 __i686.get_pc_thunk.bx\n    19: 00001274     0 OBJECT  LOCAL  HIDDEN  ABS _DYNAMIC\n    20: 00001339     1 OBJECT  GLOBAL DEFAULT   12 cPub\n    21: 000001f8    10 FUNC    GLOBAL DEFAULT    7 fPub\n    22: 0000020c   100 FUNC    GLOBAL DEFAULT    7 foo\n    23: 00001328    16 OBJECT  GLOBAL DEFAULT   11 a\n    24: 00001338     0 NOTYPE  GLOBAL DEFAULT  ABS __bss_start\n    25: 0000133c     0 NOTYPE  GLOBAL DEFAULT  ABS _end\n    26: 00001338     0 NOTYPE  GLOBAL DEFAULT  ABS _edata\n")),(0,i.yg)("p",null,"Some information on the symbols that may belong to external files or may be referenced by external files during dynamic linking are copied in the ",(0,i.yg)("inlineCode",{parentName:"p"},".dynsym")," section."),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Name")," - symbol name"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Type"),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"NoType")," - not specified"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"FUNC")," - the symbol influences a function"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"SECTION")," - associated with a section"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"FILE")," - a symbol that references a files"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Bind"),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"LOCAL")," - the symbol information is not visible outside the object file"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"GLOBAL")," - the symbol is visible to all the files being combined to form the executable"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Size")," - the size of the symbol in bytes or 0 if it is unknown"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Ndx"),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"UND")," - unspecified section reference"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"COM")," - unallocated C external variable"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"ABS")," - an absolute value for the reference"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"value")," - an index into the section table"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Value")," - if the symbol table is part of an executable, the value will contain a memory address where the symbol resides.\nOtherwise it will contain an offset from the beginning of the section referenced by ",(0,i.yg)("inlineCode",{parentName:"li"},"Ndx")," or ",(0,i.yg)("inlineCode",{parentName:"li"},"O"))),(0,i.yg)("p",null,"As you can see, the symbol table as it appears in object files compiled with gcc is quite verbose, revealing function names and visibility as well as variable scopes, names and even sizes.\nIn its default form it even shows the name of the source file."),(0,i.yg)("p",null,"In order to subvert Reverse Engineering attempts you can check out some of the methods of stripping the symbol table of valuable information:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html"},(0,i.yg)("inlineCode",{parentName:"a"},"A Whirlwind Tutorial on Creating Really Teensy ELF Executables for Linux"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://sourceware.org/binutils/docs/binutils/strip.html"},(0,i.yg)("inlineCode",{parentName:"a"},"strip")))),(0,i.yg)("h4",{id:"relocations"},"Relocations"),(0,i.yg)("p",null,"Relocations were a concept that was present ever since the invention of static linking.\nThe initial purpose of relocations was to give the static linker a roadmap when combining multiple object files into a binary by stating:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"The ",(0,i.yg)("strong",{parentName:"li"},"Symbol")," that needs to be fixed."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Where")," you can find the symbol (file/section offset)."),(0,i.yg)("li",{parentName:"ul"},"An ",(0,i.yg)("strong",{parentName:"li"},"Algorithm")," for making the fixes.")),(0,i.yg)("p",null,"The fixes would usually be made in the ",(0,i.yg)("inlineCode",{parentName:"p"},".data")," and ",(0,i.yg)("inlineCode",{parentName:"p"},".text")," sections and everything was well.\nDynamic runtime brought a bit of a complication to modifications that needed to be made in the code segments.\nThe whole idea of shared libraries is that the code can be loaded once into memory from an ELF file then shared among all the processes that use the library.\nThe only way to reliably do this is to make the code section read-only."),(0,i.yg)("p",null,"In order to compensate for this constraint a special data section called the ",(0,i.yg)("inlineCode",{parentName:"p"},"GOT")," (",(0,i.yg)("em",{parentName:"p"},"Global Offset Table"),") was created.\nWhen the code needs to work with a symbol that belongs to shared object, in the code entry for that symbol uses addresses from the ",(0,i.yg)("inlineCode",{parentName:"p"},"GOT")," table.\nFirst time the symbol is referenced the dynamic linker corrects the entry in ",(0,i.yg)("inlineCode",{parentName:"p"},"GOT")," and on subsequent calls the correct address will be used."),(0,i.yg)("p",null,"When implementing calls to subroutines in shared objects, a different table is used called the ",(0,i.yg)("inlineCode",{parentName:"p"},"PLT")," (",(0,i.yg)("em",{parentName:"p"},"Procedure Linkage Table"),").\nThe initial call is made to a stub sequence in the ",(0,i.yg)("inlineCode",{parentName:"p"},"PLT")," which bounces off a ",(0,i.yg)("inlineCode",{parentName:"p"},"GOT")," entry in order to push the subroutine name on the stack and then calls the resolver (mentioned in the ",(0,i.yg)("inlineCode",{parentName:"p"},"INTERP")," program header)."),(0,i.yg)("p",null,"Relocations and how they get applied are very complex topic and we will only try to cover as far is helps detecting file and symbol types If you want to read more you can refer to some of these resources:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"http://www.mindfruit.co.uk/2012/06/relocations-relocations.html"},(0,i.yg)("inlineCode",{parentName:"a"},"Some Assembly Required"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"http://netwinder.osuosl.org/users/p/patb/public_html/elf_relocs.html"},(0,i.yg)("inlineCode",{parentName:"a"},"Study Of ELF Loading and Relocs")))),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"readelf -r libdynamic.o\n\nRelocation section '.rel.text' at offset 0x5f8 contains 8 entries:\n Offset     Info    Type            Sym.Value  Sym. Name\n0000001d  00001402 R_386_PC32        00000000   __i686.get_pc_thunk.bx\n00000023  0000150a R_386_GOTPC       00000000   _GLOBAL_OFFSET_TABLE_\n00000029  00000409 R_386_GOTOFF      00000000   .bss\n0000002f  00000409 R_386_GOTOFF      00000000   .bss\n00000035  00000d03 R_386_GOT32       00000004   so_int_global\n00000041  00000d03 R_386_GOT32       00000004   so_int_global\n00000052  00000e04 R_386_PLT32       00000000   so_fpublic_global\n0000005b  00000209 R_386_GOTOFF      00000000   .text\n\nRelocation section '.rel.data.rel.local' at offset 0x638 contains 2 entries:\n Offset     Info    Type            Sym.Value  Sym. Name\n00000000  00000401 R_386_32          00000000   .bss\n00000004  00000201 R_386_32          00000000   .text\n\nRelocation section '.rel.data.rel' at offset 0x648 contains 2 entries:\n Offset     Info    Type            Sym.Value  Sym. Name\n00000000  00000d01 R_386_32          00000004   so_int_global\n00000004  00000e01 R_386_32          00000000   so_fpublic_global\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Offset")," - In relocatable files and linked shared objects it contains the offset from the beginning of the section , where the relocation needs to be applied"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"Info")," - This field is used to derive the index in the symbol table to the affected symbol as well as the algorithm needed for fixing.",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"info >> 8")," - symbol table index"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"info & 0xff")," - algorithm type as defined in the documentation")))),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"readelf")," is nice enough to interpret the symbol table for us and gives us the relocation algorithm in the ",(0,i.yg)("inlineCode",{parentName:"p"},"Type")," field and also the symbol name and value as defined in the symbol table."),(0,i.yg)("p",null,"By looking at the types of relocations we can draw some basic conclusions about the symbol types and also about the files."),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Relocatable Files",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"R_386_32")," - usually used to reference changes to a local symbol"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"R_386_PC32")," - reference a relative distance from here to the symbol"))),(0,i.yg)("li",{parentName:"ul"},"Relocatable Files for Shared object",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"R_386_GOTOFF")," - usually found in the code area, describes the offset from the beginning of ",(0,i.yg)("inlineCode",{parentName:"li"},"GOT")," to a local symbol"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"R_386_GOT32")," - also specific to the code area.\nThese entries persist in the linkage phase"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"R_386_PLT32")," - used when describing calls to global subroutines.\nwhen the linker will read this information it will generate an entry in the ",(0,i.yg)("inlineCode",{parentName:"li"},"GOT")," and ",(0,i.yg)("inlineCode",{parentName:"li"},"PLT")," tables"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"R_386_GOTPC")," - used in function to calculate the start address of the ",(0,i.yg)("inlineCode",{parentName:"li"},"GOT")))),(0,i.yg)("li",{parentName:"ul"},"Executables that use Dynamic Linking",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"R_386_JMP")," - the dynamic linker will deposit the address of the external subroutine during execution"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"R_386_COPY")," - the address of global variable from shared object will be deposited here"))),(0,i.yg)("li",{parentName:"ul"},"Shared Object Files",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"R_386_JMP")," - the dynamic linker will deposit the address of the external subroutine from one of the shared object dependencies during execution"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"R_386_GLOB_DATA")," - used to deposit the address of a global symbol defined in one of the shared object dependencies"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"R_386_RELATIVE")," - at link time all the ",(0,i.yg)("inlineCode",{parentName:"li"},"R_386_GOTOFF")," entries are fixed and these relocation will contain absolute addresses")))),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"IMPORTANT:")," Executable files that are statically linked do not contain relocations."),(0,i.yg)("h2",{id:"challenges"},"Challenges"),(0,i.yg)("p",null,"Challenges can be found in the ",(0,i.yg)("inlineCode",{parentName:"p"},"activities/")," directory."),(0,i.yg)("h3",{id:"01-binary-puzzle"},"01. Binary Puzzle"),(0,i.yg)("p",null,"Now that you know some stuff let's see how fast you can solve a 4 piece puzzle!"),(0,i.yg)("p",null,"You are given 4 relocatable object files.\nExamine their structure carefully and figure out what each of them is meant to be and how you can link them to create a valid binary."),(0,i.yg)("p",null,"All conventions regarding shared object names have been respected."),(0,i.yg)("p",null,"Hints:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Use ",(0,i.yg)("inlineCode",{parentName:"li"},"nm")," to investigate the files, determine what pieces you need to put together and then link them with ",(0,i.yg)("inlineCode",{parentName:"li"},"gcc"),"."),(0,i.yg)("li",{parentName:"ul"},"Check whether the files are compiled for 32 bits or for 64 bits and use the proper ",(0,i.yg)("inlineCode",{parentName:"li"},"gcc")," command.")),(0,i.yg)("p",null,"If you do it correctly you will get an executable that you can run and get the following output:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"Congratulations\nextern var1 10 at 0x565fe020\nextern var2  at 0x565fe030\nextern var3 99 at 0x565fe024\nlocal var4 0 at 0xffd532ac\ng(): not really external\n")),(0,i.yg)("h3",{id:"02-case-of-the-missing-function"},"02. Case of the Missing Function"),(0,i.yg)("p",null,"This task contains a helpless little binary that has lost one of its functions.\nAnalyze the symbol dependencies as well as the code inside the binary.\nFigure out a way to reunite the binary with its missing function."),(0,i.yg)("p",null,"You cannot modify any of the binaries in order to solve this task."),(0,i.yg)("p",null,"Hints:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Run the file, check what it is missing and build the missing component.\nUse ",(0,i.yg)("inlineCode",{parentName:"li"},"nm")," to determine what symbols should be part of the missing component."),(0,i.yg)("li",{parentName:"ul"},"Use ",(0,i.yg)("inlineCode",{parentName:"li"},"LD_LIBRARY_PATH=.")," to run an executable file and load a shared library file from the current folder.")),(0,i.yg)("h3",{id:"03-memory-dump-analysis"},"03. Memory Dump Analysis"),(0,i.yg)("p",null,"Using your newfound voodoo skills you are now able to tackle the following task.\nIn the middle of two programs I added the following lines:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},'{\n    int i;\n    int *a[1];\n    for( i = 0 ; i < 20; i++)\n        printf("%p\\n", a[i]);\n}\n')),(0,i.yg)("p",null,"The results were the following, respectively:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"0x804853b\n0x1\n0x8048530\n(nil)\n(nil)\n0xf7e0ace5\n0x1\n0xffffce64\n0xffffce6c\n0xf7ffcfc0\n0x1c\n(nil)\n0xf7fda4c8\n0x2\n0xffffce60\n0xf7f94e54\n(nil)\n(nil)\n(nil)\n0xd545cf8d\n")),(0,i.yg)("p",null,"And:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"0xbfffe7d0\n0xd696910\n0x80484a9\n0xb7fffbe8\n0x3\n0xb7ffefc0\n0xb7df6a84\n0x1\n0xb7fdc780\n0xb7fe75fc\n0x804c008\n0xb7e59195\n0x804c008\n0xb7fdb000\n0xb7fdc000\n0x1\n0xffffffff\n0x3\n(nil)\n0xf3b9a5b\n")),(0,i.yg)("p",null,"Try to tell:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Which was running on a pure 32 bit system?"),(0,i.yg)("li",{parentName:"ul"},"Which values from the stack traces are from the ",(0,i.yg)("inlineCode",{parentName:"li"},".text")," region?"),(0,i.yg)("li",{parentName:"ul"},"Which do not point to valid memory addresses?"),(0,i.yg)("li",{parentName:"ul"},"Which point to the stack?"),(0,i.yg)("li",{parentName:"ul"},"Which point to the library/",(0,i.yg)("inlineCode",{parentName:"li"},"mmap")," zone?")),(0,i.yg)("h3",{id:"04-compiler-flags"},"04. Compiler Flags"),(0,i.yg)("p",null,"Use proper compiler/linker flags/options to create a running executable for ",(0,i.yg)("inlineCode",{parentName:"p"},"flag1.o")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"caller.c")," and for ",(0,i.yg)("inlineCode",{parentName:"p"},"flag2.o")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"caller.c"),".\nSubmit the flag ",(0,i.yg)("a",{parentName:"p",href:"https://sss-ctf.security.cs.pub.ro/challenges"},"on the platform"),"."),(0,i.yg)("p",null,"It's the same flag, it's just to make sure you are able to find the flag with both formats of the ",(0,i.yg)("inlineCode",{parentName:"p"},"flag*.o")," object files."),(0,i.yg)("h3",{id:"05-print-flag"},"05. Print Flag"),(0,i.yg)("p",null,"Someone has tampered with the executable file ",(0,i.yg)("inlineCode",{parentName:"p"},"get_message"),".\nPlease fix this.\nThere should be a flag message printed in case you solve it correctly."),(0,i.yg)("p",null,"You will need to modify the executable.\nWe recommend you install and use ",(0,i.yg)("a",{parentName:"p",href:"https://packages.ubuntu.com/bionic/bless"},"Bless"),"."),(0,i.yg)("p",null,"What actions does the program do?\nWhat functions does it invoke?\nWhat should it invoke?"),(0,i.yg)("p",null,"Follow the actions from the entry point in the ELF file and see what is the spot where the program doesn't do what it should."),(0,i.yg)("h3",{id:"06-matryoshka"},"06. ",(0,i.yg)("inlineCode",{parentName:"h3"},"matryoshka")),(0,i.yg)("p",null,"Look carefully inside the ",(0,i.yg)("inlineCode",{parentName:"p"},"matryoshka")," executable.\nThe flag is there, but inside something else."),(0,i.yg)("p",null,"Submit the flag ",(0,i.yg)("a",{parentName:"p",href:"https://sss-ctf.security.cs.pub.ro/challenges"},"on the platform"),"."),(0,i.yg)("h3",{id:"bonus-07-fix-me"},"Bonus: 07. Fix Me"),(0,i.yg)("p",null,"You are given a binary that was stored on a USB stick in space where it was hit by gamma rays thus altering its content.\nFortunately, because the executable is so small, the only area damaged is the ELF header.\nFix it and run it!"),(0,i.yg)("p",null,"The structure of an ELF file is briefly presented ",(0,i.yg)("a",{parentName:"p",href:"http://i.imgur.com/m6kL4Lv.png"},"here")),(0,i.yg)("p",null,"A more detailed explanation of the ELF header is presented ",(0,i.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#Program_header"},"here")),(0,i.yg)("p",null,"The entry point address should be ",(0,i.yg)("inlineCode",{parentName:"p"},"0x8048054"),"."),(0,i.yg)("p",null,"Review ",(0,i.yg)("a",{parentName:"p",href:"http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html"},"this tutorial")," on creating a minimal ELF file."),(0,i.yg)("h3",{id:"further-pwning"},"Further Pwning"),(0,i.yg)("p",null,(0,i.yg)("a",{parentName:"p",href:"http://crackmes.cf/users/geyslan/crackme.02.32/"},"This")," is a challenge that will test your knowledge from the first three sessions.\nThe password for the archive is ",(0,i.yg)("inlineCode",{parentName:"p"},"crackmes.de"),"."),(0,i.yg)("h3",{id:"further-reading"},"Further Reading"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"http://www.skyfree.org/linux/references/ELF_Format.pdf"},"ELF-32")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"http://ftp.openwatcom.org/devel/docs/elf-64-gen.pdf"},"ELF-64")," specification"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://elinux.org/Executable_and_Linkable_Format_(ELF)"},"list")," of all ELF specification formats"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://developer.arm.com/documentation/ihi0044/e/"},"ARM")," specification"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://wiki.gentoo.org/wiki/Hardened/Introduction_to_Position_Independent_Code"},"Position Independent Code")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.ibm.com/developerworks/library/l-shobj/"},"Creating shared objects")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.airs.com/blog/archives/189"},(0,i.yg)("inlineCode",{parentName:"a"},"GNU_RELRO"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://guru.multimedia.cx/pt_gnu_stack/"},(0,i.yg)("inlineCode",{parentName:"a"},"GNU_STACK"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://refspecs.linuxfoundation.org/LSB_3.0.0/LSB-Core-generic/LSB-Core-generic/specialsections.html"},"ELF Special Sections")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html"},(0,i.yg)("inlineCode",{parentName:"a"},"A Whirlwind Tutorial on Creating Really Teensy ELF Executables for Linux"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://sourceware.org/binutils/docs/binutils/strip.html"},(0,i.yg)("inlineCode",{parentName:"a"},"strip")," man page")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"http://www.mindfruit.co.uk/2012/06/relocations-relocations.html"},"Some Assembly Required")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"http://netwinder.osuosl.org/users/p/patb/public_html/elf_relocs.html"},(0,i.yg)("inlineCode",{parentName:"a"},"Study Of ELF Loading and Relocs")))))}c.isMDXComponent=!0},2034:(e,n,a)=>{a.d(n,{A:()=>t});const t=a.p+"assets/images/elf-dynamic-linking-e002782e7ca43fdc948775a40e6f4400.png"},3316:(e,n,a)=>{a.d(n,{A:()=>t});const t=a.p+"assets/images/elf-link-exec-8c315d546d70d06703327e7e334dd2c8.png"},3513:(e,n,a)=>{a.d(n,{A:()=>t});const t=a.p+"assets/images/elf-static-linking-61fa4e6e953d672ae8386a7bdc564d28.png"},4052:(e,n,a)=>{a.d(n,{A:()=>t});const t=a.p+"assets/images/elf-space-6c6f85136ae706692845144008116b7c.png"},4603:(e,n,a)=>{a.d(n,{A:()=>t});const t=a.p+"assets/images/elf-sect-inf-dd7154e2e44a3d8a41c94c731bfd0c46.png"},5680:(e,n,a)=>{a.d(n,{xA:()=>d,yg:()=>h});var t=a(6540);function i(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function l(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function r(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?l(Object(a),!0).forEach((function(n){i(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function o(e,n){if(null==e)return{};var a,t,i=function(e,n){if(null==e)return{};var a,t,i={},l=Object.keys(e);for(t=0;t<l.length;t++)a=l[t],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(t=0;t<l.length;t++)a=l[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=t.createContext({}),p=function(e){var n=t.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):r(r({},n),e)),a},d=function(e){var n=p(e.components);return t.createElement(s.Provider,{value:n},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},g=t.forwardRef((function(e,n){var a=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),m=p(a),g=i,h=m["".concat(s,".").concat(g)]||m[g]||c[g]||l;return a?t.createElement(h,r(r({ref:n},d),{},{components:a})):t.createElement(h,r({ref:n},d))}));function h(e,n){var a=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var l=a.length,r=new Array(l);r[0]=g;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[m]="string"==typeof e?e:i,r[1]=o;for(var p=2;p<l;p++)r[p]=a[p];return t.createElement.apply(null,r)}return t.createElement.apply(null,a)}g.displayName="MDXCreateElement"},9299:(e,n,a)=>{a.d(n,{A:()=>t});const t=a.p+"assets/images/elf-merging-6ece3911b4622c9e7975d7bd7bce5d1a.png"}}]);