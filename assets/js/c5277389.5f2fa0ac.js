"use strict";(self.webpackChunkbinary_security=self.webpackChunkbinary_security||[]).push([[4422],{5680:(e,a,n)=>{n.d(a,{xA:()=>u,yg:()=>c});var t=n(6540);function r(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function i(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function l(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?i(Object(n),!0).forEach((function(a){r(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function o(e,a){if(null==e)return{};var n,t,r=function(e,a){if(null==e)return{};var n,t,r={},i=Object.keys(e);for(t=0;t<i.length;t++)n=i[t],a.indexOf(n)>=0||(r[n]=e[n]);return r}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)n=i[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=t.createContext({}),p=function(e){var a=t.useContext(s),n=a;return e&&(n="function"==typeof e?e(a):l(l({},a),e)),n},u=function(e){var a=p(e.components);return t.createElement(s.Provider,{value:a},e.children)},d="mdxType",g={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},f=t.forwardRef((function(e,a){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=p(n),f=r,c=d["".concat(s,".").concat(f)]||d[f]||g[f]||i;return n?t.createElement(c,l(l({ref:a},u),{},{components:n})):t.createElement(c,l({ref:a},u))}));function c(e,a){var n=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=f;var o={};for(var s in a)hasOwnProperty.call(a,s)&&(o[s]=a[s]);o.originalType=e,o[d]="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=n[p];return t.createElement.apply(null,l)}return t.createElement.apply(null,n)}f.displayName="MDXCreateElement"},7456:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>s,contentTitle:()=>l,default:()=>g,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var t=n(8168),r=(n(6540),n(5680));const i={},l="Buffer Exploitation",o={unversionedId:"Exploitation Techniques/Buffer Exploitation/Reading/README",id:"Exploitation Techniques/Buffer Exploitation/Reading/README",title:"Buffer Exploitation",description:"Pwntools",source:"@site/docs/Exploitation Techniques/Buffer Exploitation/Reading/README.md",sourceDirName:"Exploitation Techniques/Buffer Exploitation/Reading",slug:"/Exploitation Techniques/Buffer Exploitation/Reading/",permalink:"/binary-security/Exploitation Techniques/Buffer Exploitation/Reading/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Buffer Exploitation",permalink:"/binary-security/Exploitation Techniques/Buffer Exploitation/"},next:{title:"Shellcodes",permalink:"/binary-security/Exploitation Techniques/Shellcodes/"}},s={},p=[{value:"Pwntools",id:"pwntools",level:2},{value:"Buffers",id:"buffers",level:2},{value:"Stack Buffer Overflow",id:"stack-buffer-overflow",level:2},{value:"Buffer Size and Offset Identification",id:"buffer-size-and-offset-identification",level:3},{value:"Static Analysis",id:"static-analysis",level:4},{value:"Dynamic Analysis",id:"dynamic-analysis",level:4},{value:"Input-Output Functions",id:"input-output-functions",level:2},{value:"Challenges",id:"challenges",level:2},{value:"01. Challenge: Parrot",id:"01-challenge-parrot",level:3},{value:"02. Challenge: Indexing",id:"02-challenge-indexing",level:3},{value:"03. Challenge: <code>smashthestack</code> <code>Level7</code>",id:"03-challenge-smashthestack-level7",level:3},{value:"04. Challenge: Neighbourly",id:"04-challenge-neighbourly",level:3},{value:"05. Challenge: Input Functions",id:"05-challenge-input-functions",level:3},{value:"06. Challenge: Bonus: Birds",id:"06-challenge-bonus-birds",level:3},{value:"Further Reading",id:"further-reading",level:2}],u={toc:p},d="wrapper";function g(e){let{components:a,...i}=e;return(0,r.yg)(d,(0,t.A)({},u,i,{components:a,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"buffer-exploitation"},"Buffer Exploitation"),(0,r.yg)("h2",{id:"pwntools"},"Pwntools"),(0,r.yg)("p",null,"In this lab we will be using the ",(0,r.yg)("inlineCode",{parentName:"p"},"pwntools")," python module to solve the tasks.\nCheck out the ",(0,r.yg)("a",{parentName:"p",href:"../../../Extra/Pwntool%20Intro/Reading"},(0,r.yg)("inlineCode",{parentName:"a"},"Pwntools")," Tutorial section"),"."),(0,r.yg)("h2",{id:"buffers"},"Buffers"),(0,r.yg)("p",null,"A buffer is an area of contiguous data in memory, determined by a starting address, contents and length.\nUnderstanding how buffers are used (or misused) is vital for both offensive and defensive purposes.\nIn C, we can declare a buffer of bytes as a char array, as follows:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"char local_buffer[32];\n")),(0,r.yg)("p",null,"Which results in the following assembly code:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-asm"},"push   rbp\nmov    rbp,rsp\nsub    rsp,0x20\n...\nret\n")),(0,r.yg)("p",null,"Notice that buffer allocation is done by simply subtracting its intended size from the current stack pointer (",(0,r.yg)("inlineCode",{parentName:"p"},"sub rsp, 0x20"),").\nThis simply reserves space on the stack (remember that on x86 the stack grows \u201cupwards\u201d, from higher addresses to lower ones)."),(0,r.yg)("p",null,"A compiler may allocate more space on the stack than explicitly required due to alignment constraints or other hidden values.\nTo exploit a program, the C source code may not be a good enough reference point for stack offsets.\nOnly disassembling the executable will provide relevant information."),(0,r.yg)("p",null,"Buffers can be also be stored in other places in memory, such as the heap, ",(0,r.yg)("inlineCode",{parentName:"p"},".bss"),", ",(0,r.yg)("inlineCode",{parentName:"p"},".data")," or ",(0,r.yg)("inlineCode",{parentName:"p"},".rodata"),"."),(0,r.yg)("p",null,"Analyze and compile the following snippet (also present in the lab files, go to ",(0,r.yg)("inlineCode",{parentName:"p"},"00-tutorial")," and run ",(0,r.yg)("inlineCode",{parentName:"p"},"make buffers"),"):"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n#include <stdlib.h>\n\nchar g_buf_init_zero[32] = {0};\n/* g_buf_init_vals[5..31] will be 0 */\nchar g_buf_init_vals[32] = {1, 2, 3, 4, 5};\nconst char g_buf_const[32] = "Hello, world\\n";\n\nint main(void)\n{\n    char l_buf[32];\n    static char s_l_buf[32];\n    char *heap_buf = malloc(32);\n\n    free(heap_buf);\n\n    return 0;\n}\n')),(0,r.yg)("p",null,"Check the common binary sections and symbols.\nUse the usual commands (",(0,r.yg)("inlineCode",{parentName:"p"},"readelf -S"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"nm"),").\nObserve in which section each variable is located and the section flags."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-console"},"$ readelf -S buffers\n...\n  [16] .rodata           PROGBITS         <b>0000000000402000</b>  00002000\n       0000000000000040  0000000000000000   <b>A</b>       0     0     32\n...\n  [24] .data             PROGBITS         <b>0000000000404040</b>  00003040\n       0000000000000040  0000000000000000  <b>WA</b>       0     0     32\n  [25] .bss              NOBITS           <b>0000000000404080</b>  00003080\n       0000000000000060  0000000000000000  <b>WA</b>       0     0     32\n...\nKey to Flags:\n  W (write), A (alloc), X (execute)\n\n$ nm buffers\n...\n<b>0000000000402020 R</b> g_buf_const\n<b>0000000000404060 D</b> g_buf_init_vals\n<b>00000000004040a0 B</b> g_buf_init_zero\n\nKey to Flags:\n  R (symbol is read-only)\n  D (symbol in initialized data section)\n  B (symbol in BSS data section)\n\n  A lowercase flag means variable is not visible local (not visible outside the object)\n")),(0,r.yg)("p",null,"You can also inspect these programmatically using pwntools and the ELF class:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},"from pwn import *\n\nelf = ELF('buffers')\n\nbss    = elf.get_section_by_name('.bss')\ndata   = elf.get_section_by_name('.data')\nrodata = elf.get_section_by_name('.rodata')\n\nbss_addr    = bss['sh_addr']\ndata_addr   = data['sh_addr']\nrodata_addr = rodata['sh_addr']\n\nbss_size = bss['sh_size']\ndata_size = data['sh_size']\nrodata_size = rodata['sh_size']\n\n# A (Alloc) = 1 << 1 = 2\n# W (Write) = 1 << 0 = 1\nbss_flags    = bss['sh_flags']\ndata_flags   = data['sh_flags']\nrodata_flags = rodata['sh_flags']\n\nprint(\"Section info:\")\nprint(\".bss:    0x{:08x}-0x{:08x}, {}\".format(bss_addr, bss_addr+bss_size, bss_flags))\nprint(\".data:   0x{:08x}-0x{:08x}, {}\".format(data_addr, data_addr+data_size, data_flags))\nprint(\".rodata: 0x{:08x}-0x{:08x}, {}\".format(rodata_addr, rodata_addr+rodata_size, rodata_flags))\n\nprint()\n\nprint(\"Variable info:\")\nprint(\"g_buf_init_zero: 0x{:08x}\".format(elf.symbols.g_buf_init_zero))\nprint(\"g_buf_init_vals: 0x{:08x}\".format(elf.symbols.g_buf_init_vals))\nprint(\"g_buf_const:     0x{:08x}\".format(elf.symbols.g_buf_const))\n")),(0,r.yg)("p",null,"Another handy utility is the ",(0,r.yg)("inlineCode",{parentName:"p"},"vmmap")," command in ",(0,r.yg)("inlineCode",{parentName:"p"},"pwndbg")," which shows all memory maps of the process at runtime:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-gdb"},"pwndbg> b main\npwngdb> run\npwndbg> vmmap\nLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA\n          0x400000           0x401000 r--p     1000 0      /home/user/buffers\n          0x401000           0x402000 r-xp     1000 1000   /home/user/buffers\n          0x402000           0x403000 r--p     1000 2000   /home/user/buffers\n          0x403000           0x404000 r--p     1000 2000   /home/user/buffers\n          0x404000           0x405000 rw-p     1000 3000   /home/user/buffers\n    0x7ffff7dc9000     0x7ffff7dcb000 rw-p     2000 0\n...\n    0x7ffffffdd000     0x7ffffffff000 rw-p    22000 0      [stack]\n0xffffffffff600000 0xffffffffff601000 --xp     1000 0      [vsyscall]\n")),(0,r.yg)("p",null,"Non-static local variables and dynamically allocated buffers cannot be seen in the executable (they have meaning only at runtime, because they are allocated on the stack or heap in a function scope).\nThe symbol names aren't found anywhere in the binary, except if debug symbols are enabled (",(0,r.yg)("inlineCode",{parentName:"p"},"-g")," flag)."),(0,r.yg)("h2",{id:"stack-buffer-overflow"},"Stack Buffer Overflow"),(0,r.yg)("p",null,(0,r.yg)("img",{alt:"Stack Overflow",src:n(2141).A,width:"791",height:"416"})),(0,r.yg)("p",null,"Note that this is the stack for a 64bit system and the first couple of function arguments are stored in registers (",(0,r.yg)("inlineCode",{parentName:"p"},"rdi"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"rsi"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"rdx"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"rcx"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"r8"),", and ",(0,r.yg)("inlineCode",{parentName:"p"},"r9"),") and that's why the images has ",(0,r.yg)("inlineCode",{parentName:"p"},"arg_6")," as the first argument."),(0,r.yg)("p",null,"We should know by now that the stack serves multiple purposes:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Passing function arguments from the caller to the callee"),(0,r.yg)("li",{parentName:"ul"},"Storing local variables for functions"),(0,r.yg)("li",{parentName:"ul"},"Temporarily saving register values before a call"),(0,r.yg)("li",{parentName:"ul"},"Saving the return address and old frame pointer")),(0,r.yg)("p",null,"Even though, in an abstract sense, different buffers are separate from one another, ultimately they are just some regions of memory which do not have any intrinsic identification or associated size.\nTo avoid this, most high level languages use size metadata and bound checks to detect out of bounds accesses to the memory."),(0,r.yg)("p",null,"But in our case, bounds are unchecked, therefore it is up to the programmer to code carefully.\nThis includes checking for any overflows and using ",(0,r.yg)("strong",{parentName:"p"},"safe functions"),".\nUnfortunately, many functions in the standard C library, particularly those which work with strings and read user input, are unsafe - nowadays, the compiler will issue warnings when encountering them."),(0,r.yg)("h3",{id:"buffer-size-and-offset-identification"},"Buffer Size and Offset Identification"),(0,r.yg)("p",null,"When trying to overflow a buffer on the stack we need to know the size and where the buffer is in memory relative to the saved return address (or some other control flow altering value/pointer)."),(0,r.yg)("h4",{id:"static-analysis"},"Static Analysis"),(0,r.yg)("p",null,"One way, for simple programs, you can do ",(0,r.yg)("strong",{parentName:"p"},"static analysis")," and check some key points in the disassembled code."),(0,r.yg)("p",null,"For example, this simple program (",(0,r.yg)("inlineCode",{parentName:"p"},"00-tutorial/simple_read"),", run ",(0,r.yg)("inlineCode",{parentName:"p"},"make simple_read")," to compile):"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"#include <stdio.h>\n\nint main(void) {\n    char buf[128];\n    fread(buf, 1, 256, stdin);\n    return 0;\n}\n")),(0,r.yg)("p",null,"generates the following assembly code:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-asm"},"push   rbp\nmov    rbp,rsp\nsub    rsp,0x90\nmov    rax,QWORD PTR fs:0x28\n\nmov    QWORD PTR [rbp-0x8],rax\nxor    eax,eax\n# important bit\nmov    rdx,QWORD PTR [rip+0x2ed6]        # 4040 <stdin@@GLIBC_2.2.5>\nlea    rax,[rbp-0x90]                    # <- stack buffer starts at rbp-0x90\nmov    rcx,rdx                           # <- 4th argument fo fread, stdin\nmov    edx,0x100                         # <- 3rd argument of fread, number of elements read\nmov    esi,0x1                           # <- 2nd argument of fread, size of element\nmov    rdi,rax                           # <- 1st argument of fread (buffer address saved in RAX)\ncall   1030 <fread@plt>\n\npush   rbp\nmov    rbp,rsp\nadd    rsp,0xffffffffffffff80\n# --- important bit ---\nmov    rdx,QWORD PTR [rip+0x2efb]        # 404030 <stdin@@GLIBC_2.2.5>\nlea    rax,[rbp-0x80]  # <- stack buffer starts at rbp-0x80\nmov    rcx,rdx         # <- 4th argument fo fread, stdin\nmov    edx,0x100       # <- 3rd argument of fread, number of elements read\nmov    esi,0x1         # <- 2nd argument of fread, size of element\nmov    rdi,rax         # <- 1st argument of fread (buffer address saved in RAX)\ncall   401030 <fread@plt>\n# ---------------------\nmov    eax,0x0\nleave\nret\n")),(0,r.yg)("p",null,"Looking at the ",(0,r.yg)("inlineCode",{parentName:"p"},"fread")," arguments we can see the buffer start relative to ",(0,r.yg)("inlineCode",{parentName:"p"},"RBP")," and the number of bytes read.\n",(0,r.yg)("inlineCode",{parentName:"p"},"RBP-0x80+0x100*0x1 = RBP+0x80"),", so the ",(0,r.yg)("inlineCode",{parentName:"p"},"fread")," function can read 128 bytes after ",(0,r.yg)("inlineCode",{parentName:"p"},"RBP")," -> return address stored at 136 bytes after ",(0,r.yg)("inlineCode",{parentName:"p"},"RBP"),"."),(0,r.yg)("p",null,(0,r.yg)("img",{alt:"Stack Buffer",src:n(2256).A,width:"791",height:"416"})),(0,r.yg)("h4",{id:"dynamic-analysis"},"Dynamic Analysis"),(0,r.yg)("p",null,"You can determine offsets at runtime in a more automated way with pwndbg using an ",(0,r.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/De_Bruijn_sequence"},"De Bruijn sequences")," which produces strings where every substring of length N appears only once in the sequence;\nin our case it helps us identify the offset of an exploitable memory value relative to the buffer."),(0,r.yg)("p",null,"For a simple buffer overflow the workflow is:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"generate an long enough sequence to guarantee a buffer overflow"),(0,r.yg)("li",{parentName:"ol"},"feed the generated sequence to the input function in the program"),(0,r.yg)("li",{parentName:"ol"},"the program will produce a segmentation fault when reaching the invalid return address on the stack"),(0,r.yg)("li",{parentName:"ol"},"search the offset of the faulty address in the generated pattern to get an offset")),(0,r.yg)("p",null,"In pwndbg this works as such:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-console"},"pwndbg> cyclic -n 8 256\naaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaaaaaanaaaaaaaoaaaaaaapaaaaaaaqaaaaaaaraaaaaaasaaaaaaataaaaaaauaaaaaaavaaaaaaawaaaaaaaxaaaaaaayaaaaaaazaaaaaabbaaaaaabcaaaaaabdaaaaaabeaaaaaabfaaaaaabgaaaaaab\npwndbg> run\n...\npwndbg>\n<reading input, paste the generated pattern>\n...\npwndbg> continue\n...\nProgram received signal SIGSEGV, Segmentation fault\n...\n   0x401141 <main+27>    mov    esi, 1\n   0x401146 <main+32>    mov    rdi, rax\n   0x401149 <main+35>    call   fread@plt <fread@plt\n\n   0x40114e <main+40>    mov    eax, 0\n   0x401153 <main+45>    leave\n \u25ba 0x401154 <main+46>    ret    <0x6161616161616172>\n...\npwndbg> cyclic -n 8 -c 64 -l 0x6161616161616172\n136\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Note"),":\nWe get the same 136 offset computed manually with the static analysis method."),(0,r.yg)("h2",{id:"input-output-functions"},"Input-Output Functions"),(0,r.yg)("p",null,"Most programs aren't a straight forward single input buffer overflow so we need to deal with things like:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"automating program input-output - by programmatically sending and receiving data"),(0,r.yg)("li",{parentName:"ul"},"parsing program output - to use potential leaked information"),(0,r.yg)("li",{parentName:"ul"},"understand the mechanics of the IO methods used - what kind of data they accept and possible constraints")),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"pwntools")," offers a large area of ",(0,r.yg)("a",{parentName:"p",href:"https://docs.pwntools.com/en/stable/tubes.html"},"IO functions")," to communicate with a program (either local or remote).\nThe basic and usual ones are:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"send(data)")," - sends the ",(0,r.yg)("inlineCode",{parentName:"li"},"data")," byte string to the process"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"sendline(data)")," - shorthand for ",(0,r.yg)("inlineCode",{parentName:"li"},'send(data + b"\\n")')),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"recv(num)")," - receives ",(0,r.yg)("inlineCode",{parentName:"li"},"num")," bytes from the process"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"recvline()")," - receives a whole line from the process (until '\\n')"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"recvuntil(str)")," - receives data until ",(0,r.yg)("inlineCode",{parentName:"li"},"str")," is found (will not contain ",(0,r.yg)("inlineCode",{parentName:"li"},"str"),")"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"recvall()")," - receives the full program output (until ",(0,r.yg)("inlineCode",{parentName:"li"},"EOF"),")")),(0,r.yg)("p",null,"Check the documentation for more complex IO functions that might come in handy (like ",(0,r.yg)("inlineCode",{parentName:"p"},"recvregex"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"sendafter"),")."),(0,r.yg)("p",null,"It is also important to understand the functionality of the different IO functions the program itself uses.\nFor C programs, in our case, you can always\nfind useful information in the man pages of specific functions:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)"),":\nReads ",(0,r.yg)("inlineCode",{parentName:"li"},"nmemb")," items of data, each ",(0,r.yg)("inlineCode",{parentName:"li"},"size")," bytes long, simple and straightforward."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"char *gets(char *s)"),":\nReads until either a terminating newline or ",(0,r.yg)("inlineCode",{parentName:"li"},"EOF"),", which it replaces with a null byte ('\\0').\nThe problem here is that you won't be able to have a newline in the middle of your payload;\nnote that it doesn't have a size argument to it will read indefinitely as long as it doesn't reach a newline or ",(0,r.yg)("inlineCode",{parentName:"li"},"EOF"),"."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"char *fgets(char *s, int size, FILE *stream)"),":\nReads in ",(0,r.yg)("strong",{parentName:"li"},"at most")," one less than ",(0,r.yg)("inlineCode",{parentName:"li"},"size")," characters from stream and stores them into the buffer pointed to by s.\nReading stops after an ",(0,r.yg)("inlineCode",{parentName:"li"},"EOF")," or a ",(0,r.yg)("strong",{parentName:"li"},"newline"),".\nIf a ",(0,r.yg)("strong",{parentName:"li"},"newline")," is read, it is stored into the buffer.\nA terminating null byte ('\\0') is stored after the last character in the buffer.\nThis one adds the size limit argument, but also note that it ",(0,r.yg)("strong",{parentName:"li"},"stores")," the newline in the string and ",(0,r.yg)("strong",{parentName:"li"},"adds")," the null byte after (in contrast to ",(0,r.yg)("inlineCode",{parentName:"li"},"gets"),")"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"int scanf(const char *format, ...)"),":\nAs opposed the other functions ",(0,r.yg)("inlineCode",{parentName:"li"},"scanf")," reads ",(0,r.yg)("strong",{parentName:"li"},"text")," based on the format string and parses it\nDon't do the common mistake of ",(0,r.yg)("strong",{parentName:"li"},"sending binary data to ",(0,r.yg)("inlineCode",{parentName:"strong"},"scanf")),", for example ",(0,r.yg)("inlineCode",{parentName:"li"},'"%d"')," expects a string representation of a number like ",(0,r.yg)("inlineCode",{parentName:"li"},'"16"'),", not the binary data like ",(0,r.yg)("inlineCode",{parentName:"li"},'"\\x00\\x00\\x00\\x10"'))),(0,r.yg)("p",null,"Every time you encounter a new input function check the documentation to find it's limitations"),(0,r.yg)("h2",{id:"challenges"},"Challenges"),(0,r.yg)("h3",{id:"01-challenge-parrot"},"01. Challenge: Parrot"),(0,r.yg)("p",null,"Some programs feature a stack smashing protection in the form of stack canaries, that is, values kept on the stack which are checked before returning from a function.\nIf the value has changed, then the \u201ccanary\u201d can conclude that stack data has been corrupted throughout the execution of the current function."),(0,r.yg)("p",null,"We have implemented our very own ",(0,r.yg)("inlineCode",{parentName:"p"},"parrot"),".\nCan you avoid it somehow?"),(0,r.yg)("h3",{id:"02-challenge-indexing"},"02. Challenge: Indexing"),(0,r.yg)("p",null,"More complex programs require some form of protocol or user interaction.\nThis is where ",(0,r.yg)("inlineCode",{parentName:"p"},"pwntools")," shines.\nHere's an interactive script to get you started:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},"    #!/usr/bin/env python\n    from pwn import *\n\n    p = process('./indexing')\n\n    p.recvuntil('Index: ')\n    p.sendline() # TODO (must be string)\n\n    # Give value\n    p.recvuntil('Value: ')\n    p.sendline() # TODO (must be string)\n    p.interactive()\n")),(0,r.yg)("p",null,"Go through GDB when aiming to solve this challenge.\nAs all input values are strings, you can input them at the keyboard and follow their effect in GDB."),(0,r.yg)("h3",{id:"03-challenge-smashthestack-level7"},"03. Challenge: ",(0,r.yg)("inlineCode",{parentName:"h3"},"smashthestack")," ",(0,r.yg)("inlineCode",{parentName:"h3"},"Level7")),(0,r.yg)("p",null,"Now you can tackle a real challenge.\nSee if you can figure out how you can get a shell from this one."),(0,r.yg)("p",null,"Hints:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"There's an integer overflow + buffer overflow in the program."),(0,r.yg)("li",{parentName:"ul"},"How does integer multiplication work at a low level?\nCan you get a positive number by multiplying a negative number by 4?"),(0,r.yg)("li",{parentName:"ul"},"To pass command-line arguments in gdb use ",(0,r.yg)("inlineCode",{parentName:"li"},"run arg1 arg2 ...")," or ",(0,r.yg)("inlineCode",{parentName:"li"},"set args arg1 arg2 ...")," before a ",(0,r.yg)("inlineCode",{parentName:"li"},"run")," command"),(0,r.yg)("li",{parentName:"ul"},"In ",(0,r.yg)("inlineCode",{parentName:"li"},"pwntools")," you can pass a list to ",(0,r.yg)("inlineCode",{parentName:"li"},"process")," (",(0,r.yg)("inlineCode",{parentName:"li"},"process(['./level07', arg1, arg2]"),")")),(0,r.yg)("h3",{id:"04-challenge-neighbourly"},"04. Challenge: Neighbourly"),(0,r.yg)("p",null,"Let's overwrite a structure's function pointer using a buffer overflow in its vicinity.\nThe principle is the same."),(0,r.yg)("h3",{id:"05-challenge-input-functions"},"05. Challenge: Input Functions"),(0,r.yg)("p",null,'On the same idea as the "Indexing" challenge but much harder.\nCarefully check what input functions are used and parse the input accordingly.'),(0,r.yg)("h3",{id:"06-challenge-bonus-birds"},"06. Challenge: Bonus: Birds"),(0,r.yg)("p",null,"Time for a more complex challenge.\nBe patient and don't speed through it."),(0,r.yg)("h2",{id:"further-reading"},"Further Reading"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/De_Bruijn_sequence"},"De Bruijn sequences")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"https://docs.pwntools.com/en/latest/elf/elf.html"},(0,r.yg)("inlineCode",{parentName:"a"},"PwnTools")," ",(0,r.yg)("inlineCode",{parentName:"a"},"ELF")," Module")," (which internally uses ",(0,r.yg)("a",{parentName:"li",href:"https://github.com/eliben/pyelftools"},(0,r.yg)("inlineCode",{parentName:"a"},"PyElftoools"))," and may expose such objects)"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"https://docs.pwntools.com/en/stable/tubes.html"},(0,r.yg)("inlineCode",{parentName:"a"},"PwnTools")," ",(0,r.yg)("inlineCode",{parentName:"a"},"IO")))))}g.isMDXComponent=!0},2256:(e,a,n)=>{n.d(a,{A:()=>t});const t=n.p+"assets/images/stack_buffer-0b96391d4eed9498228a407c79df21e7.png"},2141:(e,a,n)=>{n.d(a,{A:()=>t});const t=n.p+"assets/images/stack_x86_64-c927f7ec64beb301fa5e4f41e8ef048b.png"}}]);