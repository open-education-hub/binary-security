"use strict";(self.webpackChunkbinary_security=self.webpackChunkbinary_security||[]).push([[8734],{3470:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>c,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var a=t(8168),i=(t(6540),t(5680));const l={},r="Return-Oriented Programming Advanced",o={unversionedId:"Exploitation Techniques/Return-Oriented Programming Advanced/Reading/README",id:"Exploitation Techniques/Return-Oriented Programming Advanced/Reading/README",title:"Return-Oriented Programming Advanced",description:"In this session we are going to dive deeper into Return-Oriented Programming and setbacks that appear in modern exploitation.",source:"@site/docs/Exploitation Techniques/Return-Oriented Programming Advanced/Reading/README.md",sourceDirName:"Exploitation Techniques/Return-Oriented Programming Advanced/Reading",slug:"/Exploitation Techniques/Return-Oriented Programming Advanced/Reading/",permalink:"/binary-security/Exploitation Techniques/Return-Oriented Programming Advanced/Reading/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Return-Oriented Programming Advanced",permalink:"/binary-security/Exploitation Techniques/Return-Oriented Programming Advanced/"},next:{title:"Mitigation and Defensive Strategies",permalink:"/binary-security/Mitigation and Defensive Strategies/"}},s={},p=[{value:"Calling Conventions in the ROP Context",id:"calling-conventions-in-the-rop-context",level:2},{value:"ROP gadgets on x86_64",id:"rop-gadgets-on-x86_64",level:2},{value:"Libc leaks",id:"libc-leaks",level:2},{value:"Challenges",id:"challenges",level:2},{value:"01. Challenge - Using ROP to Leak and Call system",id:"01-challenge---using-rop-to-leak-and-call-system",level:3},{value:"02. Challenge - Handling Low Stack Space",id:"02-challenge---handling-low-stack-space",level:3},{value:"03. Challenge - Stack Pivoting",id:"03-challenge---stack-pivoting",level:3},{value:"04. Challenge - mprotect",id:"04-challenge---mprotect",level:3},{value:"Further Reading",id:"further-reading",level:2}],g={toc:p},d="wrapper";function c({components:e,...n}){return(0,i.yg)(d,(0,a.A)({},g,n,{components:e,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"return-oriented-programming-advanced"},"Return-Oriented Programming Advanced"),(0,i.yg)("p",null,"In this session we are going to dive deeper into Return-Oriented Programming and setbacks that appear in modern exploitation.\nTopics covered:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"ROP for syscalls and 64 bits"),(0,i.yg)("li",{parentName:"ul"},"Dealing with ASLR in ROP"),(0,i.yg)("li",{parentName:"ul"},"Dealing with low space in the overflown buffer"),(0,i.yg)("li",{parentName:"ul"},"Combining ROP and shellcodes")),(0,i.yg)("p",null,"As the basis of the lab we will use a program based on a classical CTF challenge called ",(0,i.yg)("inlineCode",{parentName:"p"},"ropasaurusrex")," and gradually make exploitation harder."),(0,i.yg)("h2",{id:"calling-conventions-in-the-rop-context"},"Calling Conventions in the ROP Context"),(0,i.yg)("p",null,"As you know, the calling convention for 32 bits uses the stack.\nThis means that setting up parameters is as easy as just writing them in the payload."),(0,i.yg)("p",null,"We can see how a function call is generated in this ",(0,i.yg)("a",{parentName:"p",href:"https://gcc.godbolt.org/z/MPG5MhEnE"},"Compiler Explorer example"),"."),(0,i.yg)("p",null," Syscalls are special, the arguments are passed using the registers and ",(0,i.yg)("inlineCode",{parentName:"p"},"int 0x80")," or the equivalent ",(0,i.yg)("inlineCode",{parentName:"p"},"call DWORD PTR gs:0x10")," is used such that more work is needed: ",(0,i.yg)("inlineCode",{parentName:"p"},"pop ?; ret")," gadgets are needed to load the registers with the desired values."),(0,i.yg)("p",null,"In the assembly below you see a disassembly of the calling of a system call ",(0,i.yg)("inlineCode",{parentName:"p"},"read(0, 0x8048000, 0x100)"),", with the system call in the ",(0,i.yg)("inlineCode",{parentName:"p"},"eax")," register and the system call arguments in the other registers:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},"mov eax, 0x3\nmov ebx, 0\nmov ecx, 0x08048000\nmov edx, 0x100\nint 0x80\n")),(0,i.yg)("p",null,"The calling convention for 64 bit processors (",(0,i.yg)("inlineCode",{parentName:"p"},"x86_64"),") is different and mainly uses registers instead of the stack, see this ",(0,i.yg)("a",{parentName:"p",href:"https://gcc.godbolt.org/z/1Ys6M3Pdc"},"Compiler Explorer example"),"."),(0,i.yg)("p",null,"Syscalls on 64 bits are conceptually the same as on 32 bits, but it uses different registers, different syscall codes and the ",(0,i.yg)("inlineCode",{parentName:"p"},"syscall")," mnemonic is used for making a system call:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},"mov rax, 0\nmov rdi, 0\nmov rsi, 0x08048000\nmov rdx, 0x100\nsyscall\n")),(0,i.yg)("h2",{id:"rop-gadgets-on-x86_64"},"ROP gadgets on x86_64"),(0,i.yg)("p",null,"On ",(0,i.yg)("inlineCode",{parentName:"p"},"x86_64")," the ROP payloads will have to be built differently than on ",(0,i.yg)("inlineCode",{parentName:"p"},"x86")," because of the different calling convention.\nHaving the function arguments stored in registers means that you don't need to do stack cleanup anymore, but you will need gadgets with ",(0,i.yg)("strong",{parentName:"p"},"specific registers")," to pop the arguments into."),(0,i.yg)("p",null,"For example to do the ",(0,i.yg)("inlineCode",{parentName:"p"},"read(0, buf, size)")," libc call to do this call your payload will need to look like:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-text"},"pop rdi; ret\n0\npop rsi, ret\nbuf_addr\npop rdx; ret\nsize\ncall read@plt\n")),(0,i.yg)("h2",{id:"libc-leaks"},"Libc leaks"),(0,i.yg)("p",null,"You might have already encountered in other tasks the need to leak values or addresses.\nMost of the time, if you want to get a shell, you won't have a convenient ",(0,i.yg)("inlineCode",{parentName:"p"},"system@plt")," symbol present in your binary, and ",(0,i.yg)("inlineCode",{parentName:"p"},"ASLR")," will most often be activated;\nso you will have to compute it relative to another libc symbol at runtime."),(0,i.yg)("p",null,"For this we will need to know what libc library the program is loading.\nFor a local executable we can just run ",(0,i.yg)("inlineCode",{parentName:"p"},"ldd"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ ldd rop\n    linux-vdso.so.1 (0x00007ffd0834b000)\n    libc.so.6 => /usr/lib/libc.so.6 (0x00007fec18eb6000)\n    /lib64/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x00007fec190aa000)\n")),(0,i.yg)("p",null,"For remote tasks you can might get an attached ",(0,i.yg)("inlineCode",{parentName:"p"},"libc.so"),", or you can use the ",(0,i.yg)("a",{parentName:"p",href:"https://libc.blukat.me/"},"Libc database")," to find the correct libc based on some leaked offsets."),(0,i.yg)("p",null,"How to compute and use the ",(0,i.yg)("inlineCode",{parentName:"p"},"system")," function address using pwntools:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"from pwn import *\n\nlibc = ELF(\"/usr/lib/libc.so.6\") # from `ldd rop`\np = process('rop')\n\n...\n# read the leaked address of the write@got function from the program\nwrite_leak = u64(p.recv(8))\n# compute the starting address of the libc library\n# setting libc.address to this value will offset all future symbol accesses\nlibc.address = write_leak - libc.symbols['write']\n\n# use the address of system in the payload\npayload = ... + p64(libc.symbols['system'])\n")),(0,i.yg)("h2",{id:"challenges"},"Challenges"),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Note"),": All tasks from this session are 64 bit binaries, so take that into consideration when you build the ROP chains."),(0,i.yg)("h3",{id:"01-challenge---using-rop-to-leak-and-call-system"},"01. Challenge - Using ROP to Leak and Call system"),(0,i.yg)("p",null,"Use the ",(0,i.yg)("inlineCode",{parentName:"p"},"01-leak-call-system/src")," executable file in order to spawn a shell."),(0,i.yg)("p",null,"You can now call the functions in the binary but ",(0,i.yg)("inlineCode",{parentName:"p"},"system")," or any other appropriate function is missing and ASLR is enabled.\nHow do you get past this?\nYou need an information leak!\nTo leak information we want to print it to standard output and process it.\nWe use calls to ",(0,i.yg)("inlineCode",{parentName:"p"},"printf"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"puts")," or ",(0,i.yg)("inlineCode",{parentName:"p"},"write")," for this.\nIn our case we can use the ",(0,i.yg)("inlineCode",{parentName:"p"},"write")," function call."),(0,i.yg)("p",null,"If you have a string representation of a number you can unpack it using the ",(0,i.yg)("inlineCode",{parentName:"p"},"unpack"),"/",(0,i.yg)("inlineCode",{parentName:"p"},"u64")," function in pwntools.\nIt is the reverse of the ",(0,i.yg)("inlineCode",{parentName:"p"},"pack"),"/",(0,i.yg)("inlineCode",{parentName:"p"},"p64")," function."),(0,i.yg)("p",null,"First, trigger the information leak by calling the ",(0,i.yg)("inlineCode",{parentName:"p"},"write")," function and leaking an address from libc."),(0,i.yg)("p",null,"You can use the GOT table storing libc addresses."),(0,i.yg)("p",null,"You need to read the output from the above ",(0,i.yg)("inlineCode",{parentName:"p"},"write")," call.\nUse ",(0,i.yg)("inlineCode",{parentName:"p"},"p.recv(8)")," in the Python script to read the 8 bytes output of the ",(0,i.yg)("inlineCode",{parentName:"p"},"write")," call in the ",(0,i.yg)("inlineCode",{parentName:"p"},"ROP")," chain."),(0,i.yg)("p",null,"Remember that you need gadgets to pop values into ",(0,i.yg)("inlineCode",{parentName:"p"},"rdi"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"rsi"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"rdx")," for the ",(0,i.yg)("inlineCode",{parentName:"p"},"write")," call."),(0,i.yg)("p",null,"Find the address of the ",(0,i.yg)("inlineCode",{parentName:"p"},"system")," call."),(0,i.yg)("p",null,"Remember the libc leaks section above"),(0,i.yg)("p",null,"Call `system()."),(0,i.yg)("p",null,"You can't write the ",(0,i.yg)("inlineCode",{parentName:"p"},"system")," address in the ROP chain as it is different each time and the ROP chain is statically defined.\nYou can use the GOT table again.\nWrite an entry in the GOT table with the newly found address and call the function for that entry.\nIt will evolve into a call to ",(0,i.yg)("inlineCode",{parentName:"p"},"system"),"."),(0,i.yg)("p",null,"To write an entry in the GOT table use the ",(0,i.yg)("inlineCode",{parentName:"p"},"read")," call in the ROP chain.\nYou will feed to ",(0,i.yg)("inlineCode",{parentName:"p"},"read")," the computed address below."),(0,i.yg)("p",null,"For the actual parameter use the ",(0,i.yg)("inlineCode",{parentName:"p"},'"sh"')," string already present in the vulnerable binary.\nUse ",(0,i.yg)("inlineCode",{parentName:"p"},"searchmem")," in GDB to find the ",(0,i.yg)("inlineCode",{parentName:"p"},'"sh"')," string in the executable."),(0,i.yg)("h3",{id:"02-challenge---handling-low-stack-space"},"02. Challenge - Handling Low Stack Space"),(0,i.yg)("p",null,"The previous binary had the luxury of plenty of stack space to be overflown.\nIt is often the case that we don't have enough space for a long ROP chain.\nLet's handle that."),(0,i.yg)("p",null,"For the current task, switch to the ",(0,i.yg)("inlineCode",{parentName:"p"},"02-low-stack-space/src")," sub-folder.\nThe extra constraint here is that huge ROP chains are no longer an option."),(0,i.yg)("p",null,"Find out how much space you have in the overflow and assess the situation."),(0,i.yg)("p",null,"Use ",(0,i.yg)("inlineCode",{parentName:"p"},"gdb")," and the cyclic pattern to get the information required."),(0,i.yg)("p",null,"Now follow the steps below."),(0,i.yg)("p",null,"First trigger the info leak as before."),(0,i.yg)("p",null,"Use ",(0,i.yg)("inlineCode",{parentName:"p"},"write")," and leak the address of a GOT value.\nUse this to compute the address of the ",(0,i.yg)("inlineCode",{parentName:"p"},"system")," call."),(0,i.yg)("p",null,"You can only construct a partial ROP chain.\nA longer one won't fit.\nSo after calling ",(0,i.yg)("inlineCode",{parentName:"p"},"write"),", call ",(0,i.yg)("inlineCode",{parentName:"p"},"main")," again."),(0,i.yg)("p",null,"Note that using ",(0,i.yg)("inlineCode",{parentName:"p"},"sendline")," means sending out a newline character (",(0,i.yg)("inlineCode",{parentName:"p"},"'\\n'"),") at the end of the message.\nIf you want to strictly send out a message without a newline, use ",(0,i.yg)("inlineCode",{parentName:"p"},"send"),"."),(0,i.yg)("p",null,"Find the address of ",(0,i.yg)("inlineCode",{parentName:"p"},"main")," by looking at the argument for the ",(0,i.yg)("inlineCode",{parentName:"p"},"__libc_start_main")," function.\nCheck the disassembling of the program and see what is the parameter passed to the ",(0,i.yg)("inlineCode",{parentName:"p"},"__libc_start_main call"),"."),(0,i.yg)("p",null,"After calling ",(0,i.yg)("inlineCode",{parentName:"p"},"main")," again you will get back to the initial situation where you can exploit the buffer overflow."),(0,i.yg)("p",null,"Insert ",(0,i.yg)("inlineCode",{parentName:"p"},'"sh"')," string."),(0,i.yg)("p",null,"This time you don't have the ",(0,i.yg)("inlineCode",{parentName:"p"},'"sh"')," string in the binary, but you can find it in ",(0,i.yg)("strong",{parentName:"p"},"the libc binary itself")," so you can compute it the same way you compute the ",(0,i.yg)("inlineCode",{parentName:"p"},"system")," address.\nIn pwntools:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},'\nsh = next(libc.search(b"/bin/sh\\x00"))\n')),(0,i.yg)("p",null,"Call ",(0,i.yg)("inlineCode",{parentName:"p"},"system"),"."),(0,i.yg)("h3",{id:"03-challenge---stack-pivoting"},"03. Challenge - Stack Pivoting"),(0,i.yg)("p",null,"Let's assume that ",(0,i.yg)("inlineCode",{parentName:"p"},"main")," function had additional constraints that made it impossible to repeat the overflow.\nHow can we still solve it?\nThe method is called stack pivoting.\nIn short, this means making the stack pointer refer another (writable) memory area that has enough space, a memory area that we will populate with the actual ROP chain."),(0,i.yg)("p",null,"Read more about stack pivoting ",(0,i.yg)("a",{parentName:"p",href:"http://neilscomputerblog.blogspot.ro/2012/06/stack-pivoting.html"},"here"),"."),(0,i.yg)("p",null,"Tour goal is to fill the actual ROP chain to a large enough memory area.\nWe need a two stage exploit:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"In the first stage, prepare the memory area where to fill the second stage ROP chain;\nthen fill the memory area with the second stage ROP chain."),(0,i.yg)("li",{parentName:"ul"},"In the second stage, create the actual ROP chain and feed it to the program and profit.")),(0,i.yg)("p",null,"Follow the steps below."),(0,i.yg)("p",null,"Use ",(0,i.yg)("inlineCode",{parentName:"p"},"pmap")," or ",(0,i.yg)("inlineCode",{parentName:"p"},"vmmap")," in ",(0,i.yg)("inlineCode",{parentName:"p"},"pwndbg")," to discover the writable data section of the process.\nSelect an address in that section (",(0,i.yg)("strong",{parentName:"p"},"don't")," use the start address).\nThis is where you fill the 2nd stage data (the actual ROP chain)."),(0,i.yg)("p",null,"Who not use the start address?\nBecause ",(0,i.yg)("inlineCode",{parentName:"p"},"pop")," instructions (which decrease the ",(0,i.yg)("inlineCode",{parentName:"p"},"rsp"),") will go outside the memory region."),(0,i.yg)("p",null,"Create a first stage payload that calls ",(0,i.yg)("inlineCode",{parentName:"p"},"read")," to store the 2nd stage data to the newly found memory area.\nAfter that pivot the stack pointer to the memory area address."),(0,i.yg)("p",null,"At a given address in the executable you have a call to ",(0,i.yg)("inlineCode",{parentName:"p"},"read")," followed by a ",(0,i.yg)("inlineCode",{parentName:"p"},"leave; ret")," gadget.\nThis sequence of instructions allows you to read data and then pivot the stack."),(0,i.yg)("p",null,"The leave instruction fills the stack pointer (",(0,i.yg)("inlineCode",{parentName:"p"},"rsp"),") with the address of the frame pointer (",(0,i.yg)("inlineCode",{parentName:"p"},"rbp"),").\nIt's equivalent to:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-asm"},"mov rsp, rbp\npop rbp\n")),(0,i.yg)("p",null,"Write the actual ROP chain as a second stage payload like when we didn't have space constraints.\nThe 2nd stage will be stored to the memory area and the stack pointer will point to that."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Important!"),"\nBe careful when and where the stack pivoting takes place.\nAfter the ",(0,i.yg)("inlineCode",{parentName:"p"},"mov rsp, rbp")," part of the ",(0,i.yg)("inlineCode",{parentName:"p"},"leave")," instruction happens your stack will be pivoted, so the following ",(0,i.yg)("inlineCode",{parentName:"p"},"pop rbp")," will happen ",(0,i.yg)("strong",{parentName:"p"},"on the new stack"),".\nTake this offset into account when building the payload."),(0,i.yg)("h3",{id:"04-challenge---mprotect"},"04. Challenge - mprotect"),(0,i.yg)("p",null,"Combine everything you've learned until now and develop a complex payload to call ",(0,i.yg)("inlineCode",{parentName:"p"},"mprotect")," to change the permissions on a memory region to read+write+execute and then insert a shellcode to call ",(0,i.yg)("inlineCode",{parentName:"p"},'system("/bin/sh")'),"."),(0,i.yg)("h2",{id:"further-reading"},"Further Reading"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://syscalls.kernelgrok.com/"},"https://syscalls.kernelgrok.com/")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"http://articles.manugarg.com/systemcallinlinux2_6.html"},"http://articles.manugarg.com/systemcallinlinux2_6.html")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries#the-procedure-linkage-table-plt"},"https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries#the-procedure-linkage-table-plt")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://github.com/Gallopsled/pwntools-tutorial/tree/master/walkthrough"},"https://github.com/Gallopsled/pwntools-tutorial/tree/master/walkthrough"))))}c.isMDXComponent=!0},5680:(e,n,t)=>{t.d(n,{xA:()=>g,yg:()=>u});var a=t(6540);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},g=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,g=o(e,["components","mdxType","originalType","parentName"]),d=p(t),h=i,u=d["".concat(s,".").concat(h)]||d[h]||c[h]||l;return t?a.createElement(u,r(r({ref:n},g),{},{components:t})):a.createElement(u,r({ref:n},g))}));function u(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var l=t.length,r=new Array(l);r[0]=h;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[d]="string"==typeof e?e:i,r[1]=o;for(var p=2;p<l;p++)r[p]=t[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"}}]);